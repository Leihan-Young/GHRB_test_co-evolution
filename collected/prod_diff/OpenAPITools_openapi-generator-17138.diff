diff --git a/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java b/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java
index 20ce9f3ad40..284266b60bb 100644
--- a/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java
+++ b/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java
@@ -811,6 +811,15 @@ public class InlineModelResolver {
                             ap.setItems(schema);
                         }
                     }
+                } else if (ModelUtils.isComposedSchema(inner)) {
+                    String innerModelName = resolveModelName(inner.getTitle(), path + "_" + key);
+                    gatherInlineModels(inner, innerModelName);
+                    innerModelName = addSchemas(innerModelName, inner);
+                    Schema schema = new Schema().$ref(innerModelName);
+                    schema.setRequired(inner.getRequired());
+                    ap.setItems(schema);
+                } else {
+                    LOGGER.debug("Schema not yet handled in model resolver: {}", inner);
                 }
             }
             if (ModelUtils.isMapSchema(property)) {
@@ -833,6 +842,15 @@ public class InlineModelResolver {
                             property.setAdditionalProperties(schema);
                         }
                     }
+                } else if (ModelUtils.isComposedSchema(inner)) {
+                    String innerModelName = resolveModelName(inner.getTitle(), path + "_" + key);
+                    gatherInlineModels(inner, innerModelName);
+                    innerModelName = addSchemas(innerModelName, inner);
+                    Schema schema = new Schema().$ref(innerModelName);
+                    schema.setRequired(inner.getRequired());
+                    property.setAdditionalProperties(schema);
+                } else {
+                    LOGGER.debug("Schema not yet handled in model resolver: {}", inner);
                 }
             }
         }
diff --git a/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/JSON.java b/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/JSON.java
index dc729b10c5e..eb4c4733250 100644
--- a/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/JSON.java
+++ b/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/JSON.java
@@ -230,6 +230,9 @@ public class JSON {
         gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
         gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
         gsonBuilder.registerTypeAdapterFactory(new org.openapitools.client.model.AdditionalPropertiesClass.CustomTypeAdapterFactory());
+        gsonBuilder.registerTypeAdapterFactory(new org.openapitools.client.model.AllOfModelArrayAnyOf.CustomTypeAdapterFactory());
+        gsonBuilder.registerTypeAdapterFactory(new org.openapitools.client.model.AllOfModelArrayAnyOfAllOfLinkListColumn1.CustomTypeAdapterFactory());
+        gsonBuilder.registerTypeAdapterFactory(new org.openapitools.client.model.AllOfModelArrayAnyOfAllOfLinkListColumn1Value.CustomTypeAdapterFactory());
         gsonBuilder.registerTypeAdapterFactory(new org.openapitools.client.model.Apple.CustomTypeAdapterFactory());
         gsonBuilder.registerTypeAdapterFactory(new org.openapitools.client.model.AppleReq.CustomTypeAdapterFactory());
         gsonBuilder.registerTypeAdapterFactory(new org.openapitools.client.model.ArrayDefault.CustomTypeAdapterFactory());
diff --git a/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/model/AllOfModelArrayAnyOf.java b/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/model/AllOfModelArrayAnyOf.java
new file mode 100644
index 00000000000..0e1ea2ed1b7
--- /dev/null
+++ b/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/model/AllOfModelArrayAnyOf.java
@@ -0,0 +1,347 @@
+/*
+ * OpenAPI Petstore
+ * This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\
+ *
+ * The version of the OpenAPI document: 1.0.0
+ * 
+ *
+ * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
+ * https://openapi-generator.tech
+ * Do not edit the class manually.
+ */
+
+
+package org.openapitools.client.model;
+
+import java.util.Objects;
+import com.google.gson.TypeAdapter;
+import com.google.gson.annotations.JsonAdapter;
+import com.google.gson.annotations.SerializedName;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import java.util.Arrays;
+import org.openapitools.client.model.AllOfModelArrayAnyOfAllOfLinkListColumn1;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+
+import java.lang.reflect.Type;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.openapitools.client.JSON;
+
+/**
+ * AllOfModelArrayAnyOf
+ */
+@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
+public class AllOfModelArrayAnyOf {
+  public static final String SERIALIZED_NAME_ID = "id";
+  @SerializedName(SERIALIZED_NAME_ID)
+  private Long id;
+
+  public static final String SERIALIZED_NAME_NAME = "name";
+  @SerializedName(SERIALIZED_NAME_NAME)
+  private String name = "default-name";
+
+  public static final String SERIALIZED_NAME_LINK_LIST_COLUMN1 = "linkListColumn1";
+  @SerializedName(SERIALIZED_NAME_LINK_LIST_COLUMN1)
+  private AllOfModelArrayAnyOfAllOfLinkListColumn1 linkListColumn1;
+
+  public AllOfModelArrayAnyOf() {
+  }
+
+  public AllOfModelArrayAnyOf id(Long id) {
+    this.id = id;
+    return this;
+  }
+
+   /**
+   * Get id
+   * @return id
+  **/
+  @javax.annotation.Nullable
+  public Long getId() {
+    return id;
+  }
+
+  public void setId(Long id) {
+    this.id = id;
+  }
+
+
+  public AllOfModelArrayAnyOf name(String name) {
+    this.name = name;
+    return this;
+  }
+
+   /**
+   * Get name
+   * @return name
+  **/
+  @javax.annotation.Nonnull
+  public String getName() {
+    return name;
+  }
+
+  public void setName(String name) {
+    this.name = name;
+  }
+
+
+  public AllOfModelArrayAnyOf linkListColumn1(AllOfModelArrayAnyOfAllOfLinkListColumn1 linkListColumn1) {
+    this.linkListColumn1 = linkListColumn1;
+    return this;
+  }
+
+   /**
+   * Get linkListColumn1
+   * @return linkListColumn1
+  **/
+  @javax.annotation.Nullable
+  public AllOfModelArrayAnyOfAllOfLinkListColumn1 getLinkListColumn1() {
+    return linkListColumn1;
+  }
+
+  public void setLinkListColumn1(AllOfModelArrayAnyOfAllOfLinkListColumn1 linkListColumn1) {
+    this.linkListColumn1 = linkListColumn1;
+  }
+
+  /**
+   * A container for additional, undeclared properties.
+   * This is a holder for any undeclared properties as specified with
+   * the 'additionalProperties' keyword in the OAS document.
+   */
+  private Map<String, Object> additionalProperties;
+
+  /**
+   * Set the additional (undeclared) property with the specified name and value.
+   * If the property does not already exist, create it otherwise replace it.
+   *
+   * @param key name of the property
+   * @param value value of the property
+   * @return the AllOfModelArrayAnyOf instance itself
+   */
+  public AllOfModelArrayAnyOf putAdditionalProperty(String key, Object value) {
+    if (this.additionalProperties == null) {
+        this.additionalProperties = new HashMap<String, Object>();
+    }
+    this.additionalProperties.put(key, value);
+    return this;
+  }
+
+  /**
+   * Return the additional (undeclared) property.
+   *
+   * @return a map of objects
+   */
+  public Map<String, Object> getAdditionalProperties() {
+    return additionalProperties;
+  }
+
+  /**
+   * Return the additional (undeclared) property with the specified name.
+   *
+   * @param key name of the property
+   * @return an object
+   */
+  public Object getAdditionalProperty(String key) {
+    if (this.additionalProperties == null) {
+        return null;
+    }
+    return this.additionalProperties.get(key);
+  }
+
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    AllOfModelArrayAnyOf allOfModelArrayAnyOf = (AllOfModelArrayAnyOf) o;
+    return Objects.equals(this.id, allOfModelArrayAnyOf.id) &&
+        Objects.equals(this.name, allOfModelArrayAnyOf.name) &&
+        Objects.equals(this.linkListColumn1, allOfModelArrayAnyOf.linkListColumn1)&&
+        Objects.equals(this.additionalProperties, allOfModelArrayAnyOf.additionalProperties);
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(id, name, linkListColumn1, additionalProperties);
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    sb.append("class AllOfModelArrayAnyOf {\n");
+    sb.append("    id: ").append(toIndentedString(id)).append("\n");
+    sb.append("    name: ").append(toIndentedString(name)).append("\n");
+    sb.append("    linkListColumn1: ").append(toIndentedString(linkListColumn1)).append("\n");
+    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
+    sb.append("}");
+    return sb.toString();
+  }
+
+  /**
+   * Convert the given object to string with each line indented by 4 spaces
+   * (except the first line).
+   */
+  private String toIndentedString(Object o) {
+    if (o == null) {
+      return "null";
+    }
+    return o.toString().replace("\n", "\n    ");
+  }
+
+
+  public static HashSet<String> openapiFields;
+  public static HashSet<String> openapiRequiredFields;
+
+  static {
+    // a set of all properties/fields (JSON key names)
+    openapiFields = new HashSet<String>();
+    openapiFields.add("id");
+    openapiFields.add("name");
+    openapiFields.add("linkListColumn1");
+
+    // a set of required properties/fields (JSON key names)
+    openapiRequiredFields = new HashSet<String>();
+    openapiRequiredFields.add("name");
+  }
+
+ /**
+  * Validates the JSON Element and throws an exception if issues found
+  *
+  * @param jsonElement JSON Element
+  * @throws IOException if the JSON Element is invalid with respect to AllOfModelArrayAnyOf
+  */
+  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
+      if (jsonElement == null) {
+        if (!AllOfModelArrayAnyOf.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
+          throw new IllegalArgumentException(String.format("The required field(s) %s in AllOfModelArrayAnyOf is not found in the empty JSON string", AllOfModelArrayAnyOf.openapiRequiredFields.toString()));
+        }
+      }
+
+      // check to make sure all required properties/fields are present in the JSON string
+      for (String requiredField : AllOfModelArrayAnyOf.openapiRequiredFields) {
+        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
+          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
+        }
+      }
+        JsonObject jsonObj = jsonElement.getAsJsonObject();
+      if (!jsonObj.get("name").isJsonPrimitive()) {
+        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
+      }
+      // validate the optional field `linkListColumn1`
+      if (jsonObj.get("linkListColumn1") != null && !jsonObj.get("linkListColumn1").isJsonNull()) {
+        AllOfModelArrayAnyOfAllOfLinkListColumn1.validateJsonElement(jsonObj.get("linkListColumn1"));
+      }
+  }
+
+  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+       if (!AllOfModelArrayAnyOf.class.isAssignableFrom(type.getRawType())) {
+         return null; // this class only serializes 'AllOfModelArrayAnyOf' and its subtypes
+       }
+       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
+       final TypeAdapter<AllOfModelArrayAnyOf> thisAdapter
+                        = gson.getDelegateAdapter(this, TypeToken.get(AllOfModelArrayAnyOf.class));
+
+       return (TypeAdapter<T>) new TypeAdapter<AllOfModelArrayAnyOf>() {
+           @Override
+           public void write(JsonWriter out, AllOfModelArrayAnyOf value) throws IOException {
+             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
+             obj.remove("additionalProperties");
+             // serialize additional properties
+             if (value.getAdditionalProperties() != null) {
+               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
+                 if (entry.getValue() instanceof String)
+                   obj.addProperty(entry.getKey(), (String) entry.getValue());
+                 else if (entry.getValue() instanceof Number)
+                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
+                 else if (entry.getValue() instanceof Boolean)
+                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
+                 else if (entry.getValue() instanceof Character)
+                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
+                 else {
+                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
+                 }
+               }
+             }
+             elementAdapter.write(out, obj);
+           }
+
+           @Override
+           public AllOfModelArrayAnyOf read(JsonReader in) throws IOException {
+             JsonElement jsonElement = elementAdapter.read(in);
+             validateJsonElement(jsonElement);
+             JsonObject jsonObj = jsonElement.getAsJsonObject();
+             // store additional fields in the deserialized instance
+             AllOfModelArrayAnyOf instance = thisAdapter.fromJsonTree(jsonObj);
+             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
+               if (!openapiFields.contains(entry.getKey())) {
+                 if (entry.getValue().isJsonPrimitive()) { // primitive type
+                   if (entry.getValue().getAsJsonPrimitive().isString())
+                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
+                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
+                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
+                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
+                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
+                   else
+                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
+                 } else if (entry.getValue().isJsonArray()) {
+                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
+                 } else { // JSON object
+                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
+                 }
+               }
+             }
+             return instance;
+           }
+
+       }.nullSafe();
+    }
+  }
+
+ /**
+  * Create an instance of AllOfModelArrayAnyOf given an JSON string
+  *
+  * @param jsonString JSON string
+  * @return An instance of AllOfModelArrayAnyOf
+  * @throws IOException if the JSON string is invalid with respect to AllOfModelArrayAnyOf
+  */
+  public static AllOfModelArrayAnyOf fromJson(String jsonString) throws IOException {
+    return JSON.getGson().fromJson(jsonString, AllOfModelArrayAnyOf.class);
+  }
+
+ /**
+  * Convert an instance of AllOfModelArrayAnyOf to an JSON string
+  *
+  * @return JSON string
+  */
+  public String toJson() {
+    return JSON.getGson().toJson(this);
+  }
+}
+
diff --git a/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/model/AllOfModelArrayAnyOfAllOfLinkListColumn1.java b/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/model/AllOfModelArrayAnyOfAllOfLinkListColumn1.java
new file mode 100644
index 00000000000..76825bcae22
--- /dev/null
+++ b/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/model/AllOfModelArrayAnyOfAllOfLinkListColumn1.java
@@ -0,0 +1,308 @@
+/*
+ * OpenAPI Petstore
+ * This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\
+ *
+ * The version of the OpenAPI document: 1.0.0
+ * 
+ *
+ * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
+ * https://openapi-generator.tech
+ * Do not edit the class manually.
+ */
+
+
+package org.openapitools.client.model;
+
+import java.util.Objects;
+import com.google.gson.TypeAdapter;
+import com.google.gson.annotations.JsonAdapter;
+import com.google.gson.annotations.SerializedName;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.openapitools.client.model.AllOfModelArrayAnyOfAllOfLinkListColumn1Value;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+
+import java.lang.reflect.Type;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.openapitools.client.JSON;
+
+/**
+ * AllOfModelArrayAnyOfAllOfLinkListColumn1
+ */
+@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
+public class AllOfModelArrayAnyOfAllOfLinkListColumn1 {
+  public static final String SERIALIZED_NAME_VALUE = "value";
+  @SerializedName(SERIALIZED_NAME_VALUE)
+  private List<AllOfModelArrayAnyOfAllOfLinkListColumn1Value> value = new ArrayList<>();
+
+  public AllOfModelArrayAnyOfAllOfLinkListColumn1() {
+  }
+
+  public AllOfModelArrayAnyOfAllOfLinkListColumn1 value(List<AllOfModelArrayAnyOfAllOfLinkListColumn1Value> value) {
+    this.value = value;
+    return this;
+  }
+
+  public AllOfModelArrayAnyOfAllOfLinkListColumn1 addValueItem(AllOfModelArrayAnyOfAllOfLinkListColumn1Value valueItem) {
+    if (this.value == null) {
+      this.value = new ArrayList<>();
+    }
+    this.value.add(valueItem);
+    return this;
+  }
+
+   /**
+   * Get value
+   * @return value
+  **/
+  @javax.annotation.Nonnull
+  public List<AllOfModelArrayAnyOfAllOfLinkListColumn1Value> getValue() {
+    return value;
+  }
+
+  public void setValue(List<AllOfModelArrayAnyOfAllOfLinkListColumn1Value> value) {
+    this.value = value;
+  }
+
+  /**
+   * A container for additional, undeclared properties.
+   * This is a holder for any undeclared properties as specified with
+   * the 'additionalProperties' keyword in the OAS document.
+   */
+  private Map<String, Object> additionalProperties;
+
+  /**
+   * Set the additional (undeclared) property with the specified name and value.
+   * If the property does not already exist, create it otherwise replace it.
+   *
+   * @param key name of the property
+   * @param value value of the property
+   * @return the AllOfModelArrayAnyOfAllOfLinkListColumn1 instance itself
+   */
+  public AllOfModelArrayAnyOfAllOfLinkListColumn1 putAdditionalProperty(String key, Object value) {
+    if (this.additionalProperties == null) {
+        this.additionalProperties = new HashMap<String, Object>();
+    }
+    this.additionalProperties.put(key, value);
+    return this;
+  }
+
+  /**
+   * Return the additional (undeclared) property.
+   *
+   * @return a map of objects
+   */
+  public Map<String, Object> getAdditionalProperties() {
+    return additionalProperties;
+  }
+
+  /**
+   * Return the additional (undeclared) property with the specified name.
+   *
+   * @param key name of the property
+   * @return an object
+   */
+  public Object getAdditionalProperty(String key) {
+    if (this.additionalProperties == null) {
+        return null;
+    }
+    return this.additionalProperties.get(key);
+  }
+
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    AllOfModelArrayAnyOfAllOfLinkListColumn1 allOfModelArrayAnyOfAllOfLinkListColumn1 = (AllOfModelArrayAnyOfAllOfLinkListColumn1) o;
+    return Objects.equals(this.value, allOfModelArrayAnyOfAllOfLinkListColumn1.value)&&
+        Objects.equals(this.additionalProperties, allOfModelArrayAnyOfAllOfLinkListColumn1.additionalProperties);
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(value, additionalProperties);
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    sb.append("class AllOfModelArrayAnyOfAllOfLinkListColumn1 {\n");
+    sb.append("    value: ").append(toIndentedString(value)).append("\n");
+    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
+    sb.append("}");
+    return sb.toString();
+  }
+
+  /**
+   * Convert the given object to string with each line indented by 4 spaces
+   * (except the first line).
+   */
+  private String toIndentedString(Object o) {
+    if (o == null) {
+      return "null";
+    }
+    return o.toString().replace("\n", "\n    ");
+  }
+
+
+  public static HashSet<String> openapiFields;
+  public static HashSet<String> openapiRequiredFields;
+
+  static {
+    // a set of all properties/fields (JSON key names)
+    openapiFields = new HashSet<String>();
+    openapiFields.add("value");
+
+    // a set of required properties/fields (JSON key names)
+    openapiRequiredFields = new HashSet<String>();
+    openapiRequiredFields.add("value");
+  }
+
+ /**
+  * Validates the JSON Element and throws an exception if issues found
+  *
+  * @param jsonElement JSON Element
+  * @throws IOException if the JSON Element is invalid with respect to AllOfModelArrayAnyOfAllOfLinkListColumn1
+  */
+  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
+      if (jsonElement == null) {
+        if (!AllOfModelArrayAnyOfAllOfLinkListColumn1.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
+          throw new IllegalArgumentException(String.format("The required field(s) %s in AllOfModelArrayAnyOfAllOfLinkListColumn1 is not found in the empty JSON string", AllOfModelArrayAnyOfAllOfLinkListColumn1.openapiRequiredFields.toString()));
+        }
+      }
+
+      // check to make sure all required properties/fields are present in the JSON string
+      for (String requiredField : AllOfModelArrayAnyOfAllOfLinkListColumn1.openapiRequiredFields) {
+        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
+          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
+        }
+      }
+        JsonObject jsonObj = jsonElement.getAsJsonObject();
+      // ensure the json data is an array
+      if (!jsonObj.get("value").isJsonArray()) {
+        throw new IllegalArgumentException(String.format("Expected the field `value` to be an array in the JSON string but got `%s`", jsonObj.get("value").toString()));
+      }
+
+      JsonArray jsonArrayvalue = jsonObj.getAsJsonArray("value");
+      // validate the required field `value` (array)
+      for (int i = 0; i < jsonArrayvalue.size(); i++) {
+        AllOfModelArrayAnyOfAllOfLinkListColumn1Value.validateJsonElement(jsonArrayvalue.get(i));
+      };
+  }
+
+  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+       if (!AllOfModelArrayAnyOfAllOfLinkListColumn1.class.isAssignableFrom(type.getRawType())) {
+         return null; // this class only serializes 'AllOfModelArrayAnyOfAllOfLinkListColumn1' and its subtypes
+       }
+       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
+       final TypeAdapter<AllOfModelArrayAnyOfAllOfLinkListColumn1> thisAdapter
+                        = gson.getDelegateAdapter(this, TypeToken.get(AllOfModelArrayAnyOfAllOfLinkListColumn1.class));
+
+       return (TypeAdapter<T>) new TypeAdapter<AllOfModelArrayAnyOfAllOfLinkListColumn1>() {
+           @Override
+           public void write(JsonWriter out, AllOfModelArrayAnyOfAllOfLinkListColumn1 value) throws IOException {
+             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
+             obj.remove("additionalProperties");
+             // serialize additional properties
+             if (value.getAdditionalProperties() != null) {
+               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
+                 if (entry.getValue() instanceof String)
+                   obj.addProperty(entry.getKey(), (String) entry.getValue());
+                 else if (entry.getValue() instanceof Number)
+                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
+                 else if (entry.getValue() instanceof Boolean)
+                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
+                 else if (entry.getValue() instanceof Character)
+                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
+                 else {
+                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
+                 }
+               }
+             }
+             elementAdapter.write(out, obj);
+           }
+
+           @Override
+           public AllOfModelArrayAnyOfAllOfLinkListColumn1 read(JsonReader in) throws IOException {
+             JsonElement jsonElement = elementAdapter.read(in);
+             validateJsonElement(jsonElement);
+             JsonObject jsonObj = jsonElement.getAsJsonObject();
+             // store additional fields in the deserialized instance
+             AllOfModelArrayAnyOfAllOfLinkListColumn1 instance = thisAdapter.fromJsonTree(jsonObj);
+             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
+               if (!openapiFields.contains(entry.getKey())) {
+                 if (entry.getValue().isJsonPrimitive()) { // primitive type
+                   if (entry.getValue().getAsJsonPrimitive().isString())
+                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
+                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
+                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
+                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
+                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
+                   else
+                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
+                 } else if (entry.getValue().isJsonArray()) {
+                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
+                 } else { // JSON object
+                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
+                 }
+               }
+             }
+             return instance;
+           }
+
+       }.nullSafe();
+    }
+  }
+
+ /**
+  * Create an instance of AllOfModelArrayAnyOfAllOfLinkListColumn1 given an JSON string
+  *
+  * @param jsonString JSON string
+  * @return An instance of AllOfModelArrayAnyOfAllOfLinkListColumn1
+  * @throws IOException if the JSON string is invalid with respect to AllOfModelArrayAnyOfAllOfLinkListColumn1
+  */
+  public static AllOfModelArrayAnyOfAllOfLinkListColumn1 fromJson(String jsonString) throws IOException {
+    return JSON.getGson().fromJson(jsonString, AllOfModelArrayAnyOfAllOfLinkListColumn1.class);
+  }
+
+ /**
+  * Convert an instance of AllOfModelArrayAnyOfAllOfLinkListColumn1 to an JSON string
+  *
+  * @return JSON string
+  */
+  public String toJson() {
+    return JSON.getGson().toJson(this);
+  }
+}
+
diff --git a/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/model/AllOfModelArrayAnyOfAllOfLinkListColumn1Value.java b/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/model/AllOfModelArrayAnyOfAllOfLinkListColumn1Value.java
new file mode 100644
index 00000000000..89716f846d3
--- /dev/null
+++ b/samples/client/petstore/java/okhttp-gson/src/main/java/org/openapitools/client/model/AllOfModelArrayAnyOfAllOfLinkListColumn1Value.java
@@ -0,0 +1,272 @@
+/*
+ * OpenAPI Petstore
+ * This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\
+ *
+ * The version of the OpenAPI document: 1.0.0
+ * 
+ *
+ * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
+ * https://openapi-generator.tech
+ * Do not edit the class manually.
+ */
+
+
+package org.openapitools.client.model;
+
+import java.util.Objects;
+import com.google.gson.TypeAdapter;
+import com.google.gson.annotations.JsonAdapter;
+import com.google.gson.annotations.SerializedName;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import java.util.Arrays;
+import org.openapitools.client.model.Tag;
+import org.openapitools.client.model.User;
+import org.openapitools.jackson.nullable.JsonNullable;
+
+
+
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonParseException;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.annotations.JsonAdapter;
+import com.google.gson.annotations.SerializedName;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonParseException;
+
+import org.openapitools.client.JSON;
+
+@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
+public class AllOfModelArrayAnyOfAllOfLinkListColumn1Value extends AbstractOpenApiSchema {
+    private static final Logger log = Logger.getLogger(AllOfModelArrayAnyOfAllOfLinkListColumn1Value.class.getName());
+
+    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
+        @SuppressWarnings("unchecked")
+        @Override
+        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+            if (!AllOfModelArrayAnyOfAllOfLinkListColumn1Value.class.isAssignableFrom(type.getRawType())) {
+                return null; // this class only serializes 'AllOfModelArrayAnyOfAllOfLinkListColumn1Value' and its subtypes
+            }
+            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
+            final TypeAdapter<User> adapterUser = gson.getDelegateAdapter(this, TypeToken.get(User.class));
+            final TypeAdapter<Tag> adapterTag = gson.getDelegateAdapter(this, TypeToken.get(Tag.class));
+
+            return (TypeAdapter<T>) new TypeAdapter<AllOfModelArrayAnyOfAllOfLinkListColumn1Value>() {
+                @Override
+                public void write(JsonWriter out, AllOfModelArrayAnyOfAllOfLinkListColumn1Value value) throws IOException {
+                    if (value == null || value.getActualInstance() == null) {
+                        elementAdapter.write(out, null);
+                        return;
+                    }
+
+                    // check if the actual instance is of the type `User`
+                    if (value.getActualInstance() instanceof User) {
+                      JsonElement element = adapterUser.toJsonTree((User)value.getActualInstance());
+                      elementAdapter.write(out, element);
+                      return;
+                    }
+                    // check if the actual instance is of the type `Tag`
+                    if (value.getActualInstance() instanceof Tag) {
+                      JsonElement element = adapterTag.toJsonTree((Tag)value.getActualInstance());
+                      elementAdapter.write(out, element);
+                      return;
+                    }
+                    throw new IOException("Failed to serialize as the type doesn't match anyOf schemae: Tag, User");
+                }
+
+                @Override
+                public AllOfModelArrayAnyOfAllOfLinkListColumn1Value read(JsonReader in) throws IOException {
+                    Object deserialized = null;
+                    JsonElement jsonElement = elementAdapter.read(in);
+
+                    ArrayList<String> errorMessages = new ArrayList<>();
+                    TypeAdapter actualAdapter = elementAdapter;
+
+                    // deserialize User
+                    try {
+                      // validate the JSON object to see if any exception is thrown
+                      User.validateJsonElement(jsonElement);
+                      actualAdapter = adapterUser;
+                      AllOfModelArrayAnyOfAllOfLinkListColumn1Value ret = new AllOfModelArrayAnyOfAllOfLinkListColumn1Value();
+                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
+                      return ret;
+                    } catch (Exception e) {
+                      // deserialization failed, continue
+                      errorMessages.add(String.format("Deserialization for User failed with `%s`.", e.getMessage()));
+                      log.log(Level.FINER, "Input data does not match schema 'User'", e);
+                    }
+                    // deserialize Tag
+                    try {
+                      // validate the JSON object to see if any exception is thrown
+                      Tag.validateJsonElement(jsonElement);
+                      actualAdapter = adapterTag;
+                      AllOfModelArrayAnyOfAllOfLinkListColumn1Value ret = new AllOfModelArrayAnyOfAllOfLinkListColumn1Value();
+                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
+                      return ret;
+                    } catch (Exception e) {
+                      // deserialization failed, continue
+                      errorMessages.add(String.format("Deserialization for Tag failed with `%s`.", e.getMessage()));
+                      log.log(Level.FINER, "Input data does not match schema 'Tag'", e);
+                    }
+
+                    throw new IOException(String.format("Failed deserialization for AllOfModelArrayAnyOfAllOfLinkListColumn1Value: no class matches result, expected at least 1. Detailed failure message for anyOf schemas: %s. JSON: %s", errorMessages, jsonElement.toString()));
+                }
+            }.nullSafe();
+        }
+    }
+
+    // store a list of schema names defined in anyOf
+    public static final Map<String, Class<?>> schemas = new HashMap<String, Class<?>>();
+
+    public AllOfModelArrayAnyOfAllOfLinkListColumn1Value() {
+        super("anyOf", Boolean.FALSE);
+    }
+
+    public AllOfModelArrayAnyOfAllOfLinkListColumn1Value(Tag o) {
+        super("anyOf", Boolean.FALSE);
+        setActualInstance(o);
+    }
+
+    public AllOfModelArrayAnyOfAllOfLinkListColumn1Value(User o) {
+        super("anyOf", Boolean.FALSE);
+        setActualInstance(o);
+    }
+
+    static {
+        schemas.put("User", User.class);
+        schemas.put("Tag", Tag.class);
+    }
+
+    @Override
+    public Map<String, Class<?>> getSchemas() {
+        return AllOfModelArrayAnyOfAllOfLinkListColumn1Value.schemas;
+    }
+
+    /**
+     * Set the instance that matches the anyOf child schema, check
+     * the instance parameter is valid against the anyOf child schemas:
+     * Tag, User
+     *
+     * It could be an instance of the 'anyOf' schemas.
+     */
+    @Override
+    public void setActualInstance(Object instance) {
+        if (instance instanceof User) {
+            super.setActualInstance(instance);
+            return;
+        }
+
+        if (instance instanceof Tag) {
+            super.setActualInstance(instance);
+            return;
+        }
+
+        throw new RuntimeException("Invalid instance type. Must be Tag, User");
+    }
+
+    /**
+     * Get the actual instance, which can be the following:
+     * Tag, User
+     *
+     * @return The actual instance (Tag, User)
+     */
+    @Override
+    public Object getActualInstance() {
+        return super.getActualInstance();
+    }
+
+    /**
+     * Get the actual instance of `User`. If the actual instance is not `User`,
+     * the ClassCastException will be thrown.
+     *
+     * @return The actual instance of `User`
+     * @throws ClassCastException if the instance is not `User`
+     */
+    public User getUser() throws ClassCastException {
+        return (User)super.getActualInstance();
+    }
+    /**
+     * Get the actual instance of `Tag`. If the actual instance is not `Tag`,
+     * the ClassCastException will be thrown.
+     *
+     * @return The actual instance of `Tag`
+     * @throws ClassCastException if the instance is not `Tag`
+     */
+    public Tag getTag() throws ClassCastException {
+        return (Tag)super.getActualInstance();
+    }
+
+ /**
+  * Validates the JSON Element and throws an exception if issues found
+  *
+  * @param jsonElement JSON Element
+  * @throws IOException if the JSON Element is invalid with respect to AllOfModelArrayAnyOfAllOfLinkListColumn1Value
+  */
+  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
+    // validate anyOf schemas one by one
+    ArrayList<String> errorMessages = new ArrayList<>();
+    // validate the json string with User
+    try {
+      User.validateJsonElement(jsonElement);
+      return;
+    } catch (Exception e) {
+      errorMessages.add(String.format("Deserialization for User failed with `%s`.", e.getMessage()));
+      // continue to the next one
+    }
+    // validate the json string with Tag
+    try {
+      Tag.validateJsonElement(jsonElement);
+      return;
+    } catch (Exception e) {
+      errorMessages.add(String.format("Deserialization for Tag failed with `%s`.", e.getMessage()));
+      // continue to the next one
+    }
+    throw new IOException(String.format("The JSON string is invalid for AllOfModelArrayAnyOfAllOfLinkListColumn1Value with anyOf schemas: Tag, User. no class match the result, expected at least 1. Detailed failure message for anyOf schemas: %s. JSON: %s", errorMessages, jsonElement.toString()));
+    
+  }
+
+ /**
+  * Create an instance of AllOfModelArrayAnyOfAllOfLinkListColumn1Value given an JSON string
+  *
+  * @param jsonString JSON string
+  * @return An instance of AllOfModelArrayAnyOfAllOfLinkListColumn1Value
+  * @throws IOException if the JSON string is invalid with respect to AllOfModelArrayAnyOfAllOfLinkListColumn1Value
+  */
+  public static AllOfModelArrayAnyOfAllOfLinkListColumn1Value fromJson(String jsonString) throws IOException {
+    return JSON.getGson().fromJson(jsonString, AllOfModelArrayAnyOfAllOfLinkListColumn1Value.class);
+  }
+
+ /**
+  * Convert an instance of AllOfModelArrayAnyOfAllOfLinkListColumn1Value to an JSON string
+  *
+  * @return JSON string
+  */
+  public String toJson() {
+    return JSON.getGson().toJson(this);
+  }
+}
+
