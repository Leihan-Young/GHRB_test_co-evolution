diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java
new file mode 100644
index 000000000..33e908824
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java
@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.store.ConsumeQueue;
+import org.apache.rocketmq.store.DefaultMessageStore;
+import org.apache.rocketmq.store.DispatchRequest;
+import org.apache.rocketmq.store.SelectMappedBufferResult;
+import org.apache.rocketmq.tieredstore.common.AppendResult;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.container.TieredConsumeQueue;
+import org.apache.rocketmq.tieredstore.container.TieredContainerManager;
+import org.apache.rocketmq.tieredstore.container.TieredMessageQueueContainer;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mockito;
+
+public class TieredDispatcherTest {
+    TieredMessageStoreConfig storeConfig;
+    MessageQueue mq;
+    TieredMetadataStore metadataStore;
+
+    @Before
+    public void setUp() {
+        MemoryFileSegment.checkSize = false;
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setBrokerName(storeConfig.getBrokerName());
+        mq = new MessageQueue("TieredMessageQueueContainerTest", storeConfig.getBrokerName(), 0);
+        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        MemoryFileSegment.checkSize = true;
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
+        TieredContainerManager.getInstance(storeConfig).cleanup();
+    }
+
+    @Test
+    public void testDispatch() {
+        metadataStore.addQueue(mq, 6);
+        MemoryFileSegment segment = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG, mq, 1000, storeConfig);
+        segment.initPosition(segment.getSize());
+        metadataStore.updateFileSegment(segment);
+        metadataStore.updateFileSegment(segment);
+        segment = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE, mq, 6 * TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE, storeConfig);
+        metadataStore.updateFileSegment(segment);
+
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        DefaultMessageStore defaultMessageStore = Mockito.mock(DefaultMessageStore.class);
+        TieredDispatcher dispatcher = new TieredDispatcher(defaultMessageStore, storeConfig);
+
+        SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);
+        Mockito.when(defaultMessageStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
+        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 6, 7, MessageBufferUtilTest.MSG_LEN, 1);
+        dispatcher.dispatch(request);
+        Assert.assertNotNull(containerManager.getMQContainer(mq));
+        Assert.assertEquals(7, containerManager.getMQContainer(mq).getDispatchOffset());
+
+        TieredMessageQueueContainer container = containerManager.getOrCreateMQContainer(mq);
+        container.commit(true);
+        Assert.assertEquals(6, container.getBuildCQMaxOffset());
+
+        dispatcher.buildCQAndIndexFile();
+        Assert.assertEquals(7, container.getConsumeQueueMaxOffset());
+
+        ByteBuffer buffer1 = MessageBufferUtilTest.buildMessageBuffer();
+        buffer1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);
+        container.appendCommitLog(buffer1);
+        ByteBuffer buffer2 = MessageBufferUtilTest.buildMessageBuffer();
+        buffer2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 8);
+        container.appendCommitLog(buffer2);
+        ByteBuffer buffer3 = MessageBufferUtilTest.buildMessageBuffer();
+        buffer3.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 9);
+        container.appendCommitLog(buffer3);
+        container.commitCommitLog();
+        Assert.assertEquals(10, container.getDispatchOffset());
+
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 8, 8, 0, 0, 0, buffer1);
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 9, 9, 0, 0, 0, buffer2);
+        dispatcher.buildCQAndIndexFile();
+        Assert.assertEquals(7, container.getConsumeQueueMaxOffset());
+        Assert.assertEquals(7, container.getDispatchOffset());
+
+
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 7, 7, 0, 0, 0, buffer1);
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 8, 8, 0, 0, 0, buffer2);
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 9, 9, 0, 0, 0, buffer3);
+        dispatcher.buildCQAndIndexFile();
+        Assert.assertEquals(10, container.getConsumeQueueMaxOffset());
+    }
+
+    @Test
+    public void testDispatchByMQContainer() {
+        metadataStore.addQueue(mq, 6);
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        DefaultMessageStore defaultStore = Mockito.mock(DefaultMessageStore.class);
+        Mockito.when(defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).thenReturn(Mockito.mock(ConsumeQueue.class));
+        TieredDispatcher dispatcher = new TieredDispatcher(defaultStore, storeConfig);
+
+        Mockito.when(defaultStore.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(0L);
+        Mockito.when(defaultStore.getMaxOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(9L);
+
+        ByteBuffer cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);
+        cqItem.putLong(7);
+        cqItem.putInt(MessageBufferUtilTest.MSG_LEN);
+        cqItem.putLong(1);
+        cqItem.flip();
+        SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);
+        Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(6)).thenReturn(mockResult);
+
+        cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);
+        cqItem.putLong(8);
+        cqItem.putInt(MessageBufferUtilTest.MSG_LEN);
+        cqItem.putLong(1);
+        cqItem.flip();
+        mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);
+
+        Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(7)).thenReturn(mockResult);
+
+        mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);
+        Mockito.when(defaultStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
+
+        ByteBuffer msg = MessageBufferUtilTest.buildMessageBuffer();
+        msg.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);
+        mockResult = new SelectMappedBufferResult(0, msg, MessageBufferUtilTest.MSG_LEN, null);
+        Mockito.when(defaultStore.selectOneMessageByOffset(8, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
+
+        dispatcher.dispatchByMQContainer(containerManager.getOrCreateMQContainer(mq));
+        Assert.assertEquals(8, containerManager.getMQContainer(mq).getDispatchOffset());
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java
new file mode 100644
index 000000000..1134729e0
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java
@@ -0,0 +1,292 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.lang3.SystemUtils;
+import org.apache.commons.lang3.tuple.Triple;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.store.DispatchRequest;
+import org.apache.rocketmq.store.GetMessageResult;
+import org.apache.rocketmq.store.GetMessageStatus;
+import org.apache.rocketmq.store.QueryMessageResult;
+import org.apache.rocketmq.store.SelectMappedBufferResult;
+import org.apache.rocketmq.tieredstore.common.AppendResult;
+import org.apache.rocketmq.tieredstore.common.BoundaryType;
+import org.apache.rocketmq.tieredstore.common.SelectMappedBufferResultWrapper;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.container.TieredContainerManager;
+import org.apache.rocketmq.tieredstore.container.TieredMessageQueueContainer;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.awaitility.Awaitility;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Assume;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TieredMessageFetcherTest {
+    TieredMessageStoreConfig storeConfig;
+    MessageQueue mq;
+    TieredMetadataStore metadataStore;
+
+    @Before
+    public void setUp() {
+        MemoryFileSegment.checkSize = false;
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setBrokerName(storeConfig.getBrokerName());
+        storeConfig.setReadAheadCacheExpireDuration(Long.MAX_VALUE);
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setTieredStoreIndexFileMaxHashSlotNum(2);
+        storeConfig.setTieredStoreIndexFileMaxIndexNum(3);
+        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+        mq = new MessageQueue("TieredMessageFetcherTest", storeConfig.getBrokerName(), 0);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        MemoryFileSegment.checkSize = true;
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
+        TieredContainerManager.getInstance(storeConfig).cleanup();
+    }
+
+    public Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> buildFetcher() {
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        GetMessageResult getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE, getMessageResult.getStatus());
+
+        TieredMessageQueueContainer container = containerManager.getOrCreateMQContainer(mq);
+        container.initOffset(0);
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.NO_MESSAGE_IN_QUEUE, getMessageResult.getStatus());
+
+        ByteBuffer msg1 = MessageBufferUtilTest.buildMessageBuffer();
+        msg1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
+        msg1.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, 0);
+        AppendResult result = container.appendCommitLog(msg1);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        ByteBuffer msg2 = MessageBufferUtilTest.buildMessageBuffer();
+        msg2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
+        msg2.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, MessageBufferUtilTest.MSG_LEN);
+        container.appendCommitLog(msg2);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, 0, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 1, MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        container.commit(true);
+        return Triple.of(fetcher, msg1, msg2);
+    }
+
+    @Test
+    public void testGetMessageFromTieredStoreAsync() {
+        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
+        TieredMessageFetcher fetcher = triple.getLeft();
+        ByteBuffer msg1 = triple.getMiddle();
+        ByteBuffer msg2 = triple.getRight();
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getMQContainer(mq);
+        Assert.assertNotNull(container);
+
+        GetMessageResult getMessageResult = fetcher.getMessageFromTieredStoreAsync(container, 0, 32).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
+        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
+        Assert.assertEquals(msg2, getMessageResult.getMessageBufferList().get(1));
+
+        AppendResult result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 2, storeConfig.getReadAheadMessageSizeThreshold(), MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+        container.commit(true);
+        getMessageResult = fetcher.getMessageFromTieredStoreAsync(container, 0, 32).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
+    }
+
+    @Test
+    public void testGetMessageFromCacheAsync() {
+        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
+        TieredMessageFetcher fetcher = triple.getLeft();
+        ByteBuffer msg1 = triple.getMiddle();
+        ByteBuffer msg2 = triple.getRight();
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getMQContainer(mq);
+        Assert.assertNotNull(container);
+
+        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, new ArrayList<>());
+        Assert.assertEquals(0, fetcher.readAheadCache.estimatedSize());
+        fetcher.putMessageToCache(container, 0, new SelectMappedBufferResult(0, msg1, msg1.remaining(), null), 0, 0, 1);
+        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
+
+        GetMessageResult getMessageResult = fetcher.getMessageFromCacheAsync(container, "group", 0, 32).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(1, getMessageResult.getMessageBufferList().size());
+        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
+
+        Awaitility.waitAtMost(3, TimeUnit.SECONDS)
+            .until(() -> fetcher.readAheadCache.estimatedSize() == 2);
+        ArrayList<SelectMappedBufferResultWrapper> wrapperList = new ArrayList<>();
+        wrapperList.add(fetcher.getMessageFromCache(container, 0));
+        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, wrapperList);
+        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
+        wrapperList.clear();
+        wrapperList.add(fetcher.getMessageFromCache(container, 1));
+        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, wrapperList);
+        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
+
+        SelectMappedBufferResult messageFromCache = fetcher.getMessageFromCache(container, 1).getDuplicateResult();
+        fetcher.recordCacheAccess(container, "group", 0, wrapperList);
+        Assert.assertNotNull(messageFromCache);
+        Assert.assertEquals(msg2, messageFromCache.getByteBuffer());
+        Assert.assertEquals(0, fetcher.readAheadCache.estimatedSize());
+    }
+
+    @Test
+    public void testGetMessageAsync() {
+        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
+        TieredMessageFetcher fetcher = triple.getLeft();
+        ByteBuffer msg1 = triple.getMiddle();
+        ByteBuffer msg2 = triple.getRight();
+
+        GetMessageResult getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), -1, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.OFFSET_TOO_SMALL, getMessageResult.getStatus());
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 2, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.OFFSET_OVERFLOW_ONE, getMessageResult.getStatus());
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 3, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.OFFSET_OVERFLOW_BADLY, getMessageResult.getStatus());
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
+        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
+        Assert.assertEquals(msg2, getMessageResult.getMessageBufferList().get(1));
+    }
+
+    @Test
+    public void testGetMessageStoreTimeStampAsync() {
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
+        container.initOffset(0);
+
+        ByteBuffer msg1 = MessageBufferUtilTest.buildMessageBuffer();
+        msg1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
+        msg1.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, 0);
+        long currentTimeMillis1 = System.currentTimeMillis();
+        msg1.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, currentTimeMillis1);
+        AppendResult result = container.appendCommitLog(msg1);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        ByteBuffer msg2 = MessageBufferUtilTest.buildMessageBuffer();
+        msg2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
+        msg2.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, MessageBufferUtilTest.MSG_LEN);
+        long currentTimeMillis2 = System.currentTimeMillis();
+        msg2.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, currentTimeMillis2);
+        container.appendCommitLog(msg2);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, 0, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 1, MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        container.commit(true);
+
+        long result1 = fetcher.getEarliestMessageTimeAsync(mq.getTopic(), mq.getQueueId()).join();
+        long result2 = fetcher.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 0).join();
+        Assert.assertEquals(result1, result2);
+        Assert.assertEquals(currentTimeMillis1, result1);
+
+        long result3 = fetcher.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 1).join();
+        Assert.assertEquals(currentTimeMillis2, result3);
+    }
+
+    @Test
+    public void testGetOffsetInQueueByTime() {
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
+        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 50, 0, MessageBufferUtilTest.MSG_LEN, 0), true);
+        container.commit(true);
+        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+
+
+        long timestamp = System.currentTimeMillis();
+        ByteBuffer buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 50);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp);
+        container.initOffset(50);
+        container.appendCommitLog(buffer, true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, MessageBufferUtilTest.MSG_LEN, 0, timestamp, 50, "", "", 0, 0, null), true);
+        container.commit(true);
+        Assert.assertEquals(50, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+    }
+
+    @Test
+    public void testQueryMessageAsync() {
+        // skip this test on windows
+        Assume.assumeFalse(SystemUtils.IS_OS_WINDOWS);
+
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        Assert.assertEquals(0, fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
+
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
+        Assert.assertEquals(0, fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
+
+        container.initOffset(0);
+        ByteBuffer buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
+        container.appendCommitLog(buffer);
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
+        container.appendCommitLog(buffer);
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 2);
+        container.appendCommitLog(buffer);
+
+        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "key", 0, 0, null);
+        container.appendIndexFile(request);
+        request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "key", 0, 0, null);
+        container.appendIndexFile(request);
+        request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "another-key", 0, 0, null);
+        container.appendIndexFile(request);
+        container.commit(true);
+        Assert.assertEquals(1, fetcher.queryMessageAsync(mq.getTopic(), "key", 1, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
+
+        QueryMessageResult result = fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join();
+        Assert.assertEquals(2, result.getMessageMapedList().size());
+        Assert.assertEquals(1, result.getMessageMapedList().get(0).getByteBuffer().getLong(MessageBufferUtil.QUEUE_OFFSET_POSITION));
+        Assert.assertEquals(0, result.getMessageMapedList().get(1).getByteBuffer().getLong(MessageBufferUtil.QUEUE_OFFSET_POSITION));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java
new file mode 100644
index 000000000..800b10938
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore;
+
+import io.opentelemetry.api.common.Attributes;
+import io.opentelemetry.sdk.OpenTelemetrySdk;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.HashSet;
+import java.util.Properties;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.BrokerConfig;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
+import org.apache.rocketmq.remoting.Configuration;
+import org.apache.rocketmq.store.CommitLog;
+import org.apache.rocketmq.store.DefaultMessageStore;
+import org.apache.rocketmq.store.GetMessageResult;
+import org.apache.rocketmq.store.GetMessageStatus;
+import org.apache.rocketmq.store.MessageStore;
+import org.apache.rocketmq.store.QueryMessageResult;
+import org.apache.rocketmq.store.SelectMappedBufferResult;
+import org.apache.rocketmq.store.config.MessageStoreConfig;
+import org.apache.rocketmq.store.plugin.MessageStorePluginContext;
+import org.apache.rocketmq.tieredstore.common.BoundaryType;
+import org.apache.rocketmq.tieredstore.container.TieredContainerManager;
+import org.apache.rocketmq.tieredstore.container.TieredMessageQueueContainer;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mockito;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class TieredMessageStoreTest {
+    private MessageStoreConfig storeConfig;
+    private MessageQueue mq;
+    private MessageStore nextStore;
+    private TieredMessageStore store;
+    private TieredMessageFetcher fetcher;
+    private Configuration configuration;
+    private TieredContainerManager containerManager;
+
+    @Before
+    public void setUp() {
+        storeConfig = new MessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        mq = new MessageQueue("TieredMessageStoreTest", "broker", 0);
+
+        nextStore = Mockito.mock(DefaultMessageStore.class);
+        CommitLog commitLog = mock(CommitLog.class);
+        when(commitLog.getMinOffset()).thenReturn(100L);
+        when(nextStore.getCommitLog()).thenReturn(commitLog);
+
+        BrokerConfig brokerConfig = new BrokerConfig();
+        brokerConfig.setBrokerName("broker");
+        configuration = new Configuration(LoggerFactory.getLogger(TieredStoreUtil.TIERED_STORE_LOGGER_NAME), "/tmp/rmqut/config", storeConfig, brokerConfig);
+        Properties properties = new Properties();
+        properties.setProperty("tieredBackendServiceProvider", "org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        configuration.registerConfig(properties);
+        MessageStorePluginContext context = new MessageStorePluginContext(new MessageStoreConfig(), null, null, brokerConfig, configuration);
+
+        store = new TieredMessageStore(context, nextStore);
+
+        fetcher = Mockito.mock(TieredMessageFetcher.class);
+        try {
+            Field field = store.getClass().getDeclaredField("fetcher");
+            field.setAccessible(true);
+            field.set(store, fetcher);
+        } catch (NoSuchFieldException | IllegalAccessException e) {
+            Assert.fail(e.getClass().getCanonicalName() + ": " + e.getMessage());
+        }
+
+        TieredContainerManager.getInstance(store.getStoreConfig()).getOrCreateMQContainer(mq);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(store.getStoreConfig()).destroy();
+        TieredContainerManager.getInstance(store.getStoreConfig()).cleanup();
+    }
+
+    private void mockContainer() {
+        containerManager = Mockito.mock(TieredContainerManager.class);
+        TieredMessageQueueContainer container = Mockito.mock(TieredMessageQueueContainer.class);
+        when(container.getConsumeQueueCommitOffset()).thenReturn(Long.MAX_VALUE);
+        when(containerManager.getMQContainer(mq)).thenReturn(container);
+        try {
+            Field field = store.getClass().getDeclaredField("containerManager");
+            field.setAccessible(true);
+            field.set(store, containerManager);
+        } catch (NoSuchFieldException | IllegalAccessException e) {
+            Assert.fail(e.getClass().getCanonicalName() + ": " + e.getMessage());
+        }
+    }
+
+    @Test
+    public void testViaTieredStorage() {
+        mockContainer();
+        Properties properties = new Properties();
+        // TieredStorageLevel.DISABLE
+        properties.setProperty("tieredStorageLevel", "0");
+        configuration.update(properties);
+        Assert.assertFalse(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        // TieredStorageLevel.NOT_IN_DISK
+        properties.setProperty("tieredStorageLevel", "1");
+        configuration.update(properties);
+        when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(false);
+        Assert.assertTrue(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);
+        Assert.assertFalse(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        // TieredStorageLevel.NOT_IN_MEM
+        properties.setProperty("tieredStorageLevel", "2");
+        configuration.update(properties);
+        Mockito.when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(false);
+        Mockito.when(nextStore.checkInMemByConsumeOffset(anyString(), anyInt(), anyLong(), anyInt())).thenReturn(true);
+        Assert.assertTrue(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        Mockito.when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);
+        Mockito.when(nextStore.checkInMemByConsumeOffset(anyString(), anyInt(), anyLong(), anyInt())).thenReturn(false);
+        Assert.assertTrue(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        Mockito.when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);
+        Mockito.when(nextStore.checkInMemByConsumeOffset(anyString(), anyInt(), anyLong(), anyInt())).thenReturn(true);
+        Assert.assertFalse(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        // TieredStorageLevel.FORCE
+        properties.setProperty("tieredStorageLevel", "3");
+        configuration.update(properties);
+        Assert.assertTrue(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+    }
+
+    @Test
+    public void testGetMessageAsync() {
+        mockContainer();
+        GetMessageResult result1 = new GetMessageResult();
+        result1.setStatus(GetMessageStatus.FOUND);
+        GetMessageResult result2 = new GetMessageResult();
+        result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);
+
+        when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));
+        when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);
+        Assert.assertSame(result1, store.getMessage("group", mq.getTopic(), mq.getQueueId(), 0, 0, null));
+
+        result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);
+        Assert.assertSame(result1, store.getMessage("group", mq.getTopic(), mq.getQueueId(), 0, 0, null));
+
+        result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);
+        Assert.assertSame(result1, store.getMessage("group", mq.getTopic(), mq.getQueueId(), 0, 0, null));
+
+        result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);
+        Assert.assertSame(result1, store.getMessage("group", mq.getTopic(), mq.getQueueId(), 0, 0, null));
+
+        // TieredStorageLevel.FORCE
+        Properties properties = new Properties();
+        properties.setProperty("tieredStorageLevel", "3");
+        configuration.update(properties);
+        when(nextStore.checkInDiskByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);
+        Assert.assertSame(result2, store.getMessage("group", mq.getTopic(), mq.getQueueId(), 0, 0, null));
+    }
+
+    @Test
+    public void testGetEarliestMessageTimeAsync() {
+        when(fetcher.getEarliestMessageTimeAsync(anyString(), anyInt())).thenReturn(CompletableFuture.completedFuture(1L));
+        Assert.assertEquals(1, (long) store.getEarliestMessageTimeAsync(mq.getTopic(), mq.getQueueId()).join());
+
+        when(fetcher.getEarliestMessageTimeAsync(anyString(), anyInt())).thenReturn(CompletableFuture.completedFuture(-1L));
+        when(nextStore.getEarliestMessageTime(anyString(), anyInt())).thenReturn(2L);
+        Assert.assertEquals(2, (long) store.getEarliestMessageTimeAsync(mq.getTopic(), mq.getQueueId()).join());
+    }
+
+    @Test
+    public void testGetMessageStoreTimeStampAsync() {
+        mockContainer();
+        // TieredStorageLevel.DISABLE
+        Properties properties = new Properties();
+        properties.setProperty("tieredStorageLevel", "DISABLE");
+        configuration.update(properties);
+        when(fetcher.getMessageStoreTimeStampAsync(anyString(), anyInt(), anyLong())).thenReturn(CompletableFuture.completedFuture(1L));
+        when(nextStore.getMessageStoreTimeStampAsync(anyString(), anyInt(), anyLong())).thenReturn(CompletableFuture.completedFuture(2L));
+        when(nextStore.getMessageStoreTimeStamp(anyString(), anyInt(), anyLong())).thenReturn(3L);
+        Assert.assertEquals(2, (long) store.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 0).join());
+
+        // TieredStorageLevel.FORCE
+        properties.setProperty("tieredStorageLevel", "FORCE");
+        configuration.update(properties);
+        Assert.assertEquals(1, (long) store.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 0).join());
+
+        Mockito.when(fetcher.getMessageStoreTimeStampAsync(anyString(), anyInt(), anyLong())).thenReturn(CompletableFuture.completedFuture(-1L));
+        Assert.assertEquals(3, (long) store.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 0).join());
+    }
+
+    @Test
+    public void testGetOffsetInQueueByTime() {
+        Mockito.when(fetcher.getOffsetInQueueByTime(anyString(), anyInt(), anyLong(), eq(BoundaryType.LOWER))).thenReturn(1L);
+        Mockito.when(nextStore.getOffsetInQueueByTime(anyString(), anyInt(), anyLong())).thenReturn(2L);
+        Mockito.when(nextStore.getEarliestMessageTime()).thenReturn(100L);
+        Assert.assertEquals(1, store.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+        Assert.assertEquals(2, store.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 1000, BoundaryType.LOWER));
+
+        Mockito.when(fetcher.getOffsetInQueueByTime(anyString(), anyInt(), anyLong(), eq(BoundaryType.LOWER))).thenReturn(-1L);
+        Assert.assertEquals(2, store.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+    }
+
+    @Test
+    public void testQueryMessage() {
+        QueryMessageResult result1 = new QueryMessageResult();
+        result1.addMessage(new SelectMappedBufferResult(0, null, 0, null));
+        result1.addMessage(new SelectMappedBufferResult(0, null, 0, null));
+        when(fetcher.queryMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyLong())).thenReturn(CompletableFuture.completedFuture(result1));
+        QueryMessageResult result2 = new QueryMessageResult();
+        result2.addMessage(new SelectMappedBufferResult(0, null, 0, null));
+        when(nextStore.queryMessage(anyString(), anyString(), anyInt(), anyLong(), anyLong())).thenReturn(result2);
+        when(nextStore.getEarliestMessageTime()).thenReturn(100L);
+        Assert.assertEquals(2, store.queryMessage(mq.getTopic(), "key", 32, 0, 99).getMessageMapedList().size());
+        Assert.assertEquals(1, store.queryMessage(mq.getTopic(), "key", 32, 100, 200).getMessageMapedList().size());
+        Assert.assertEquals(3, store.queryMessage(mq.getTopic(), "key", 32, 0, 200).getMessageMapedList().size());
+    }
+
+    @Test
+    public void testGetMinOffsetInQueue() {
+        mockContainer();
+        TieredMessageQueueContainer container = containerManager.getMQContainer(mq);
+        when(nextStore.getMinOffsetInQueue(anyString(), anyInt())).thenReturn(100L);
+        when(containerManager.getMQContainer(mq)).thenReturn(null);
+        Assert.assertEquals(100L, store.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId()));
+
+        when(containerManager.getMQContainer(mq)).thenReturn(container);
+        when(container.getConsumeQueueMinOffset()).thenReturn(10L);
+        Assert.assertEquals(10L, store.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId()));
+    }
+
+    @Test
+    public void testCleanUnusedTopics() {
+        Set<String> topicSet = new HashSet<>();
+        store.cleanUnusedTopic(topicSet);
+        Assert.assertNull(TieredContainerManager.getInstance(store.getStoreConfig()).getMQContainer(mq));
+        Assert.assertNull(TieredStoreUtil.getMetadataStore(store.getStoreConfig()).getTopic(mq.getTopic()));
+        Assert.assertNull(TieredStoreUtil.getMetadataStore(store.getStoreConfig()).getQueue(mq));
+    }
+
+    @Test
+    public void testDeleteTopics() {
+        Set<String> topicSet = new HashSet<>();
+        topicSet.add(mq.getTopic());
+        store.deleteTopics(topicSet);
+        Assert.assertNull(TieredContainerManager.getInstance(store.getStoreConfig()).getMQContainer(mq));
+        Assert.assertNull(TieredStoreUtil.getMetadataStore(store.getStoreConfig()).getTopic(mq.getTopic()));
+        Assert.assertNull(TieredStoreUtil.getMetadataStore(store.getStoreConfig()).getQueue(mq));
+    }
+
+    @Test
+    public void testMetrics() {
+        store.getMetricsView();
+        store.initMetrics(OpenTelemetrySdk.builder().build().getMeter(""),
+            Attributes::builder);
+    }
+
+    @Test
+    public void testShutdownAndDestroy() {
+        store.destroy();
+//        store.shutdown();
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/CommonTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/CommonTest.java
new file mode 100644
index 000000000..5210a0f69
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/CommonTest.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.common;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import org.apache.commons.lang3.tuple.Pair;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class CommonTest {
+    @Test
+    public void testInflightRequestFuture() {
+        List<Pair<Integer, CompletableFuture<Long>>> futureList = new ArrayList<>();
+        futureList.add(Pair.of(32, CompletableFuture.completedFuture(1031L)));
+        futureList.add(Pair.of(256, CompletableFuture.completedFuture(1287L)));
+        InflightRequestFuture future = new InflightRequestFuture(1000, futureList);
+
+        Assert.assertEquals(1000, future.getStartOffset());
+        Assert.assertTrue(future.isFirstDone());
+        Assert.assertTrue(future.isAllDone());
+        Assert.assertEquals(1031, future.getFirstFuture().join().longValue());
+        Assert.assertEquals(-1L, future.getFuture(0).join().longValue());
+        Assert.assertEquals(1031L, future.getFuture(1024).join().longValue());
+        Assert.assertEquals(1287L, future.getFuture(1200).join().longValue());
+        Assert.assertEquals(-1L, future.getFuture(2000).join().longValue());
+        Assert.assertEquals(1287L, future.getLastFuture().join().longValue());
+        Assert.assertArrayEquals(futureList.stream().map(Pair::getRight).toArray(), future.getAllFuture().toArray());
+    }
+
+    @Test
+    public void testInflightRequestKey() {
+        InflightRequestKey requestKey1 = new InflightRequestKey("group", 0, 0);
+        InflightRequestKey requestKey2 = new InflightRequestKey("group", 1, 1);
+        Assert.assertEquals(requestKey1, requestKey2);
+        Assert.assertEquals(requestKey1.hashCode(), requestKey2.hashCode());
+        Assert.assertEquals(requestKey1.getGroup(), requestKey2.getGroup());
+        Assert.assertNotEquals(requestKey1.getOffset(), requestKey2.getOffset());
+        Assert.assertNotEquals(requestKey1.getBatchSize(), requestKey2.getBatchSize());
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredContainerManagerTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredContainerManagerTest.java
new file mode 100644
index 000000000..1c8254d98
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredContainerManagerTest.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.container;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.awaitility.Awaitility;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TieredContainerManagerTest {
+    TieredMessageStoreConfig storeConfig;
+    MessageQueue mq;
+    TieredMetadataStore metadataStore;
+
+    @Before
+    public void setUp() {
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setBrokerName(storeConfig.getBrokerName());
+        mq = new MessageQueue("TieredContainerManagerTest", storeConfig.getBrokerName(), 0);
+        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
+        TieredContainerManager.getInstance(storeConfig).cleanup();
+    }
+
+
+    @Test
+    public void testLoadAndDestroy() {
+        metadataStore.addTopic(mq.getTopic(), 0);
+        metadataStore.addQueue(mq, 100);
+        MessageQueue mq1 = new MessageQueue(mq.getTopic(), mq.getBrokerName(), 1);
+        metadataStore.addQueue(mq1, 200);
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        boolean load = containerManager.load();
+        Assert.assertTrue(load);
+
+        Awaitility.await().atMost(3, TimeUnit.SECONDS).until(() -> containerManager.getAllMQContainer().size() == 2);
+
+        TieredMessageQueueContainer container = containerManager.getMQContainer(mq);
+        Assert.assertNotNull(container);
+        Assert.assertEquals(100, container.getDispatchOffset());
+
+        TieredMessageQueueContainer container1 = containerManager.getMQContainer(mq1);
+        Assert.assertNotNull(container1);
+        Assert.assertEquals(200, container1.getDispatchOffset());
+
+        containerManager.destroyContainer(mq);
+        Assert.assertTrue(container.isClosed());
+        Assert.assertNull(containerManager.getMQContainer(mq));
+        Assert.assertNull(metadataStore.getQueue(mq));
+
+        containerManager.destroy();
+        Assert.assertTrue(container1.isClosed());
+        Assert.assertNull(containerManager.getMQContainer(mq1));
+        Assert.assertNull(metadataStore.getQueue(mq1));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileQueueTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredFileQueueTest.java
similarity index 93%
rename from tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileQueueTest.java
rename to tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredFileQueueTest.java
index a6bf09f6f..6385fa281 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileQueueTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredFileQueueTest.java
@@ -14,17 +14,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.rocketmq.store.tiered.container;
+package org.apache.rocketmq.tieredstore.container;
 
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.UUID;
 import org.apache.commons.io.FileUtils;
 import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.tiered.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.store.tiered.metadata.TieredMetadataStore;
-import org.apache.rocketmq.store.tiered.mock.MemoryFileSegment;
-import org.apache.rocketmq.store.tiered.util.TieredStoreUtil;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
@@ -37,14 +39,14 @@ public class TieredFileQueueTest {
     @Before
     public void setUp() {
         storeConfig = new TieredMessageStoreConfig();
-        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "rmqut");
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.store.tiered.mock.MemoryFileSegment");
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
         queue = new MessageQueue("TieredFileQueueTest", storeConfig.getBrokerName(), 0);
     }
 
     @After
     public void tearDown() throws IOException {
-        FileUtils.deleteDirectory(new File("/tmp/rmqut"));
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
         TieredStoreUtil.getMetadataStore(storeConfig).destroy();
     }
 
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredIndexFileTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredIndexFileTest.java
similarity index 89%
rename from tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredIndexFileTest.java
rename to tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredIndexFileTest.java
index f4f517f65..c30ee2a55 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredIndexFileTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredIndexFileTest.java
@@ -14,21 +14,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.rocketmq.store.tiered.container;
+package org.apache.rocketmq.tieredstore.container;
 
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.List;
+import java.util.UUID;
 import java.util.concurrent.TimeUnit;
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.lang3.SystemUtils;
 import org.apache.commons.lang3.tuple.Pair;
 import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.tiered.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.store.tiered.metadata.TieredMetadataStore;
-import org.apache.rocketmq.store.tiered.mock.MemoryFileSegment;
-import org.apache.rocketmq.store.tiered.util.TieredStoreUtil;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
 import org.awaitility.Awaitility;
 import org.junit.After;
 import org.junit.Assert;
@@ -44,19 +45,19 @@ public class TieredIndexFileTest {
     @Before
     public void setUp() {
         MemoryFileSegment.checkSize = false;
-        mq = new MessageQueue("TieredIndexFileTest", "broker", 1);
         storeConfig = new TieredMessageStoreConfig();
-        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "rmqut");
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.store.tiered.mock.MemoryFileSegment");
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
         storeConfig.setTieredStoreIndexFileMaxHashSlotNum(2);
         storeConfig.setTieredStoreIndexFileMaxIndexNum(3);
+        mq = new MessageQueue("TieredIndexFileTest", storeConfig.getBrokerName(), 1);
         metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
     }
 
     @After
     public void tearDown() throws IOException {
         MemoryFileSegment.checkSize = true;
-        FileUtils.deleteDirectory(new File("/tmp/rmqut"));
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
 //        metadataStore.reLoadStore();
     }
 
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredMessageQueueContainerTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredMessageQueueContainerTest.java
new file mode 100644
index 000000000..a9eb444c9
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredMessageQueueContainerTest.java
@@ -0,0 +1,195 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.container;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.store.DispatchRequest;
+import org.apache.rocketmq.tieredstore.common.AppendResult;
+import org.apache.rocketmq.tieredstore.common.BoundaryType;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.metadata.QueueMetadata;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TieredMessageQueueContainerTest {
+    TieredMessageStoreConfig storeConfig;
+    MessageQueue mq;
+    TieredMetadataStore metadataStore;
+
+    @Before
+    public void setUp() {
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setCommitLogRollingInterval(0);
+        storeConfig.setCommitLogRollingMinimumSize(999);
+        mq = new MessageQueue("TieredMessageQueueContainerTest", storeConfig.getBrokerName(), 0);
+        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        MemoryFileSegment.checkSize = true;
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
+        TieredContainerManager.getInstance(storeConfig).cleanup();
+    }
+
+    @Test
+    public void testAppendCommitLog() throws ClassNotFoundException, NoSuchMethodException, IOException {
+        TieredMessageQueueContainer container = new TieredMessageQueueContainer(mq, storeConfig);
+        ByteBuffer message = MessageBufferUtilTest.buildMessageBuffer();
+        AppendResult result = container.appendCommitLog(message);
+        Assert.assertEquals(AppendResult.OFFSET_INCORRECT, result);
+
+        MemoryFileSegment segment = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG, mq, 1000, storeConfig);
+        segment.initPosition(segment.getSize());
+        metadataStore.updateFileSegment(segment);
+        metadataStore.updateFileSegment(segment);
+        container = new TieredMessageQueueContainer(mq, storeConfig);
+        container.initOffset(6);
+        result = container.appendCommitLog(message);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        message.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);
+        result = container.appendCommitLog(message);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        container.commit(true);
+        Assert.assertEquals(7, container.getBuildCQMaxOffset());
+
+        container.cleanExpiredFile(0);
+        container.destroyExpiredFile();
+        try {
+            Field field = container.getClass().getDeclaredField("commitLog");
+            field.setAccessible(true);
+            TieredCommitLog commitLog = (TieredCommitLog) field.get(container);
+            Field field2 = commitLog.getClass().getDeclaredField("fileQueue");
+            field2.setAccessible(true);
+            TieredFileQueue fileQueue = (TieredFileQueue) field2.get(commitLog);
+            Assert.assertEquals(2, fileQueue.getFileSegmentCount());
+
+            TieredFileSegment file1 = fileQueue.getFileByIndex(0);
+            TieredFileSegment file2 = fileQueue.getFileByIndex(1);
+
+            container.destroy();
+            Assert.assertEquals(0, fileQueue.getFileSegmentCount());
+            Assert.assertTrue(file1.isClosed());
+            Assert.assertTrue(file2.isClosed());
+        } catch (Exception e) {
+            Assert.fail(e.getClass().getCanonicalName() + ": " + e.getMessage());
+        }
+    }
+
+    @Test
+    public void testAppendConsumeQueue() throws ClassNotFoundException, NoSuchMethodException {
+        TieredMessageQueueContainer container = new TieredMessageQueueContainer(mq, storeConfig);
+        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 51, 2, 3, 4);
+        AppendResult result = container.appendConsumeQueue(request);
+        Assert.assertEquals(AppendResult.OFFSET_INCORRECT, result);
+
+        MemoryFileSegment segment = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE, mq, 20, storeConfig);
+        segment.initPosition(segment.getSize());
+        metadataStore.updateFileSegment(segment);
+        metadataStore.updateFileSegment(segment);
+        container = new TieredMessageQueueContainer(mq, storeConfig);
+        result = container.appendConsumeQueue(request);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 52, 2, 3, 4);
+        result = container.appendConsumeQueue(request);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        container.commit(true);
+        container.flushMetadata();
+        QueueMetadata queueMetadata = metadataStore.getQueue(mq);
+        Assert.assertEquals(53, queueMetadata.getMaxOffset());
+    }
+
+    @Test
+    public void testBinarySearchInQueueByTime() throws ClassNotFoundException, NoSuchMethodException {
+        MemoryFileSegment.checkSize = false;
+
+        TieredMessageQueueContainer container = new TieredMessageQueueContainer(mq, storeConfig);
+        container.initOffset(50);
+        long timestamp1 = System.currentTimeMillis();
+        ByteBuffer buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 50);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp1);
+        container.appendCommitLog(buffer, true);
+
+        long timestamp2 = timestamp1 + 100;
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 51);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp2);
+        container.appendCommitLog(buffer, true);
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 52);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp2);
+        container.appendCommitLog(buffer, true);
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 53);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp2);
+        container.appendCommitLog(buffer, true);
+
+        long timestamp3 = timestamp2 + 100;
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 54);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp3);
+        container.appendCommitLog(buffer, true);
+
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, MessageBufferUtilTest.MSG_LEN, 0, timestamp1, 50, "", "", 0, 0, null), true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0, timestamp2, 51, "", "", 0, 0, null), true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN, 0, timestamp2, 52, "", "", 0, 0, null), true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN * 3, MessageBufferUtilTest.MSG_LEN, 0, timestamp2, 53, "", "", 0, 0, null), true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN * 4, MessageBufferUtilTest.MSG_LEN, 0, timestamp3, 54, "", "", 0, 0, null), true);
+        container.commit(true);
+
+        Assert.assertEquals(54, container.binarySearchInQueueByTime(timestamp3 + 1, BoundaryType.UPPER));
+        Assert.assertEquals(54, container.binarySearchInQueueByTime(timestamp3, BoundaryType.UPPER));
+
+        Assert.assertEquals(50, container.binarySearchInQueueByTime(timestamp1 - 1, BoundaryType.LOWER));
+        Assert.assertEquals(50, container.binarySearchInQueueByTime(timestamp1, BoundaryType.LOWER));
+
+        Assert.assertEquals(51, container.binarySearchInQueueByTime(timestamp1 + 1, BoundaryType.LOWER));
+        Assert.assertEquals(51, container.binarySearchInQueueByTime(timestamp2, BoundaryType.LOWER));
+        Assert.assertEquals(54, container.binarySearchInQueueByTime(timestamp2 + 1, BoundaryType.LOWER));
+        Assert.assertEquals(54, container.binarySearchInQueueByTime(timestamp3, BoundaryType.LOWER));
+
+        Assert.assertEquals(50, container.binarySearchInQueueByTime(timestamp1, BoundaryType.UPPER));
+        Assert.assertEquals(50, container.binarySearchInQueueByTime(timestamp1 + 1, BoundaryType.UPPER));
+        Assert.assertEquals(53, container.binarySearchInQueueByTime(timestamp2, BoundaryType.UPPER));
+        Assert.assertEquals(53, container.binarySearchInQueueByTime(timestamp2 + 1, BoundaryType.UPPER));
+
+        Assert.assertEquals(0, container.binarySearchInQueueByTime(timestamp1 - 1, BoundaryType.UPPER));
+        Assert.assertEquals(55, container.binarySearchInQueueByTime(timestamp3 + 1, BoundaryType.LOWER));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/metadata/MetadataStoreTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metadata/MetadataStoreTest.java
similarity index 92%
rename from tieredstore/src/test/java/org/apache/rocketmq/store/tiered/metadata/MetadataStoreTest.java
rename to tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metadata/MetadataStoreTest.java
index a1c5b861a..45a3a6b7a 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/metadata/MetadataStoreTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metadata/MetadataStoreTest.java
@@ -14,20 +14,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.rocketmq.store.tiered.metadata;
+package org.apache.rocketmq.tieredstore.metadata;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.apache.commons.io.FileUtils;
 import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.tiered.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.store.tiered.container.TieredCommitLog;
-import org.apache.rocketmq.store.tiered.container.TieredFileSegment;
-import org.apache.rocketmq.store.tiered.mock.MemoryFileSegment;
-import org.apache.rocketmq.store.tiered.util.TieredStoreUtil;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.container.TieredCommitLog;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
@@ -41,14 +42,14 @@ public class MetadataStoreTest {
     @Before
     public void setUp() {
         storeConfig = new TieredMessageStoreConfig();
-        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "rmqut");
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
         mq = new MessageQueue("MetadataStoreTest", storeConfig.getBrokerName(), 1);
         metadataStore = new TieredMetadataManager(storeConfig);
     }
 
     @After
     public void tearDown() throws IOException {
-        FileUtils.deleteDirectory(new File("/tmp/rmqut"));
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
         TieredStoreUtil.getMetadataStore(storeConfig).destroy();
     }
 
@@ -70,7 +71,7 @@ public class MetadataStoreTest {
         Assert.assertEquals(queueMetadata.getMinOffset(), 0);
         Assert.assertEquals(queueMetadata.getMaxOffset(), 0);
 
-        MessageQueue mq2 = new MessageQueue("MetadataStoreTest", "broker", 2);
+        MessageQueue mq2 = new MessageQueue("MetadataStoreTest", storeConfig.getBrokerName(), 2);
         metadataStore.addQueue(mq2, 1);
         AtomicInteger i = new AtomicInteger(0);
         metadataStore.iterateQueue(mq.getTopic(), metadata -> {
@@ -171,7 +172,6 @@ public class MetadataStoreTest {
         TieredMetadataManager metadataManager = (TieredMetadataManager) metadataStore;
         metadataManager.addTopic(mq.getTopic(), 1);
         metadataManager.addQueue(mq, 2);
-        metadataManager.persist();
         Assert.assertTrue(new File(metadataManager.configFilePath()).exists());
 
         metadataManager = new TieredMetadataManager(storeConfig);
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metrics/TieredStoreMetricsManagerTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metrics/TieredStoreMetricsManagerTest.java
new file mode 100644
index 000000000..dea8f503f
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metrics/TieredStoreMetricsManagerTest.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.metrics;
+
+import io.opentelemetry.sdk.OpenTelemetrySdk;
+import org.apache.rocketmq.tieredstore.TieredMessageFetcher;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.junit.Test;
+
+public class TieredStoreMetricsManagerTest {
+
+    @Test
+    public void getMetricsView() {
+        TieredStoreMetricsManager.getMetricsView();
+    }
+
+    @Test
+    public void init() {
+        TieredMessageStoreConfig storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        TieredStoreMetricsManager.init(OpenTelemetrySdk.builder().build().getMeter(""),
+            null, storeConfig, new TieredMessageFetcher(storeConfig), null);
+    }
+
+    @Test
+    public void newAttributesBuilder() {
+        TieredStoreMetricsManager.newAttributesBuilder();
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/mock/MemoryFileSegment.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegment.java
similarity index 84%
rename from tieredstore/src/test/java/org/apache/rocketmq/store/tiered/mock/MemoryFileSegment.java
rename to tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegment.java
index 0071963cf..25f4a6b6c 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/mock/MemoryFileSegment.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegment.java
@@ -14,15 +14,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.rocketmq.store.tiered.mock;
+package org.apache.rocketmq.tieredstore.mock;
 
 import java.io.File;
 import java.nio.ByteBuffer;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.tiered.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.store.tiered.container.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
 import org.junit.Assert;
 
 public class MemoryFileSegment extends TieredFileSegment {
@@ -52,22 +52,26 @@ public class MemoryFileSegment extends TieredFileSegment {
         memStore.position((int) getSize());
     }
 
-    @Override public String getPath() {
+    @Override
+    public String getPath() {
         return "/tiered/" + fileType + File.separator + baseOffset;
     }
 
-    @Override public long getSize() {
+    @Override
+    public long getSize() {
         if (checkSize) {
             return 1000;
         }
         return 0;
     }
 
-    @Override protected void createFile() {
+    @Override
+    public void createFile() {
 
     }
 
-    @Override protected CompletableFuture<ByteBuffer> read0(long position, int length) {
+    @Override
+    public CompletableFuture<ByteBuffer> read0(long position, int length) {
         ByteBuffer buffer = memStore.duplicate();
         buffer.position((int) position);
         ByteBuffer slice = buffer.slice();
@@ -76,7 +80,7 @@ public class MemoryFileSegment extends TieredFileSegment {
     }
 
     @Override
-    protected CompletableFuture<Boolean> commit0(TieredFileSegmentInputStream inputStream, long position, int length,
+    public CompletableFuture<Boolean> commit0(TieredFileSegmentInputStream inputStream, long position, int length,
         boolean append) {
         try {
             if (blocker != null && !blocker.get()) {
@@ -104,11 +108,13 @@ public class MemoryFileSegment extends TieredFileSegment {
         return CompletableFuture.completedFuture(true);
     }
 
-    @Override protected boolean exists() {
+    @Override
+    public boolean exists() {
         return false;
     }
 
-    @Override protected void destroyFile() {
+    @Override
+    public void destroyFile() {
 
     }
 }
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileSegmentTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentTest.java
similarity index 93%
rename from tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileSegmentTest.java
rename to tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentTest.java
index d189aadd9..f55f7481c 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileSegmentTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentTest.java
@@ -14,15 +14,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.rocketmq.store.tiered.container;
+package org.apache.rocketmq.tieredstore.provider;
 
 import java.nio.ByteBuffer;
 import java.util.concurrent.CompletableFuture;
 import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.tiered.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.store.tiered.mock.MemoryFileSegment;
-import org.apache.rocketmq.store.tiered.util.MessageBufferUtil;
-import org.apache.rocketmq.store.tiered.util.MessageBufferUtilTest;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.container.TieredCommitLog;
+import org.apache.rocketmq.tieredstore.container.TieredConsumeQueue;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -30,7 +32,7 @@ public class TieredFileSegmentTest {
     public int baseOffset = 1000;
 
     public TieredFileSegment createFileSegment(TieredFileSegment.FileSegmentType fileType) {
-        return new MemoryFileSegment(fileType, new MessageQueue("TieredFileSegmentTest", "broker", 0),
+        return new MemoryFileSegment(fileType, new MessageQueue("TieredFileSegmentTest", new TieredMessageStoreConfig().getBrokerName(), 0),
             baseOffset, new TieredMessageStoreConfig());
     }
 
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/CQItemBufferUtilTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/CQItemBufferUtilTest.java
similarity index 97%
rename from tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/CQItemBufferUtilTest.java
rename to tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/CQItemBufferUtilTest.java
index d0e4932c9..7f8caea20 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/CQItemBufferUtilTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/CQItemBufferUtilTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.rocketmq.store.tiered.util;
+package org.apache.rocketmq.tieredstore.util;
 
 import java.nio.ByteBuffer;
 import org.apache.rocketmq.store.ConsumeQueue;
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/MessageBufferUtilTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/MessageBufferUtilTest.java
similarity index 98%
rename from tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/MessageBufferUtilTest.java
rename to tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/MessageBufferUtilTest.java
index 739629a56..268ea2d46 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/MessageBufferUtilTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/MessageBufferUtilTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.rocketmq.store.tiered.util;
+package org.apache.rocketmq.tieredstore.util;
 
 import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
@@ -25,8 +25,8 @@ import java.util.Map;
 import org.apache.commons.lang3.tuple.Pair;
 import org.apache.rocketmq.common.message.MessageConst;
 import org.apache.rocketmq.common.message.MessageDecoder;
-import org.apache.rocketmq.store.tiered.container.TieredCommitLog;
-import org.apache.rocketmq.store.tiered.container.TieredConsumeQueue;
+import org.apache.rocketmq.tieredstore.container.TieredCommitLog;
+import org.apache.rocketmq.tieredstore.container.TieredConsumeQueue;
 import org.junit.Assert;
 import org.junit.Test;
 
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/TieredStoreUtilTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/TieredStoreUtilTest.java
similarity index 97%
rename from tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/TieredStoreUtilTest.java
rename to tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/TieredStoreUtilTest.java
index 1bb462d8b..82e112524 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/TieredStoreUtilTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/TieredStoreUtilTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.rocketmq.store.tiered.util;
+package org.apache.rocketmq.tieredstore.util;
 
 import java.util.HashMap;
 import java.util.Map;
