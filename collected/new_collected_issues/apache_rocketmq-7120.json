{
  "issue_id": 7064,
  "issue_url": "https://github.com/apache/rocketmq/issues/7064",
  "title": "[RIP-66] Support KV(Rocksdb) Storage",
  "description": "<h3 dir=\"auto\">Before Creating the Enhancement Request</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\" checked=\"\"> I have confirmed that this should be classified as an enhancement rather than a bug/feature.</li>\n</ul>\n<h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">We will introduce kv(rocksdb) storage to solve the possible Full GC caused by large object memory allocation when metadata such as topic is serialized, and the performance degradation caused by random writing of a large number of small ConsumeQueue files in a million-topic scenario</p>\n<h3 dir=\"auto\">Motivation</h3>\n<p dir=\"auto\">we have encountered and been plagued by some probelms in the actual production environment. In some actual production scenarios, millions of topics and subsriptions will be created, and both of them may be deleted and created frequently. In current architecture, both topics and subcriptions are persisted in real time, which means each request of topics and subsciptions updating will trigger the persist interface, and the persistence of such metadata is written in full rather than append-only.</p>\n<p dir=\"auto\">In the scenario of millions of topics, frequent persistence generates the large memory object jsonString of the topicConfigTable. When the memory is tight, the large memory object jsonString will be directly allocated to the old generation, resulting in frequent Full GC.</p>\n<p dir=\"auto\">In addition, millions of topics will inevitably bring millions of indexed ConsumeQueue small files, a large number of indexed small files will destroy the advantages of rocketmq sequential writing, and the random writing of ConsumeQueue will make the performance drop sharply.</p>\n<h3 dir=\"auto\">Describe the Solution You'd Like</h3>\n<p dir=\"auto\">This proposal mainly optimizes and solves the existing perfermance problems in the million-topic scenario from two levels:</p>\n<ol dir=\"auto\">\n<li>Metadata like topic, subscription, consumerOffset implement kv storage</li>\n<li>ConsumeQueue index file implements kv storage</li>\n</ol>\n<h3 dir=\"auto\">Describe Alternatives You've Considered</h3>\n<p dir=\"auto\">no</p>\n<h3 dir=\"auto\">Additional Context</h3>\n<p dir=\"auto\">No response</p>",
  "description_text": "Before Creating the Enhancement Request\n\n I have confirmed that this should be classified as an enhancement rather than a bug/feature.\n\nSummary\nWe will introduce kv(rocksdb) storage to solve the possible Full GC caused by large object memory allocation when metadata such as topic is serialized, and the performance degradation caused by random writing of a large number of small ConsumeQueue files in a million-topic scenario\nMotivation\nwe have encountered and been plagued by some probelms in the actual production environment. In some actual production scenarios, millions of topics and subsriptions will be created, and both of them may be deleted and created frequently. In current architecture, both topics and subcriptions are persisted in real time, which means each request of topics and subsciptions updating will trigger the persist interface, and the persistence of such metadata is written in full rather than append-only.\nIn the scenario of millions of topics, frequent persistence generates the large memory object jsonString of the topicConfigTable. When the memory is tight, the large memory object jsonString will be directly allocated to the old generation, resulting in frequent Full GC.\nIn addition, millions of topics will inevitably bring millions of indexed ConsumeQueue small files, a large number of indexed small files will destroy the advantages of rocketmq sequential writing, and the random writing of ConsumeQueue will make the performance drop sharply.\nDescribe the Solution You'd Like\nThis proposal mainly optimizes and solves the existing perfermance problems in the million-topic scenario from two levels:\n\nMetadata like topic, subscription, consumerOffset implement kv storage\nConsumeQueue index file implements kv storage\n\nDescribe Alternatives You've Considered\nno\nAdditional Context\nNo response"
}