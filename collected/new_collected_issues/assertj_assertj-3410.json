{
  "issue_id": 3359,
  "issue_url": "https://github.com/assertj/assertj/issues/3359",
  "title": "Unable to compare some timestamp types",
  "description": "<p dir=\"auto\"><strong>Describe the bug</strong><br>\nA clear and concise description of what the bug is.</p>\n<ul dir=\"auto\">\n<li>assertj core version: 3.25.3</li>\n<li>java version: 21.0.1-open</li>\n<li>test framework version: JUnit 5.10.2</li>\n<li>os (if relevant):  Linux 6.5.0-15-generic # 15-Ubuntu SMP PREEMPT_DYNAMIC Tue Jan  9 17:03:36 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux (Ubuntu 23.10)</li>\n</ul>\n<p dir=\"auto\"><strong>Test case reproducing the bug</strong></p>\n<p dir=\"auto\">Some timestamp types, for example, <code class=\"notranslate\">java.sql.Timestamp</code>, are not specifically handled when comparing with other temporal types, and as a result, though there are no compile-time errors caused by types, they are not effectively compared as temporals.</p>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"public class Demo {\n    @Test\n    void compareSqlTimestampWithInstant() {\n        final long now = System.currentTimeMillis();\n        final Timestamp ts = new Timestamp(now);\n        final Instant instant = Instant.ofEpochMilli(now);\n        assertEquals(ts.getNanos(), instant.getNano()); // this succeeds\n        assertThat(ts).isEqualTo(instant); // this fails.\n        assertThat(ts).isAfterOrEqualTo(instant); // even if I want to relax the check, this still fails\n    }\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Demo</span> {\n    <span class=\"pl-c1\">@</span><span class=\"pl-c1\">Test</span>\n    <span class=\"pl-smi\">void</span> <span class=\"pl-en\">compareSqlTimestampWithInstant</span>() {\n        <span class=\"pl-k\">final</span> <span class=\"pl-smi\">long</span> <span class=\"pl-s1\">now</span> = <span class=\"pl-smi\">System</span>.<span class=\"pl-en\">currentTimeMillis</span>();\n        <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Timestamp</span> <span class=\"pl-s1\">ts</span> = <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Timestamp</span>(<span class=\"pl-s1\">now</span>);\n        <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Instant</span> <span class=\"pl-s1\">instant</span> = <span class=\"pl-smi\">Instant</span>.<span class=\"pl-en\">ofEpochMilli</span>(<span class=\"pl-s1\">now</span>);\n        <span class=\"pl-en\">assertEquals</span>(<span class=\"pl-s1\">ts</span>.<span class=\"pl-en\">getNanos</span>(), <span class=\"pl-s1\">instant</span>.<span class=\"pl-en\">getNano</span>()); <span class=\"pl-c\">// this succeeds</span>\n        <span class=\"pl-en\">assertThat</span>(<span class=\"pl-s1\">ts</span>).<span class=\"pl-en\">isEqualTo</span>(<span class=\"pl-s1\">instant</span>); <span class=\"pl-c\">// this fails.</span>\n        <span class=\"pl-en\">assertThat</span>(<span class=\"pl-s1\">ts</span>).<span class=\"pl-en\">isAfterOrEqualTo</span>(<span class=\"pl-s1\">instant</span>); <span class=\"pl-c\">// even if I want to relax the check, this still fails</span>\n    }\n}</pre></div>\n<p dir=\"auto\">I can see there are javadocs mentioning that comparisons are done by converting these timestamp types to <code class=\"notranslate\">java.util.Date</code>, but is there a way to make this less surprising, otherwise make it a compilation error, so the user can take care of nanoseconds?</p>\n<p dir=\"auto\"><strong>Updated</strong>: I thought it was caused by nano-second precision being dropped along the assertion classes, but it turns out that there is no special handling of such types, and they end up calling <code class=\"notranslate\">Object.equals()</code>.</p>",
  "description_text": "Describe the bug\nA clear and concise description of what the bug is.\n\nassertj core version: 3.25.3\njava version: 21.0.1-open\ntest framework version: JUnit 5.10.2\nos (if relevant):  Linux 6.5.0-15-generic # 15-Ubuntu SMP PREEMPT_DYNAMIC Tue Jan  9 17:03:36 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux (Ubuntu 23.10)\n\nTest case reproducing the bug\nSome timestamp types, for example, java.sql.Timestamp, are not specifically handled when comparing with other temporal types, and as a result, though there are no compile-time errors caused by types, they are not effectively compared as temporals.\npublic class Demo {\n    @Test\n    void compareSqlTimestampWithInstant() {\n        final long now = System.currentTimeMillis();\n        final Timestamp ts = new Timestamp(now);\n        final Instant instant = Instant.ofEpochMilli(now);\n        assertEquals(ts.getNanos(), instant.getNano()); // this succeeds\n        assertThat(ts).isEqualTo(instant); // this fails.\n        assertThat(ts).isAfterOrEqualTo(instant); // even if I want to relax the check, this still fails\n    }\n}\nI can see there are javadocs mentioning that comparisons are done by converting these timestamp types to java.util.Date, but is there a way to make this less surprising, otherwise make it a compilation error, so the user can take care of nanoseconds?\nUpdated: I thought it was caused by nano-second precision being dropped along the assertion classes, but it turns out that there is no special handling of such types, and they end up calling Object.equals()."
}