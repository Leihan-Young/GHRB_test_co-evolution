{
  "issue_id": 1219,
  "issue_url": "https://github.com/google/gson/issues/1219",
  "title": "Don't silently ignore missing type information from `TypeTokens`.",
  "description": "<p dir=\"auto\">I'm active on Stack Overflow, and often see questions with code more or less like this:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public class Main {\n\t\t\n\tpublic static void main(String[] args) {\n            // should work right?\n\t    MyClass mc = new Gson().fromJson(\"{}\", Main.<MyClass>typeTokenHelper());\n\t}\n\t\n\tstatic class MyClass {}\n\t\n\tpublic static <T> Type typeTokenHelper() {\n\t\treturn new TypeToken<T>() {}.getType();\n\t}\n\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">public class Main {\n\t\t\n\tpublic static void main(String[] args) {\n            // should work right?\n\t    MyClass mc = new Gson().fromJson(\"{}\", Main.<MyClass>typeTokenHelper());\n\t}\n\t\n\tstatic class MyClass {}\n\t\n\tpublic static <T> Type typeTokenHelper() {\n\t\treturn new TypeToken<T>() {}.getType();\n\t}\n\n}\n</code></pre></div>\n<p dir=\"auto\">Of course this fails with:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to test.Main$MyClass\"><pre class=\"notranslate\"><code class=\"notranslate\">java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to test.Main$MyClass\n</code></pre></div>\n<p dir=\"auto\">Since there is not actually any type information available from the <code class=\"notranslate\">TypeToken</code>. The <code class=\"notranslate\">Type</code> that you get is the generic type <code class=\"notranslate\">T</code>:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Type t = Main.<MyClass>typeTokenHelper();\nSystem.out.println(t); // prints 'T'. instead of the na\u00efvely expected 'MyClass'\"><pre class=\"notranslate\"><code class=\"notranslate\">Type t = Main.<MyClass>typeTokenHelper();\nSystem.out.println(t); // prints 'T'. instead of the na\u00efvely expected 'MyClass'\n</code></pre></div>\n<p dir=\"auto\">This is confusing. The missing type information should not be silently ignored only to get a <code class=\"notranslate\">ClassCastException</code> later. The missing type information is caused by a design time error and should be flagged as early as possible.</p>\n<p dir=\"auto\">At first glance a check like this:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// where 'typeOfT' is the type returned by TypeToken::getType\nif(typeOfT instanceof TypeVariable) {  // java.lang.reflect.TypeVariable\n    throw new RuntimeExcepiton(...);\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">// where 'typeOfT' is the type returned by TypeToken::getType\nif(typeOfT instanceof TypeVariable) {  // java.lang.reflect.TypeVariable\n    throw new RuntimeExcepiton(...);\n}\n</code></pre></div>\n<p dir=\"auto\">Somewhere might fix this issue. Perhaps in <a href=\"https://github.com/google/gson/blob/0636635cbffa08157bdbd558b1212e4d806474eb/gson/src/main/java/com/google/gson/reflect/TypeToken.java#L81\"><code class=\"notranslate\">TypeToken::getSuperclassTypeParameter</code></a> or in <a href=\"https://github.com/google/gson/blob/0636635cbffa08157bdbd558b1212e4d806474eb/gson/src/main/java/com/google/gson/Gson.java#L878\"><code class=\"notranslate\">Gson::fromJson</code></a>. (I don't know where the use of TypeTokens with TypeVariables might be required though)</p>",
  "description_text": "I'm active on Stack Overflow, and often see questions with code more or less like this:\ntypeTokenHelper());\n\t}\n\t\n\tstatic class MyClass {}\n\t\n\tpublic static  Type typeTokenHelper() {\n\t\treturn new TypeToken() {}.getType();\n\t}\n\n}\">public class Main {\n\t\t\n\tpublic static void main(String[] args) {\n            // should work right?\n\t    MyClass mc = new Gson().fromJson(\"{}\", Main.typeTokenHelper());\n\t}\n\t\n\tstatic class MyClass {}\n\t\n\tpublic static  Type typeTokenHelper() {\n\t\treturn new TypeToken() {}.getType();\n\t}\n\n}\n\nOf course this fails with:\njava.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to test.Main$MyClass\n\nSince there is not actually any type information available from the TypeToken. The Type that you get is the generic type T:\nType t = Main.typeTokenHelper();\nSystem.out.println(t); // prints 'T'. instead of the na\u00efvely expected 'MyClass'\n\nThis is confusing. The missing type information should not be silently ignored only to get a ClassCastException later. The missing type information is caused by a design time error and should be flagged as early as possible.\nAt first glance a check like this:\n// where 'typeOfT' is the type returned by TypeToken::getType\nif(typeOfT instanceof TypeVariable) {  // java.lang.reflect.TypeVariable\n    throw new RuntimeExcepiton(...);\n}\n\nSomewhere might fix this issue. Perhaps in TypeToken::getSuperclassTypeParameter or in Gson::fromJson. (I don't know where the use of TypeTokens with TypeVariables might be required though)"
}