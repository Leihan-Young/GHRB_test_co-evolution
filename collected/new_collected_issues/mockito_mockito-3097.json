{
  "issue_id": 2865,
  "issue_url": "https://github.com/mockito/mockito/issues/2865",
  "title": "Default mock of `Optional` is not `empty` when using `RETURN_DEEP_STUBS`",
  "description": "<p dir=\"auto\">Version affected: Mockito: 4.x & 5.x</p>\n<p dir=\"auto\">If you create a mock with <code class=\"notranslate\">RETURN_DEEP_STUBS</code>, then any method that returns a collection will, by default, return an empty collection, i.e. <code class=\"notranslate\">isEmpty</code> returns <code class=\"notranslate\">true</code>, etc.  This is great, as it means no additional configuration of the mock is required before passing to logic that would attempt to access elements of the collection.</p>\n<p dir=\"auto\">However, the same is not true for <code class=\"notranslate\">Optional</code>, (and I'm assuming <code class=\"notranslate\">OptionalLong</code> etc): if <code class=\"notranslate\">RETURN_DEEP_STUBS</code> is used, methods that return <code class=\"notranslate\">Optional</code> aren't treated in any special way and just return a default mock with not stubbing configured. This means <code class=\"notranslate\">isEmpty</code> returns <code class=\"notranslate\">false</code>, but <code class=\"notranslate\">get()</code> returns <code class=\"notranslate\">null</code>.   This breaks the contract of <code class=\"notranslate\">Optional</code>, causing test failures that aren't actually valid, or requiring manual configuration of the <code class=\"notranslate\">Optional</code> mock to do-the-right-thing, cluttering test code.</p>\n<p dir=\"auto\">Here's an example test that demonstrates this:</p>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface Address {\n   Optional<String> getState();\n}\n\n@Test\npublic void shouldDefaultDeepMockOptionalsToEmpty() {\n    final Address address = mock(Address.class, RETURNS_DEEP_STUBS);\n\n    assertThat(address.getState()).isEqualTo(Optional.empty());  // <--- fails\n}\n\n@Test\npublic void shouldDefaultMockOptionalsToEmpty() {\n    final Address address = mock(Address.class); // <-- no RETURNS_DEEP_STUBS\n\n    assertThat(address.getState()).isEqualTo(Optional.empty());  // <--- passes\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Address</span> {\n   <span class=\"pl-smi\">Optional</span><<span class=\"pl-smi\">String</span>> <span class=\"pl-en\">getState</span>();\n}\n\n<span class=\"pl-c1\">@</span><span class=\"pl-c1\">Test</span>\n<span class=\"pl-k\">public</span> <span class=\"pl-smi\">void</span> <span class=\"pl-s1\">shouldDefaultDeepMockOptionalsToEmpty</span>() {\n    <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Address</span> <span class=\"pl-s1\">address</span> = <span class=\"pl-en\">mock</span>(<span class=\"pl-smi\">Address</span>.<span class=\"pl-k\">class</span>, <span class=\"pl-c1\">RETURNS_DEEP_STUBS</span>);\n\n    <span class=\"pl-en\">assertThat</span>(<span class=\"pl-s1\">address</span>.<span class=\"pl-en\">getState</span>()).<span class=\"pl-en\">isEqualTo</span>(<span class=\"pl-smi\">Optional</span>.<span class=\"pl-en\">empty</span>());  <span class=\"pl-c\">// <--- fails</span>\n}\n\n<span class=\"pl-c1\">@</span><span class=\"pl-c1\">Test</span>\n<span class=\"pl-k\">public</span> <span class=\"pl-smi\">void</span> <span class=\"pl-s1\">shouldDefaultMockOptionalsToEmpty</span>() {\n    <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Address</span> <span class=\"pl-s1\">address</span> = <span class=\"pl-en\">mock</span>(<span class=\"pl-smi\">Address</span>.<span class=\"pl-k\">class</span>); <span class=\"pl-c\">// <-- no RETURNS_DEEP_STUBS</span>\n\n    <span class=\"pl-en\">assertThat</span>(<span class=\"pl-s1\">address</span>.<span class=\"pl-en\">getState</span>()).<span class=\"pl-en\">isEqualTo</span>(<span class=\"pl-smi\">Optional</span>.<span class=\"pl-en\">empty</span>());  <span class=\"pl-c\">// <--- passes</span>\n}</pre></div>\n<p dir=\"auto\">Note the second test, which doesn't use deep mocking, passes.</p>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\" checked=\"\"> The mockito message in the stacktrace have useful information, but it didn't help</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\" checked=\"\"> The problematic code (if that's possible) is copied here;<br>\nNote that some configuration are impossible to mock via Mockito</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\" checked=\"\"> Provide versions (mockito / jdk / os / any other relevant information)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\" checked=\"\"> Provide a <a href=\"http://sscce.org\" rel=\"nofollow\">Short, Self Contained, Correct (Compilable), Example</a> of the issue<br>\n(same as any question on stackoverflow.com)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\" checked=\"\"> Read the <a href=\"https://github.com/mockito/mockito/blob/main/.github/CONTRIBUTING.md\">contributing guide</a></li>\n</ul>",
  "description_text": "Version affected: Mockito: 4.x & 5.x\nIf you create a mock with RETURN_DEEP_STUBS, then any method that returns a collection will, by default, return an empty collection, i.e. isEmpty returns true, etc.  This is great, as it means no additional configuration of the mock is required before passing to logic that would attempt to access elements of the collection.\nHowever, the same is not true for Optional, (and I'm assuming OptionalLong etc): if RETURN_DEEP_STUBS is used, methods that return Optional aren't treated in any special way and just return a default mock with not stubbing configured. This means isEmpty returns false, but get() returns null.   This breaks the contract of Optional, causing test failures that aren't actually valid, or requiring manual configuration of the Optional mock to do-the-right-thing, cluttering test code.\nHere's an example test that demonstrates this:\ninterface Address {\n   Optional<String> getState();\n}\n\n@Test\npublic void shouldDefaultDeepMockOptionalsToEmpty() {\n    final Address address = mock(Address.class, RETURNS_DEEP_STUBS);\n\n    assertThat(address.getState()).isEqualTo(Optional.empty());  // <--- fails\n}\n\n@Test\npublic void shouldDefaultMockOptionalsToEmpty() {\n    final Address address = mock(Address.class); // <-- no RETURNS_DEEP_STUBS\n\n    assertThat(address.getState()).isEqualTo(Optional.empty());  // <--- passes\n}\nNote the second test, which doesn't use deep mocking, passes.\n\n The mockito message in the stacktrace have useful information, but it didn't help\n The problematic code (if that's possible) is copied here;\nNote that some configuration are impossible to mock via Mockito\n Provide versions (mockito / jdk / os / any other relevant information)\n Provide a Short, Self Contained, Correct (Compilable), Example of the issue\n(same as any question on stackoverflow.com)\n Read the contributing guide\n"
}