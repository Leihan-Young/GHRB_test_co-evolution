{
  "issue_id": 2968,
  "issue_url": "https://github.com/FasterXML/jackson-databind/issues/2968",
  "title": "Deserialization of `@JsonTypeInfo` annotated type fails with missing type id even for explicit concrete subtypes",
  "description": "<p dir=\"auto\">When attempting to deserialize to a concrete class that is part of a polymorphic type hierarchy, an InvalidTypeIdException is thrown if the JSON does not contain the type id field. Example:</p>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"@JsonTypeInfo(\n    use = JsonTypeInfo.Id.NAME,\n    property = \"type\")\n@JsonSubTypes({\n    @JsonSubTypes.Type(value = Foo.class, name = \"foo\"),\n    @JsonSubTypes.Type(value = Bar.class, name = \"bar\")})\npublic interface Base {}\n\npublic class Foo implements Base {}\n\npublic class Bar implements Base {}\n\nObjectMapper mapper = new ObjectMapper();\n\nmapper.readerFor(Foo.class).readValue(\"{}\"); // throws InvalidTypeIdException\nmapper.readValue(\"{}\", Foo.class); // throws InvalidTypeIdException\"><pre class=\"notranslate\"><span class=\"pl-c1\">@</span><span class=\"pl-c1\">JsonTypeInfo</span>(\n    <span class=\"pl-s1\">use</span> = <span class=\"pl-smi\">JsonTypeInfo</span>.<span class=\"pl-s1\">Id</span>.<span class=\"pl-c1\">NAME</span>,\n    <span class=\"pl-s1\">property</span> = <span class=\"pl-s\">\"type\"</span>)\n<span class=\"pl-c1\">@</span><span class=\"pl-c1\">JsonSubTypes</span>({\n    <span class=\"pl-c1\">@</span><span class=\"pl-smi\">JsonSubTypes</span>.<span class=\"pl-s1\">Type</span>(<span class=\"pl-s1\">value</span> = <span class=\"pl-smi\">Foo</span>.<span class=\"pl-k\">class</span>, <span class=\"pl-s1\">name</span> = <span class=\"pl-s\">\"foo\"</span>),\n    <span class=\"pl-c1\">@</span><span class=\"pl-smi\">JsonSubTypes</span>.<span class=\"pl-s1\">Type</span>(<span class=\"pl-s1\">value</span> = <span class=\"pl-smi\">Bar</span>.<span class=\"pl-k\">class</span>, <span class=\"pl-s1\">name</span> = <span class=\"pl-s\">\"bar\"</span>)})\n<span class=\"pl-k\">public</span> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Base</span> {}\n\n<span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-k\">implements</span> <span class=\"pl-smi\">Base</span> {}\n\n<span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Bar</span> <span class=\"pl-k\">implements</span> <span class=\"pl-smi\">Base</span> {}\n\n<span class=\"pl-smi\">ObjectMapper</span> <span class=\"pl-s1\">mapper</span> = <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ObjectMapper</span>();\n\n<span class=\"pl-s1\">mapper</span>.<span class=\"pl-en\">readerFor</span>(<span class=\"pl-smi\">Foo</span>.<span class=\"pl-k\">class</span>).<span class=\"pl-en\">readValue</span>(<span class=\"pl-s\">\"{}\"</span>); <span class=\"pl-c\">// throws InvalidTypeIdException</span>\n<span class=\"pl-s1\">mapper</span>.<span class=\"pl-en\">readValue</span>(<span class=\"pl-s\">\"{}\"</span>, <span class=\"pl-smi\">Foo</span>.<span class=\"pl-k\">class</span>); <span class=\"pl-c\">// throws InvalidTypeIdException</span></pre></div>\n<p dir=\"auto\">While I understand <em>why</em> this happens, as Jackson is finding the JsonTypeInfo / JsonSubTypes annotations on the interface, it is counterintuitive to me. In this instance, I am instructing the mapper as to the specific concrete class to deserialize to, so consulting those annotations seems unnecessary. Perhaps checking if the class / type supplied to readerFor / readValue matches exactly one of the classes listed in JsonSubType could be a fallback if the type id property is not found?</p>\n<p dir=\"auto\">So far, the only workaround I've found is to do something like this:</p>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)\npublic class Foo implements Base {}\"><pre class=\"notranslate\"><span class=\"pl-c1\">@</span><span class=\"pl-c1\">JsonTypeInfo</span>(<span class=\"pl-s1\">use</span> = <span class=\"pl-smi\">JsonTypeInfo</span>.<span class=\"pl-s1\">Id</span>.<span class=\"pl-c1\">NONE</span>)\n<span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-k\">implements</span> <span class=\"pl-smi\">Base</span> {}</pre></div>\n<p dir=\"auto\">but then that means serializing a Foo instance would not get the type id property. Perhaps a custom TypeIdResolver or SubTypeResolver could also be used, but having the described behavior baked in seems like a sensible default to me. Thoughts?</p>",
  "description_text": "When attempting to deserialize to a concrete class that is part of a polymorphic type hierarchy, an InvalidTypeIdException is thrown if the JSON does not contain the type id field. Example:\n@JsonTypeInfo(\n    use = JsonTypeInfo.Id.NAME,\n    property = \"type\")\n@JsonSubTypes({\n    @JsonSubTypes.Type(value = Foo.class, name = \"foo\"),\n    @JsonSubTypes.Type(value = Bar.class, name = \"bar\")})\npublic interface Base {}\n\npublic class Foo implements Base {}\n\npublic class Bar implements Base {}\n\nObjectMapper mapper = new ObjectMapper();\n\nmapper.readerFor(Foo.class).readValue(\"{}\"); // throws InvalidTypeIdException\nmapper.readValue(\"{}\", Foo.class); // throws InvalidTypeIdException\nWhile I understand why this happens, as Jackson is finding the JsonTypeInfo / JsonSubTypes annotations on the interface, it is counterintuitive to me. In this instance, I am instructing the mapper as to the specific concrete class to deserialize to, so consulting those annotations seems unnecessary. Perhaps checking if the class / type supplied to readerFor / readValue matches exactly one of the classes listed in JsonSubType could be a fallback if the type id property is not found?\nSo far, the only workaround I've found is to do something like this:\n@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)\npublic class Foo implements Base {}\nbut then that means serializing a Foo instance would not get the type id property. Perhaps a custom TypeIdResolver or SubTypeResolver could also be used, but having the described behavior baked in seems like a sensible default to me. Thoughts?"
}