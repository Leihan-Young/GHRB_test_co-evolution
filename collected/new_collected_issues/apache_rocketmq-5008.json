{
  "issue_id": 4999,
  "issue_url": "https://github.com/apache/rocketmq/issues/4999",
  "title": "ConcurrentHashMap#computeIfAbsent have performance problem in jdk1.8 QueueOffsetAssigner#assignQueueOffset use it.",
  "description": "<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/15797831/188348276-afdcb5d0-ab66-413c-842f-5a09840619e7.png\"><img src=\"https://user-images.githubusercontent.com/15797831/188348276-afdcb5d0-ab66-413c-842f-5a09840619e7.png\" alt=\"image\" style=\"max-width: 100%;\"></a><br>\n<a href=\"https://bugs.openjdk.org/browse/JDK-8161372\" rel=\"nofollow\">openjdk bug report</a> .<br>\nuse JMH to test it:</p>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.openjdk.jmh.annotations.Benchmark;\nimport org.openjdk.jmh.annotations.Fork;\nimport org.openjdk.jmh.annotations.Level;\nimport org.openjdk.jmh.annotations.Measurement;\nimport org.openjdk.jmh.annotations.Scope;\nimport org.openjdk.jmh.annotations.Setup;\nimport org.openjdk.jmh.annotations.State;\nimport org.openjdk.jmh.annotations.Threads;\nimport org.openjdk.jmh.annotations.Warmup;\n\n\n@Warmup(iterations = 2, time = 5)\n@Measurement(iterations = 3, time = 5)\n@State(Scope.Benchmark)\n@Fork(2)\npublic class HashMapBenchmark {\n\n    private static final String KEY = \"mxsm\";\n\n    private final Map<String, Object> concurrentMap = new ConcurrentHashMap<>();\n\n    @Setup(Level.Iteration)\n    public void setup() {\n        concurrentMap.clear();\n    }\n\n    @Benchmark\n    @Threads(16)\n    public Object benchmarkGetBeforeComputeIfAbsent() {\n        Object result = concurrentMap.get(KEY);\n        if (null == result) {\n            result = concurrentMap.computeIfAbsent(KEY, key -> 1);\n        }\n        return result;\n    }\n\n    @Benchmark\n    @Threads(16)\n    public Object benchmarkComputeIfAbsent() {\n        return concurrentMap.computeIfAbsent(KEY, key -> 1);\n    }\n\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">import</span> <span class=\"pl-s1\">java</span>.<span class=\"pl-s1\">util</span>.<span class=\"pl-s1\">Map</span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-s1\">java</span>.<span class=\"pl-s1\">util</span>.<span class=\"pl-s1\">concurrent</span>.<span class=\"pl-s1\">ConcurrentHashMap</span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-s1\">org</span>.<span class=\"pl-s1\">openjdk</span>.<span class=\"pl-s1\">jmh</span>.<span class=\"pl-s1\">annotations</span>.<span class=\"pl-s1\">Benchmark</span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-s1\">org</span>.<span class=\"pl-s1\">openjdk</span>.<span class=\"pl-s1\">jmh</span>.<span class=\"pl-s1\">annotations</span>.<span class=\"pl-s1\">Fork</span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-s1\">org</span>.<span class=\"pl-s1\">openjdk</span>.<span class=\"pl-s1\">jmh</span>.<span class=\"pl-s1\">annotations</span>.<span class=\"pl-s1\">Level</span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-s1\">org</span>.<span class=\"pl-s1\">openjdk</span>.<span class=\"pl-s1\">jmh</span>.<span class=\"pl-s1\">annotations</span>.<span class=\"pl-s1\">Measurement</span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-s1\">org</span>.<span class=\"pl-s1\">openjdk</span>.<span class=\"pl-s1\">jmh</span>.<span class=\"pl-s1\">annotations</span>.<span class=\"pl-s1\">Scope</span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-s1\">org</span>.<span class=\"pl-s1\">openjdk</span>.<span class=\"pl-s1\">jmh</span>.<span class=\"pl-s1\">annotations</span>.<span class=\"pl-s1\">Setup</span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-s1\">org</span>.<span class=\"pl-s1\">openjdk</span>.<span class=\"pl-s1\">jmh</span>.<span class=\"pl-s1\">annotations</span>.<span class=\"pl-s1\">State</span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-s1\">org</span>.<span class=\"pl-s1\">openjdk</span>.<span class=\"pl-s1\">jmh</span>.<span class=\"pl-s1\">annotations</span>.<span class=\"pl-s1\">Threads</span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-s1\">org</span>.<span class=\"pl-s1\">openjdk</span>.<span class=\"pl-s1\">jmh</span>.<span class=\"pl-s1\">annotations</span>.<span class=\"pl-s1\">Warmup</span>;\n\n\n<span class=\"pl-c1\">@</span><span class=\"pl-c1\">Warmup</span>(<span class=\"pl-s1\">iterations</span> = <span class=\"pl-c1\">2</span>, <span class=\"pl-s1\">time</span> = <span class=\"pl-c1\">5</span>)\n<span class=\"pl-c1\">@</span><span class=\"pl-c1\">Measurement</span>(<span class=\"pl-s1\">iterations</span> = <span class=\"pl-c1\">3</span>, <span class=\"pl-s1\">time</span> = <span class=\"pl-c1\">5</span>)\n<span class=\"pl-c1\">@</span><span class=\"pl-c1\">State</span>(<span class=\"pl-smi\">Scope</span>.<span class=\"pl-s1\">Benchmark</span>)\n<span class=\"pl-c1\">@</span><span class=\"pl-c1\">Fork</span>(<span class=\"pl-c1\">2</span>)\n<span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">HashMapBenchmark</span> {\n\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">String</span> <span class=\"pl-c1\">KEY</span> = <span class=\"pl-s\">\"mxsm\"</span>;\n\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Map</span><<span class=\"pl-smi\">String</span>, <span class=\"pl-smi\">Object</span>> <span class=\"pl-s1\">concurrentMap</span> = <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ConcurrentHashMap</span><>();\n\n    <span class=\"pl-c1\">@</span><span class=\"pl-c1\">Setup</span>(<span class=\"pl-smi\">Level</span>.<span class=\"pl-s1\">Iteration</span>)\n    <span class=\"pl-k\">public</span> <span class=\"pl-smi\">void</span> <span class=\"pl-en\">setup</span>() {\n        <span class=\"pl-s1\">concurrentMap</span>.<span class=\"pl-en\">clear</span>();\n    }\n\n    <span class=\"pl-c1\">@</span><span class=\"pl-c1\">Benchmark</span>\n    <span class=\"pl-c1\">@</span><span class=\"pl-c1\">Threads</span>(<span class=\"pl-c1\">16</span>)\n    <span class=\"pl-k\">public</span> <span class=\"pl-smi\">Object</span> <span class=\"pl-en\">benchmarkGetBeforeComputeIfAbsent</span>() {\n        <span class=\"pl-smi\">Object</span> <span class=\"pl-s1\">result</span> = <span class=\"pl-s1\">concurrentMap</span>.<span class=\"pl-en\">get</span>(<span class=\"pl-c1\">KEY</span>);\n        <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">null</span> == <span class=\"pl-s1\">result</span>) {\n            <span class=\"pl-s1\">result</span> = <span class=\"pl-s1\">concurrentMap</span>.<span class=\"pl-en\">computeIfAbsent</span>(<span class=\"pl-c1\">KEY</span>, <span class=\"pl-s1\">key</span> -> <span class=\"pl-c1\">1</span>);\n        }\n        <span class=\"pl-k\">return</span> <span class=\"pl-s1\">result</span>;\n    }\n\n    <span class=\"pl-c1\">@</span><span class=\"pl-c1\">Benchmark</span>\n    <span class=\"pl-c1\">@</span><span class=\"pl-c1\">Threads</span>(<span class=\"pl-c1\">16</span>)\n    <span class=\"pl-k\">public</span> <span class=\"pl-smi\">Object</span> <span class=\"pl-en\">benchmarkComputeIfAbsent</span>() {\n        <span class=\"pl-k\">return</span> <span class=\"pl-s1\">concurrentMap</span>.<span class=\"pl-en\">computeIfAbsent</span>(<span class=\"pl-c1\">KEY</span>, <span class=\"pl-s1\">key</span> -> <span class=\"pl-c1\">1</span>);\n    }\n\n}</pre></div>\n<p dir=\"auto\">jdk version:<br>\nopenjdk version \"1.8.0_312\"<br>\nOpenJDK Runtime Environment (build 1.8.0_312-8u312-b07-0ubuntu1~18.04-b07)<br>\nOpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode)</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"root@GZYZFA00088591:/mnt/d/develop/github/benchmark/dledger-benchmark# java -jar target/dledger-benchmarks.jar com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark\n# JMH version: 1.35\n# VM version: JDK 1.8.0_312, OpenJDK 64-Bit Server VM, 25.312-b07\n# VM invoker: /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java\n# VM options: <none>\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\n\n# Run progress: 0.00% complete, ETA 00:01:40\n# Fork: 1 of 2\n# Warmup Iteration   1: 42984830.445 ops/s\n# Warmup Iteration   2: 38416032.086 ops/s\nIteration   1: 39423217.883 ops/s\nIteration   2: 41176380.793 ops/s\nIteration   3: 41146374.512 ops/s\n\n# Run progress: 25.00% complete, ETA 00:01:15\n# Fork: 2 of 2\n# Warmup Iteration   1: 42000026.386 ops/s\n# Warmup Iteration   2: 37801042.365 ops/s\nIteration   1: 38829603.637 ops/s\nIteration   2: 39873697.470 ops/s\nIteration   3: 39745609.268 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\":\n  40032480.594 \u00b1(99.9%) 2652852.116 ops/s [Average]\n  (min, avg, max) = (38829603.637, 40032480.594, 41176380.793), stdev = 946032.620\n  CI (99.9%): [37379628.478, 42685332.710] (assumes normal distribution)\n\n\n# JMH version: 1.35\n# VM version: JDK 1.8.0_312, OpenJDK 64-Bit Server VM, 25.312-b07\n# VM invoker: /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java\n# VM options: <none>\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\n\n# Run progress: 50.00% complete, ETA 00:00:50\n# Fork: 1 of 2\n# Warmup Iteration   1: 867041643.912 ops/s\n# Warmup Iteration   2: 879285059.514 ops/s\nIteration   1: 946381466.173 ops/s\nIteration   2: 829405048.842 ops/s\nIteration   3: 904068960.001 ops/s\n\n# Run progress: 75.00% complete, ETA 00:00:25\n# Fork: 2 of 2\n# Warmup Iteration   1: 801375284.635 ops/s\n# Warmup Iteration   2: 1023301849.860 ops/s\nIteration   1: 864155832.112 ops/s\nIteration   2: 939504012.429 ops/s\nIteration   3: 913166819.166 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\":\n  899447023.121 \u00b1(99.9%) 126458224.528 ops/s [Average]\n  (min, avg, max) = (829405048.842, 899447023.121, 946381466.173), stdev = 45096221.050\n  CI (99.9%): [772988798.593, 1025905247.649] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:01:41\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                                                      Mode  Cnt          Score           Error  Units\nConcurrentHashMapBenchmark.benchmarkComputeIfAbsent           thrpt    6   40032480.594 \u00b1   2652852.116  ops/s\nConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent  thrpt    6  899447023.121 \u00b1 126458224.528  ops/s\"><pre class=\"notranslate\"><code class=\"notranslate\">root@GZYZFA00088591:/mnt/d/develop/github/benchmark/dledger-benchmark# java -jar target/dledger-benchmarks.jar com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark\n# JMH version: 1.35\n# VM version: JDK 1.8.0_312, OpenJDK 64-Bit Server VM, 25.312-b07\n# VM invoker: /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java\n# VM options: <none>\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\n\n# Run progress: 0.00% complete, ETA 00:01:40\n# Fork: 1 of 2\n# Warmup Iteration   1: 42984830.445 ops/s\n# Warmup Iteration   2: 38416032.086 ops/s\nIteration   1: 39423217.883 ops/s\nIteration   2: 41176380.793 ops/s\nIteration   3: 41146374.512 ops/s\n\n# Run progress: 25.00% complete, ETA 00:01:15\n# Fork: 2 of 2\n# Warmup Iteration   1: 42000026.386 ops/s\n# Warmup Iteration   2: 37801042.365 ops/s\nIteration   1: 38829603.637 ops/s\nIteration   2: 39873697.470 ops/s\nIteration   3: 39745609.268 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\":\n  40032480.594 \u00b1(99.9%) 2652852.116 ops/s [Average]\n  (min, avg, max) = (38829603.637, 40032480.594, 41176380.793), stdev = 946032.620\n  CI (99.9%): [37379628.478, 42685332.710] (assumes normal distribution)\n\n\n# JMH version: 1.35\n# VM version: JDK 1.8.0_312, OpenJDK 64-Bit Server VM, 25.312-b07\n# VM invoker: /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java\n# VM options: <none>\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\n\n# Run progress: 50.00% complete, ETA 00:00:50\n# Fork: 1 of 2\n# Warmup Iteration   1: 867041643.912 ops/s\n# Warmup Iteration   2: 879285059.514 ops/s\nIteration   1: 946381466.173 ops/s\nIteration   2: 829405048.842 ops/s\nIteration   3: 904068960.001 ops/s\n\n# Run progress: 75.00% complete, ETA 00:00:25\n# Fork: 2 of 2\n# Warmup Iteration   1: 801375284.635 ops/s\n# Warmup Iteration   2: 1023301849.860 ops/s\nIteration   1: 864155832.112 ops/s\nIteration   2: 939504012.429 ops/s\nIteration   3: 913166819.166 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\":\n  899447023.121 \u00b1(99.9%) 126458224.528 ops/s [Average]\n  (min, avg, max) = (829405048.842, 899447023.121, 946381466.173), stdev = 45096221.050\n  CI (99.9%): [772988798.593, 1025905247.649] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:01:41\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                                                      Mode  Cnt          Score           Error  Units\nConcurrentHashMapBenchmark.benchmarkComputeIfAbsent           thrpt    6   40032480.594 \u00b1   2652852.116  ops/s\nConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent  thrpt    6  899447023.121 \u00b1 126458224.528  ops/s\n</code></pre></div>\n<p dir=\"auto\">jdk11 version\uff1a<br>\nopenjdk version \"11.0.14.1\" 2022-02-08<br>\nOpenJDK Runtime Environment (build 11.0.14.1+1-Ubuntu-0ubuntu1.18.04)<br>\nOpenJDK 64-Bit Server VM (build 11.0.14.1+1-Ubuntu-0ubuntu1.18.04, mixed mode, sharing)</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"root@GZYZFA00088591:/mnt/d/develop/github/benchmark/dledger-benchmark# java -jar target/dledger-benchmarks.jar com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark\nWARNING: An illegal reflective access operation has occurred\nWARNING: Illegal reflective access by org.openjdk.jmh.util.Utils (file:/mnt/d/develop/github/benchmark/dledger-benchmark/target/dledger-benchmarks.jar) to method java.io.Console.encoding()\nWARNING: Please consider reporting this to the maintainers of org.openjdk.jmh.util.Utils\nWARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations\nWARNING: All illegal access operations will be denied in a future release\n# JMH version: 1.35\n# VM version: JDK 11.0.14.1, OpenJDK 64-Bit Server VM, 11.0.14.1+1-Ubuntu-0ubuntu1.18.04\n# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java\n# VM options: <none>\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\n\n# Run progress: 0.00% complete, ETA 00:01:40\n# Fork: 1 of 2\n# Warmup Iteration   1: 734790850.730 ops/s\n# Warmup Iteration   2: 723040919.893 ops/s\nIteration   1: 641529840.743 ops/s\nIteration   2: 711719044.738 ops/s\nIteration   3: 683114525.450 ops/s\n\n# Run progress: 25.00% complete, ETA 00:01:16\n# Fork: 2 of 2\n# Warmup Iteration   1: 658869896.647 ops/s\n# Warmup Iteration   2: 634635199.677 ops/s\nIteration   1: 682154939.057 ops/s\nIteration   2: 684056273.846 ops/s\nIteration   3: 684466801.465 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\":\n  681173570.883 \u00b1(99.9%) 63060380.600 ops/s [Average]\n  (min, avg, max) = (641529840.743, 681173570.883, 711719044.738), stdev = 22487939.188\n  CI (99.9%): [618113190.283, 744233951.483] (assumes normal distribution)\n\n\n# JMH version: 1.35\n# VM version: JDK 11.0.14.1, OpenJDK 64-Bit Server VM, 11.0.14.1+1-Ubuntu-0ubuntu1.18.04\n# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java\n# VM options: <none>\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\n\n# Run progress: 50.00% complete, ETA 00:00:50\n# Fork: 1 of 2\n# Warmup Iteration   1: 913175624.693 ops/s\n# Warmup Iteration   2: 889999077.476 ops/s\nIteration   1: 755423064.811 ops/s\nIteration   2: 819973081.401 ops/s\nIteration   3: 819069238.312 ops/s\n\n# Run progress: 75.00% complete, ETA 00:00:25\n# Fork: 2 of 2\n# Warmup Iteration   1: 755788304.744 ops/s\n# Warmup Iteration   2: 749372817.128 ops/s\nIteration   1: 840515776.127 ops/s\nIteration   2: 872478443.625 ops/s\nIteration   3: 848340384.022 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\":\n  825966664.716 \u00b1(99.9%) 111714396.868 ops/s [Average]\n  (min, avg, max) = (755423064.811, 825966664.716, 872478443.625), stdev = 39838430.078\n  CI (99.9%): [714252267.848, 937681061.585] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:01:41\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                                                      Mode  Cnt          Score           Error  Units\nConcurrentHashMapBenchmark.benchmarkComputeIfAbsent           thrpt    6  681173570.883 \u00b1  63060380.600  ops/s\nConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent  thrpt    6  825966664.716 \u00b1 111714396.868  ops/s\"><pre class=\"notranslate\"><code class=\"notranslate\">root@GZYZFA00088591:/mnt/d/develop/github/benchmark/dledger-benchmark# java -jar target/dledger-benchmarks.jar com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark\nWARNING: An illegal reflective access operation has occurred\nWARNING: Illegal reflective access by org.openjdk.jmh.util.Utils (file:/mnt/d/develop/github/benchmark/dledger-benchmark/target/dledger-benchmarks.jar) to method java.io.Console.encoding()\nWARNING: Please consider reporting this to the maintainers of org.openjdk.jmh.util.Utils\nWARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations\nWARNING: All illegal access operations will be denied in a future release\n# JMH version: 1.35\n# VM version: JDK 11.0.14.1, OpenJDK 64-Bit Server VM, 11.0.14.1+1-Ubuntu-0ubuntu1.18.04\n# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java\n# VM options: <none>\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\n\n# Run progress: 0.00% complete, ETA 00:01:40\n# Fork: 1 of 2\n# Warmup Iteration   1: 734790850.730 ops/s\n# Warmup Iteration   2: 723040919.893 ops/s\nIteration   1: 641529840.743 ops/s\nIteration   2: 711719044.738 ops/s\nIteration   3: 683114525.450 ops/s\n\n# Run progress: 25.00% complete, ETA 00:01:16\n# Fork: 2 of 2\n# Warmup Iteration   1: 658869896.647 ops/s\n# Warmup Iteration   2: 634635199.677 ops/s\nIteration   1: 682154939.057 ops/s\nIteration   2: 684056273.846 ops/s\nIteration   3: 684466801.465 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\":\n  681173570.883 \u00b1(99.9%) 63060380.600 ops/s [Average]\n  (min, avg, max) = (641529840.743, 681173570.883, 711719044.738), stdev = 22487939.188\n  CI (99.9%): [618113190.283, 744233951.483] (assumes normal distribution)\n\n\n# JMH version: 1.35\n# VM version: JDK 11.0.14.1, OpenJDK 64-Bit Server VM, 11.0.14.1+1-Ubuntu-0ubuntu1.18.04\n# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java\n# VM options: <none>\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\n\n# Run progress: 50.00% complete, ETA 00:00:50\n# Fork: 1 of 2\n# Warmup Iteration   1: 913175624.693 ops/s\n# Warmup Iteration   2: 889999077.476 ops/s\nIteration   1: 755423064.811 ops/s\nIteration   2: 819973081.401 ops/s\nIteration   3: 819069238.312 ops/s\n\n# Run progress: 75.00% complete, ETA 00:00:25\n# Fork: 2 of 2\n# Warmup Iteration   1: 755788304.744 ops/s\n# Warmup Iteration   2: 749372817.128 ops/s\nIteration   1: 840515776.127 ops/s\nIteration   2: 872478443.625 ops/s\nIteration   3: 848340384.022 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\":\n  825966664.716 \u00b1(99.9%) 111714396.868 ops/s [Average]\n  (min, avg, max) = (755423064.811, 825966664.716, 872478443.625), stdev = 39838430.078\n  CI (99.9%): [714252267.848, 937681061.585] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:01:41\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                                                      Mode  Cnt          Score           Error  Units\nConcurrentHashMapBenchmark.benchmarkComputeIfAbsent           thrpt    6  681173570.883 \u00b1  63060380.600  ops/s\nConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent  thrpt    6  825966664.716 \u00b1 111714396.868  ops/s\n</code></pre></div>\n<p dir=\"auto\">jdk version >= 9 has fixed it.  RocketMQ run on jdk8+ so we need to solve it.</p>",
  "description_text": "\nopenjdk bug report .\nuse JMH to test it:\n concurrentMap = new ConcurrentHashMap<>();\n\n    @Setup(Level.Iteration)\n    public void setup() {\n        concurrentMap.clear();\n    }\n\n    @Benchmark\n    @Threads(16)\n    public Object benchmarkGetBeforeComputeIfAbsent() {\n        Object result = concurrentMap.get(KEY);\n        if (null == result) {\n            result = concurrentMap.computeIfAbsent(KEY, key -> 1);\n        }\n        return result;\n    }\n\n    @Benchmark\n    @Threads(16)\n    public Object benchmarkComputeIfAbsent() {\n        return concurrentMap.computeIfAbsent(KEY, key -> 1);\n    }\n\n}\">import java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.openjdk.jmh.annotations.Benchmark;\nimport org.openjdk.jmh.annotations.Fork;\nimport org.openjdk.jmh.annotations.Level;\nimport org.openjdk.jmh.annotations.Measurement;\nimport org.openjdk.jmh.annotations.Scope;\nimport org.openjdk.jmh.annotations.Setup;\nimport org.openjdk.jmh.annotations.State;\nimport org.openjdk.jmh.annotations.Threads;\nimport org.openjdk.jmh.annotations.Warmup;\n\n\n@Warmup(iterations = 2, time = 5)\n@Measurement(iterations = 3, time = 5)\n@State(Scope.Benchmark)\n@Fork(2)\npublic class HashMapBenchmark {\n\n    private static final String KEY = \"mxsm\";\n\n    private final Map<String, Object> concurrentMap = new ConcurrentHashMap<>();\n\n    @Setup(Level.Iteration)\n    public void setup() {\n        concurrentMap.clear();\n    }\n\n    @Benchmark\n    @Threads(16)\n    public Object benchmarkGetBeforeComputeIfAbsent() {\n        Object result = concurrentMap.get(KEY);\n        if (null == result) {\n            result = concurrentMap.computeIfAbsent(KEY, key -> 1);\n        }\n        return result;\n    }\n\n    @Benchmark\n    @Threads(16)\n    public Object benchmarkComputeIfAbsent() {\n        return concurrentMap.computeIfAbsent(KEY, key -> 1);\n    }\n\n}\njdk version:\nopenjdk version \"1.8.0_312\"\nOpenJDK Runtime Environment (build 1.8.0_312-8u312-b07-0ubuntu1~18.04-b07)\nOpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode)\n\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\n\n# Run progress: 50.00% complete, ETA 00:00:50\n# Fork: 1 of 2\n# Warmup Iteration   1: 867041643.912 ops/s\n# Warmup Iteration   2: 879285059.514 ops/s\nIteration   1: 946381466.173 ops/s\nIteration   2: 829405048.842 ops/s\nIteration   3: 904068960.001 ops/s\n\n# Run progress: 75.00% complete, ETA 00:00:25\n# Fork: 2 of 2\n# Warmup Iteration   1: 801375284.635 ops/s\n# Warmup Iteration   2: 1023301849.860 ops/s\nIteration   1: 864155832.112 ops/s\nIteration   2: 939504012.429 ops/s\nIteration   3: 913166819.166 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\":\n  899447023.121 \u00b1(99.9%) 126458224.528 ops/s [Average]\n  (min, avg, max) = (829405048.842, 899447023.121, 946381466.173), stdev = 45096221.050\n  CI (99.9%): [772988798.593, 1025905247.649] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:01:41\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                                                      Mode  Cnt          Score           Error  Units\nConcurrentHashMapBenchmark.benchmarkComputeIfAbsent           thrpt    6   40032480.594 \u00b1   2652852.116  ops/s\nConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent  thrpt    6  899447023.121 \u00b1 126458224.528  ops/s\">root@GZYZFA00088591:/mnt/d/develop/github/benchmark/dledger-benchmark# java -jar target/dledger-benchmarks.jar com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark\n# JMH version: 1.35\n# VM version: JDK 1.8.0_312, OpenJDK 64-Bit Server VM, 25.312-b07\n# VM invoker: /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java\n# VM options: \n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\n\n# Run progress: 0.00% complete, ETA 00:01:40\n# Fork: 1 of 2\n# Warmup Iteration   1: 42984830.445 ops/s\n# Warmup Iteration   2: 38416032.086 ops/s\nIteration   1: 39423217.883 ops/s\nIteration   2: 41176380.793 ops/s\nIteration   3: 41146374.512 ops/s\n\n# Run progress: 25.00% complete, ETA 00:01:15\n# Fork: 2 of 2\n# Warmup Iteration   1: 42000026.386 ops/s\n# Warmup Iteration   2: 37801042.365 ops/s\nIteration   1: 38829603.637 ops/s\nIteration   2: 39873697.470 ops/s\nIteration   3: 39745609.268 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\":\n  40032480.594 \u00b1(99.9%) 2652852.116 ops/s [Average]\n  (min, avg, max) = (38829603.637, 40032480.594, 41176380.793), stdev = 946032.620\n  CI (99.9%): [37379628.478, 42685332.710] (assumes normal distribution)\n\n\n# JMH version: 1.35\n# VM version: JDK 1.8.0_312, OpenJDK 64-Bit Server VM, 25.312-b07\n# VM invoker: /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java\n# VM options: \n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\n\n# Run progress: 50.00% complete, ETA 00:00:50\n# Fork: 1 of 2\n# Warmup Iteration   1: 867041643.912 ops/s\n# Warmup Iteration   2: 879285059.514 ops/s\nIteration   1: 946381466.173 ops/s\nIteration   2: 829405048.842 ops/s\nIteration   3: 904068960.001 ops/s\n\n# Run progress: 75.00% complete, ETA 00:00:25\n# Fork: 2 of 2\n# Warmup Iteration   1: 801375284.635 ops/s\n# Warmup Iteration   2: 1023301849.860 ops/s\nIteration   1: 864155832.112 ops/s\nIteration   2: 939504012.429 ops/s\nIteration   3: 913166819.166 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\":\n  899447023.121 \u00b1(99.9%) 126458224.528 ops/s [Average]\n  (min, avg, max) = (829405048.842, 899447023.121, 946381466.173), stdev = 45096221.050\n  CI (99.9%): [772988798.593, 1025905247.649] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:01:41\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                                                      Mode  Cnt          Score           Error  Units\nConcurrentHashMapBenchmark.benchmarkComputeIfAbsent           thrpt    6   40032480.594 \u00b1   2652852.116  ops/s\nConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent  thrpt    6  899447023.121 \u00b1 126458224.528  ops/s\n\njdk11 version\uff1a\nopenjdk version \"11.0.14.1\" 2022-02-08\nOpenJDK Runtime Environment (build 11.0.14.1+1-Ubuntu-0ubuntu1.18.04)\nOpenJDK 64-Bit Server VM (build 11.0.14.1+1-Ubuntu-0ubuntu1.18.04, mixed mode, sharing)\n\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\n\n# Run progress: 50.00% complete, ETA 00:00:50\n# Fork: 1 of 2\n# Warmup Iteration   1: 913175624.693 ops/s\n# Warmup Iteration   2: 889999077.476 ops/s\nIteration   1: 755423064.811 ops/s\nIteration   2: 819973081.401 ops/s\nIteration   3: 819069238.312 ops/s\n\n# Run progress: 75.00% complete, ETA 00:00:25\n# Fork: 2 of 2\n# Warmup Iteration   1: 755788304.744 ops/s\n# Warmup Iteration   2: 749372817.128 ops/s\nIteration   1: 840515776.127 ops/s\nIteration   2: 872478443.625 ops/s\nIteration   3: 848340384.022 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\":\n  825966664.716 \u00b1(99.9%) 111714396.868 ops/s [Average]\n  (min, avg, max) = (755423064.811, 825966664.716, 872478443.625), stdev = 39838430.078\n  CI (99.9%): [714252267.848, 937681061.585] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:01:41\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                                                      Mode  Cnt          Score           Error  Units\nConcurrentHashMapBenchmark.benchmarkComputeIfAbsent           thrpt    6  681173570.883 \u00b1  63060380.600  ops/s\nConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent  thrpt    6  825966664.716 \u00b1 111714396.868  ops/s\">root@GZYZFA00088591:/mnt/d/develop/github/benchmark/dledger-benchmark# java -jar target/dledger-benchmarks.jar com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark\nWARNING: An illegal reflective access operation has occurred\nWARNING: Illegal reflective access by org.openjdk.jmh.util.Utils (file:/mnt/d/develop/github/benchmark/dledger-benchmark/target/dledger-benchmarks.jar) to method java.io.Console.encoding()\nWARNING: Please consider reporting this to the maintainers of org.openjdk.jmh.util.Utils\nWARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations\nWARNING: All illegal access operations will be denied in a future release\n# JMH version: 1.35\n# VM version: JDK 11.0.14.1, OpenJDK 64-Bit Server VM, 11.0.14.1+1-Ubuntu-0ubuntu1.18.04\n# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java\n# VM options: \n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\n\n# Run progress: 0.00% complete, ETA 00:01:40\n# Fork: 1 of 2\n# Warmup Iteration   1: 734790850.730 ops/s\n# Warmup Iteration   2: 723040919.893 ops/s\nIteration   1: 641529840.743 ops/s\nIteration   2: 711719044.738 ops/s\nIteration   3: 683114525.450 ops/s\n\n# Run progress: 25.00% complete, ETA 00:01:16\n# Fork: 2 of 2\n# Warmup Iteration   1: 658869896.647 ops/s\n# Warmup Iteration   2: 634635199.677 ops/s\nIteration   1: 682154939.057 ops/s\nIteration   2: 684056273.846 ops/s\nIteration   3: 684466801.465 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkComputeIfAbsent\":\n  681173570.883 \u00b1(99.9%) 63060380.600 ops/s [Average]\n  (min, avg, max) = (641529840.743, 681173570.883, 711719044.738), stdev = 22487939.188\n  CI (99.9%): [618113190.283, 744233951.483] (assumes normal distribution)\n\n\n# JMH version: 1.35\n# VM version: JDK 11.0.14.1, OpenJDK 64-Bit Server VM, 11.0.14.1+1-Ubuntu-0ubuntu1.18.04\n# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java\n# VM options: \n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 5 s each\n# Measurement: 3 iterations, 5 s each\n# Timeout: 10 min per iteration\n# Threads: 16 threads, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\n\n# Run progress: 50.00% complete, ETA 00:00:50\n# Fork: 1 of 2\n# Warmup Iteration   1: 913175624.693 ops/s\n# Warmup Iteration   2: 889999077.476 ops/s\nIteration   1: 755423064.811 ops/s\nIteration   2: 819973081.401 ops/s\nIteration   3: 819069238.312 ops/s\n\n# Run progress: 75.00% complete, ETA 00:00:25\n# Fork: 2 of 2\n# Warmup Iteration   1: 755788304.744 ops/s\n# Warmup Iteration   2: 749372817.128 ops/s\nIteration   1: 840515776.127 ops/s\nIteration   2: 872478443.625 ops/s\nIteration   3: 848340384.022 ops/s\n\n\nResult \"com.github.mxsm.dledger.benchmark.ConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent\":\n  825966664.716 \u00b1(99.9%) 111714396.868 ops/s [Average]\n  (min, avg, max) = (755423064.811, 825966664.716, 872478443.625), stdev = 39838430.078\n  CI (99.9%): [714252267.848, 937681061.585] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:01:41\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                                                      Mode  Cnt          Score           Error  Units\nConcurrentHashMapBenchmark.benchmarkComputeIfAbsent           thrpt    6  681173570.883 \u00b1  63060380.600  ops/s\nConcurrentHashMapBenchmark.benchmarkGetBeforeComputeIfAbsent  thrpt    6  825966664.716 \u00b1 111714396.868  ops/s\n\njdk version >= 9 has fixed it.  RocketMQ run on jdk8+ so we need to solve it."
}