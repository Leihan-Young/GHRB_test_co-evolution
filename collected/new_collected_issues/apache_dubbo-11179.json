{
  "issue_id": 11168,
  "issue_url": "https://github.com/apache/dubbo/issues/11168",
  "title": "Calling a method on a ReferenceConfig changes the current thread's context classloader and doesn't reset it back",
  "description": "<p dir=\"auto\">The following change introduced switching the current thread's classloader when decoding the result of a call over Dubbo:<br>\n<a href=\"https://github.com/apache/dubbo/pull/8737/files#diff-d86267b6e1a01363575f5353debcb5c7fd6ad017afd2adb75e914bc4102d592e\">https://github.com/apache/dubbo/pull/8737/files#diff-d86267b6e1a01363575f5353debcb5c7fd6ad017afd2adb75e914bc4102d592e</a></p>\n<p dir=\"auto\">However, after the deserialization is done, the classloader is not switched back to what it was before. Not only is it considered bad practice not to reset the thread context classloader (for example in a try-finally block), it seems like this is an unintended side effect of calling a method of a remote service which in our case breaks the functionality when we migrated from Dubbo 2.x to 3.x.</p>\n<p dir=\"auto\">I have searched the <a href=\"https://github.com/apache/dubbo/issues\">issues</a> of this repository and believe that this is not a duplicate.</p>\n<h3 dir=\"auto\">Environment</h3>\n<ul dir=\"auto\">\n<li>Dubbo version: 3.1.3</li>\n<li>Operating System version: Linux</li>\n<li>Java version: 11</li>\n</ul>\n<h3 dir=\"auto\">Steps to reproduce this issue</h3>\n<ol dir=\"auto\">\n<li>Create a ReferenceConfig with one classloader (for example in a Tomcat Resource specified in server.xml, using the common or system classloader (most probably AppClassLoader))</li>\n<li>Call a method on the reference from a different classloader (for example from a webapp deployed to Tomcat, which uses the ParallelWebappClassLoader)</li>\n<li>The call will switch the thread context classloader from ParallelWebappClassLoader to AppClassLoader and leave it that way without resetting it.</li>\n</ol>\n<h3 dir=\"auto\">Expected Behavior</h3>\n<p dir=\"auto\">After the call to a Dubbo reference the classloader of the current thread should be the same as before the call.</p>\n<h3 dir=\"auto\">Actual Behavior</h3>\n<p dir=\"auto\">The classloader of the current thread is changed and isn't reset.</p>",
  "description_text": "The following change introduced switching the current thread's classloader when decoding the result of a call over Dubbo:\nhttps://github.com/apache/dubbo/pull/8737/files#diff-d86267b6e1a01363575f5353debcb5c7fd6ad017afd2adb75e914bc4102d592e\nHowever, after the deserialization is done, the classloader is not switched back to what it was before. Not only is it considered bad practice not to reset the thread context classloader (for example in a try-finally block), it seems like this is an unintended side effect of calling a method of a remote service which in our case breaks the functionality when we migrated from Dubbo 2.x to 3.x.\nI have searched the issues of this repository and believe that this is not a duplicate.\nEnvironment\n\nDubbo version: 3.1.3\nOperating System version: Linux\nJava version: 11\n\nSteps to reproduce this issue\n\nCreate a ReferenceConfig with one classloader (for example in a Tomcat Resource specified in server.xml, using the common or system classloader (most probably AppClassLoader))\nCall a method on the reference from a different classloader (for example from a webapp deployed to Tomcat, which uses the ParallelWebappClassLoader)\nThe call will switch the thread context classloader from ParallelWebappClassLoader to AppClassLoader and leave it that way without resetting it.\n\nExpected Behavior\nAfter the call to a Dubbo reference the classloader of the current thread should be the same as before the call.\nActual Behavior\nThe classloader of the current thread is changed and isn't reset."
}