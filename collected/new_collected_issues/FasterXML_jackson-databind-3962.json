{
  "issue_id": 3924,
  "issue_url": "https://github.com/FasterXML/jackson-databind/issues/3924",
  "title": "Incorrect target type when disabling coercion, trying to deserialize String from Array/Object",
  "description": "<p dir=\"auto\">When disabling coercions and providing a wrong type on an array element, the error message is specifying that we are trying to coerce the type of the array when it should mention we are trying to coerce the type of the element of the array. See the example below. This is another instance of <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1478544963\" data-permission-text=\"Title is private\" data-url=\"https://github.com/FasterXML/jackson-databind/issues/3690\" data-hovercard-type=\"issue\" data-hovercard-url=\"/FasterXML/jackson-databind/issues/3690/hovercard\" href=\"https://github.com/FasterXML/jackson-databind/issues/3690\">#3690</a>.</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// Test class.\npublic static class Input<T> {\n    private T field;\n\n    public T getField() {\n        return field;\n    }\n\n    public void setField(T field) {\n        this.field = field;\n    }\n}\n\n// Building a strict ObjectMapper.\nObjectMapper objectMapper = JsonMapper.builder()\n    .withCoercionConfigDefaults(config -> {\n        config.setCoercion(CoercionInputShape.Boolean, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Integer, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Float, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.String, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Array, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Object, CoercionAction.Fail);\n    })\n    .build();\nTypeFactory typeFactory = objectMapper.getTypeFactory();\n\n// Test.\nJavaType arrayType = typeFactory.constructParametricType(List.class, String.class);\nJavaType inputType = typeFactory.constructParametricType(Input.class, arrayType);\ntry {\n    // Returns class java.lang.String + VALUE_NUMBER_INT -> correct.\n    objectMapper.readValue(\"{ \\\"field\\\": [ 1 ] }\", inputType);\n    // Returns class java.util.ArrayList + START_ARRAY -> was expecting target type to be String.\n    objectMapper.readValue(\"{ \\\"field\\\": [ [ 1 ] ] }\", inputType);\n    // Returns class java.util.ArrayList + START_OBJECT -> was expecting target type to be String.\n    objectMapper.readValue(\"{ \\\"field\\\": [ { \\\"field\\\": 1 } ] }\", inputType);\n} catch (MismatchedInputException exception) {\n    JsonParser parser = (JsonParser) exception.getProcessor();\n    System.out.println(exception.getTargetType());\n    System.out.println(parser.currentToken());\n}\n\n// A truly strict String parser.\n// If we register this deserializer in the ObjectMapper above we will then get the expected target type.\npublic class StringDeserializer extends JsonDeserializer<String> {\n    @Override\n    public String deserialize(JsonParser parser, DeserializationContext context) throws IOException {\n        if (!parser.hasToken(VALUE_STRING)) {\n            throw context.wrongTokenException(parser, String.class, VALUE_STRING, null);\n        }\n\n        return parser.getText();\n    }\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">// Test class.\npublic static class Input<T> {\n    private T field;\n\n    public T getField() {\n        return field;\n    }\n\n    public void setField(T field) {\n        this.field = field;\n    }\n}\n\n// Building a strict ObjectMapper.\nObjectMapper objectMapper = JsonMapper.builder()\n    .withCoercionConfigDefaults(config -> {\n        config.setCoercion(CoercionInputShape.Boolean, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Integer, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Float, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.String, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Array, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Object, CoercionAction.Fail);\n    })\n    .build();\nTypeFactory typeFactory = objectMapper.getTypeFactory();\n\n// Test.\nJavaType arrayType = typeFactory.constructParametricType(List.class, String.class);\nJavaType inputType = typeFactory.constructParametricType(Input.class, arrayType);\ntry {\n    // Returns class java.lang.String + VALUE_NUMBER_INT -> correct.\n    objectMapper.readValue(\"{ \\\"field\\\": [ 1 ] }\", inputType);\n    // Returns class java.util.ArrayList + START_ARRAY -> was expecting target type to be String.\n    objectMapper.readValue(\"{ \\\"field\\\": [ [ 1 ] ] }\", inputType);\n    // Returns class java.util.ArrayList + START_OBJECT -> was expecting target type to be String.\n    objectMapper.readValue(\"{ \\\"field\\\": [ { \\\"field\\\": 1 } ] }\", inputType);\n} catch (MismatchedInputException exception) {\n    JsonParser parser = (JsonParser) exception.getProcessor();\n    System.out.println(exception.getTargetType());\n    System.out.println(parser.currentToken());\n}\n\n// A truly strict String parser.\n// If we register this deserializer in the ObjectMapper above we will then get the expected target type.\npublic class StringDeserializer extends JsonDeserializer<String> {\n    @Override\n    public String deserialize(JsonParser parser, DeserializationContext context) throws IOException {\n        if (!parser.hasToken(VALUE_STRING)) {\n            throw context.wrongTokenException(parser, String.class, VALUE_STRING, null);\n        }\n\n        return parser.getText();\n    }\n}\n</code></pre></div>\n<p dir=\"auto\">This is our test suite for JSON strict parsing which we have used to open many such issues in the past, in case you want to take inspiration for Jackson tests.<br>\n<a href=\"https://github.com/FasterXML/jackson-databind/files/11461536/Test.zip\">Test.zip</a></p>",
  "description_text": "When disabling coercions and providing a wrong type on an array element, the error message is specifying that we are trying to coerce the type of the array when it should mention we are trying to coerce the type of the element of the array. See the example below. This is another instance of #3690.\n was expecting target type to be String.\n    objectMapper.readValue(\"{ \\\"field\\\": [ [ 1 ] ] }\", inputType);\n    // Returns class java.util.ArrayList + START_OBJECT -> was expecting target type to be String.\n    objectMapper.readValue(\"{ \\\"field\\\": [ { \\\"field\\\": 1 } ] }\", inputType);\n} catch (MismatchedInputException exception) {\n    JsonParser parser = (JsonParser) exception.getProcessor();\n    System.out.println(exception.getTargetType());\n    System.out.println(parser.currentToken());\n}\n\n// A truly strict String parser.\n// If we register this deserializer in the ObjectMapper above we will then get the expected target type.\npublic class StringDeserializer extends JsonDeserializer {\n    @Override\n    public String deserialize(JsonParser parser, DeserializationContext context) throws IOException {\n        if (!parser.hasToken(VALUE_STRING)) {\n            throw context.wrongTokenException(parser, String.class, VALUE_STRING, null);\n        }\n\n        return parser.getText();\n    }\n}\">// Test class.\npublic static class Input {\n    private T field;\n\n    public T getField() {\n        return field;\n    }\n\n    public void setField(T field) {\n        this.field = field;\n    }\n}\n\n// Building a strict ObjectMapper.\nObjectMapper objectMapper = JsonMapper.builder()\n    .withCoercionConfigDefaults(config -> {\n        config.setCoercion(CoercionInputShape.Boolean, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Integer, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Float, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.String, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Array, CoercionAction.Fail)\n            .setCoercion(CoercionInputShape.Object, CoercionAction.Fail);\n    })\n    .build();\nTypeFactory typeFactory = objectMapper.getTypeFactory();\n\n// Test.\nJavaType arrayType = typeFactory.constructParametricType(List.class, String.class);\nJavaType inputType = typeFactory.constructParametricType(Input.class, arrayType);\ntry {\n    // Returns class java.lang.String + VALUE_NUMBER_INT -> correct.\n    objectMapper.readValue(\"{ \\\"field\\\": [ 1 ] }\", inputType);\n    // Returns class java.util.ArrayList + START_ARRAY -> was expecting target type to be String.\n    objectMapper.readValue(\"{ \\\"field\\\": [ [ 1 ] ] }\", inputType);\n    // Returns class java.util.ArrayList + START_OBJECT -> was expecting target type to be String.\n    objectMapper.readValue(\"{ \\\"field\\\": [ { \\\"field\\\": 1 } ] }\", inputType);\n} catch (MismatchedInputException exception) {\n    JsonParser parser = (JsonParser) exception.getProcessor();\n    System.out.println(exception.getTargetType());\n    System.out.println(parser.currentToken());\n}\n\n// A truly strict String parser.\n// If we register this deserializer in the ObjectMapper above we will then get the expected target type.\npublic class StringDeserializer extends JsonDeserializer {\n    @Override\n    public String deserialize(JsonParser parser, DeserializationContext context) throws IOException {\n        if (!parser.hasToken(VALUE_STRING)) {\n            throw context.wrongTokenException(parser, String.class, VALUE_STRING, null);\n        }\n\n        return parser.getText();\n    }\n}\n\nThis is our test suite for JSON strict parsing which we have used to open many such issues in the past, in case you want to take inspiration for Jackson tests.\nTest.zip"
}