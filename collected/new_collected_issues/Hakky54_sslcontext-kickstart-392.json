{
  "issue_id": 391,
  "issue_url": "https://github.com/Hakky54/sslcontext-kickstart/issues/391",
  "title": "Disable \"Acceptable client certificate CA names\" on MTLS client connect.",
  "description": "<h3 dir=\"auto\">Discussed in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"5722198\" data-permission-text=\"Title is private\" data-url=\"https://github.com/Hakky54/sslcontext-kickstart/discussions/389\" data-hovercard-type=\"discussion\" data-hovercard-url=\"/Hakky54/sslcontext-kickstart/discussions/389/hovercard\" href=\"https://github.com/Hakky54/sslcontext-kickstart/discussions/389\">#389</a></h3>\n<div type=\"discussions-op-text\" dir=\"auto\">\n<p dir=\"auto\"><sup>Originally posted by <strong>gerardnorton</strong> October 10, 2023</sup><br>\nIn MTLS configuration, by default, all allowed clients CN are returned when a client initializes an SSL communication. This can lead to many security risks and information leaks.</p>\n<p dir=\"auto\">This is my server implementation:</p>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"@Bean\npublic ConfigurableServletWebServerFactory webServerFactory(\n                        SslContextFactory.Server sslContextFactory,\n                        @Value(\"${server.port}\") int serverPort) {\n     JettyServletWebServerFactory factory = new JettyServletWebServerFactory();\n     JettyServerCustomizer jettyServerCustomizer = server -> {\n          ServerConnector serverConnector = new ServerConnector(server, sslContextFactory);\n          serverConnector.setPort(serverPort);\n          server.setConnectors(new Connector[] {serverConnector});\n     };\n     factory.setServerCustomizers(Collections.singletonList(jettyServerCustomizer));\n     return factory;\n}\n\n@Bean\npublic SSLFactory sslFactory(@Value(\"${ssl.keystore-path}\") String keyStorePath,\n                        @Value(\"${ssl.keystore-password}\") String keyStorePassword,\n                        @Value(\"${ssl.truststore-path}\") String trustStorePath,\n                        @Value(\"${ssl.truststore-password}\") String trustStorePassword)\n                        throws Exception {\n    ...\n    return SSLFactory.builder()\n         .withIdentityMaterial(identityKeystore.toPath(), keyStorePassword.toCharArray())\n         .withTrustMaterial(identityTruststore.toPath(),   trustStorePassword.toCharArray())\n         .withSwappableIdentityMaterial().withSwappableTrustMaterial()\n         .withNeedClientAuthentication(Boolean.TRUE)\n         .withProtocols(\"TLSv1.3\", \"TLSv1.2\")\n         .withCiphers(\"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\", \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\")\n         .withSessionTimeout(3600).withSessionCacheSize(1024).build();\n}\n\n@Bean\npublic SslContextFactory.Server sslContextFactory(SSLFactory sslFactory) {\n         return JettySslUtils.forServer(sslFactory);\n}\"><pre class=\"notranslate\"><span class=\"pl-c1\">@</span><span class=\"pl-c1\">Bean</span>\n<span class=\"pl-k\">public</span> <span class=\"pl-smi\">ConfigurableServletWebServerFactory</span> <span class=\"pl-s1\">webServerFactory</span>(\n                        <span class=\"pl-smi\">SslContextFactory</span>.<span class=\"pl-smi\">Server</span> <span class=\"pl-s1\">sslContextFactory</span>,\n                        <span class=\"pl-c1\">@</span><span class=\"pl-c1\">Value</span>(<span class=\"pl-s\">\"${server.port}\"</span>) <span class=\"pl-smi\">int</span> <span class=\"pl-s1\">serverPort</span>) {\n     <span class=\"pl-smi\">JettyServletWebServerFactory</span> <span class=\"pl-s1\">factory</span> = <span class=\"pl-k\">new</span> <span class=\"pl-smi\">JettyServletWebServerFactory</span>();\n     <span class=\"pl-smi\">JettyServerCustomizer</span> <span class=\"pl-s1\">jettyServerCustomizer</span> = <span class=\"pl-s1\">server</span> -> {\n          <span class=\"pl-smi\">ServerConnector</span> <span class=\"pl-s1\">serverConnector</span> = <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ServerConnector</span>(<span class=\"pl-s1\">server</span>, <span class=\"pl-s1\">sslContextFactory</span>);\n          <span class=\"pl-s1\">serverConnector</span>.<span class=\"pl-en\">setPort</span>(<span class=\"pl-s1\">serverPort</span>);\n          <span class=\"pl-s1\">server</span>.<span class=\"pl-en\">setConnectors</span>(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">Connector</span>[] {<span class=\"pl-s1\">serverConnector</span>});\n     };\n     <span class=\"pl-s1\">factory</span>.<span class=\"pl-en\">setServerCustomizers</span>(<span class=\"pl-smi\">Collections</span>.<span class=\"pl-en\">singletonList</span>(<span class=\"pl-s1\">jettyServerCustomizer</span>));\n     <span class=\"pl-k\">return</span> <span class=\"pl-s1\">factory</span>;\n}\n\n<span class=\"pl-c1\">@</span><span class=\"pl-c1\">Bean</span>\n<span class=\"pl-k\">public</span> <span class=\"pl-smi\">SSLFactory</span> <span class=\"pl-s1\">sslFactory</span>(<span class=\"pl-c1\">@</span><span class=\"pl-c1\">Value</span>(<span class=\"pl-s\">\"${ssl.keystore-path}\"</span>) <span class=\"pl-smi\">String</span> <span class=\"pl-s1\">keyStorePath</span>,\n                        <span class=\"pl-c1\">@</span><span class=\"pl-c1\">Value</span>(<span class=\"pl-s\">\"${ssl.keystore-password}\"</span>) <span class=\"pl-smi\">String</span> <span class=\"pl-s1\">keyStorePassword</span>,\n                        <span class=\"pl-c1\">@</span><span class=\"pl-c1\">Value</span>(<span class=\"pl-s\">\"${ssl.truststore-path}\"</span>) <span class=\"pl-smi\">String</span> <span class=\"pl-s1\">trustStorePath</span>,\n                        <span class=\"pl-c1\">@</span><span class=\"pl-c1\">Value</span>(<span class=\"pl-s\">\"${ssl.truststore-password}\"</span>) <span class=\"pl-smi\">String</span> <span class=\"pl-s1\">trustStorePassword</span>)\n                        <span class=\"pl-k\">throws</span> <span class=\"pl-s1\">Exception</span> {\n    ...\n    <span class=\"pl-k\">return</span> <span class=\"pl-smi\">SSLFactory</span>.<span class=\"pl-en\">builder</span>()\n         .<span class=\"pl-en\">withIdentityMaterial</span>(<span class=\"pl-s1\">identityKeystore</span>.<span class=\"pl-en\">toPath</span>(), <span class=\"pl-s1\">keyStorePassword</span>.<span class=\"pl-en\">toCharArray</span>())\n         .<span class=\"pl-en\">withTrustMaterial</span>(<span class=\"pl-s1\">identityTruststore</span>.<span class=\"pl-en\">toPath</span>(),   <span class=\"pl-s1\">trustStorePassword</span>.<span class=\"pl-en\">toCharArray</span>())\n         .<span class=\"pl-en\">withSwappableIdentityMaterial</span>().<span class=\"pl-en\">withSwappableTrustMaterial</span>()\n         .<span class=\"pl-en\">withNeedClientAuthentication</span>(<span class=\"pl-smi\">Boolean</span>.<span class=\"pl-c1\">TRUE</span>)\n         .<span class=\"pl-en\">withProtocols</span>(<span class=\"pl-s\">\"TLSv1.3\"</span>, <span class=\"pl-s\">\"TLSv1.2\"</span>)\n         .<span class=\"pl-en\">withCiphers</span>(<span class=\"pl-s\">\"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\"</span>, <span class=\"pl-s\">\"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\"</span>)\n         .<span class=\"pl-en\">withSessionTimeout</span>(<span class=\"pl-c1\">3600</span>).<span class=\"pl-en\">withSessionCacheSize</span>(<span class=\"pl-c1\">1024</span>).<span class=\"pl-en\">build</span>();\n}\n\n<span class=\"pl-c1\">@</span><span class=\"pl-c1\">Bean</span>\n<span class=\"pl-k\">public</span> <span class=\"pl-smi\">SslContextFactory</span>.<span class=\"pl-smi\">Server</span> <span class=\"pl-s1\">sslContextFactory</span>(<span class=\"pl-smi\">SSLFactory</span> <span class=\"pl-s1\">sslFactory</span>) {\n         <span class=\"pl-k\">return</span> <span class=\"pl-smi\">JettySslUtils</span>.<span class=\"pl-en\">forServer</span>(<span class=\"pl-s1\">sslFactory</span>);\n}</pre></div>\n<p dir=\"auto\">Command to check issue:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"openssl s_client -showcerts -servername 127.0.0.1 -connect 127.0.0.1:8443 </dev/nul\"><pre class=\"notranslate\">openssl s_client -showcerts -servername 127.0.0.1 -connect 127.0.0.1:8443 <span class=\"pl-k\"><</span>/dev/nul</pre></div>\n<p dir=\"auto\">Partial reponse:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"Server certificate\nsubject=CN = ssl-server-cert\nissuer=CN = ssl-ca-cert\n\nAcceptable client certificate CA names\nCN = ssl-ca-cert\nCN = admin@localhost.local\nCN = demo01@hotmail.com\nCN = demo02@hotmail.com\nClient Certificate Types: ECDSA sign, RSA sign, DSA sign\nRequested Signature Algorithms: ECDSA+SHA256:ECDSA+SHA384:ECDSA+SHA512:Ed25519:Ed448:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA+SHA256:RSA+SHA384:RSA+SHA512:DSA+SHA256:ECDSA+SHA224:RSA+SHA224:DSA+SHA224:ECDSA+SHA1:RSA+SHA1:DSA+SHA1\nShared Requested Signature Algorithms: ECDSA+SHA256:ECDSA+SHA384:ECDSA+SHA512:Ed25519:Ed448:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA+SHA256:RSA+SHA384:RSA+SHA512:DSA+SHA256:ECDSA+SHA224:RSA+SHA224:DSA+SHA224\nPeer signing digest: SHA256\nPeer signature type: RSA-PSS\nServer Temp Key: X25519, 253 bits\n\nSSL handshake has read 2228 bytes and written 472 bytes\nVerification error: self-signed certificate in certificate chain\"><pre class=\"notranslate\">Server certificate\nsubject=CN = ssl-server-cert\nissuer=CN = ssl-ca-cert\n\nAcceptable client certificate CA names\nCN = ssl-ca-cert\nCN = admin@localhost.local\nCN = demo01@hotmail.com\nCN = demo02@hotmail.com\nClient Certificate Types: ECDSA sign, RSA sign, DSA sign\nRequested Signature Algorithms: ECDSA+SHA256:ECDSA+SHA384:ECDSA+SHA512:Ed25519:Ed448:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA+SHA256:RSA+SHA384:RSA+SHA512:DSA+SHA256:ECDSA+SHA224:RSA+SHA224:DSA+SHA224:ECDSA+SHA1:RSA+SHA1:DSA+SHA1\nShared Requested Signature Algorithms: ECDSA+SHA256:ECDSA+SHA384:ECDSA+SHA512:Ed25519:Ed448:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA+SHA256:RSA+SHA384:RSA+SHA512:DSA+SHA256:ECDSA+SHA224:RSA+SHA224:DSA+SHA224\nPeer signing digest: SHA256\nPeer signature type: RSA-PSS\nServer Temp Key: X25519, 253 bits\n\nSSL handshake has <span class=\"pl-c1\">read</span> 2228 bytes and written 472 bytes\nVerification error: self-signed certificate <span class=\"pl-k\">in</span> certificate chain</pre></div>\n<p dir=\"auto\">How can I disable the response of allowed clients in the truststore file?</p>\n<p dir=\"auto\">Best regards :-)</p>\n</div>",
  "description_text": "Discussed in #389\n\nOriginally posted by gerardnorton October 10, 2023\nIn MTLS configuration, by default, all allowed clients CN are returned when a client initializes an SSL communication. This can lead to many security risks and information leaks.\nThis is my server implementation:\n {\n          ServerConnector serverConnector = new ServerConnector(server, sslContextFactory);\n          serverConnector.setPort(serverPort);\n          server.setConnectors(new Connector[] {serverConnector});\n     };\n     factory.setServerCustomizers(Collections.singletonList(jettyServerCustomizer));\n     return factory;\n}\n\n@Bean\npublic SSLFactory sslFactory(@Value(\"${ssl.keystore-path}\") String keyStorePath,\n                        @Value(\"${ssl.keystore-password}\") String keyStorePassword,\n                        @Value(\"${ssl.truststore-path}\") String trustStorePath,\n                        @Value(\"${ssl.truststore-password}\") String trustStorePassword)\n                        throws Exception {\n    ...\n    return SSLFactory.builder()\n         .withIdentityMaterial(identityKeystore.toPath(), keyStorePassword.toCharArray())\n         .withTrustMaterial(identityTruststore.toPath(),   trustStorePassword.toCharArray())\n         .withSwappableIdentityMaterial().withSwappableTrustMaterial()\n         .withNeedClientAuthentication(Boolean.TRUE)\n         .withProtocols(\"TLSv1.3\", \"TLSv1.2\")\n         .withCiphers(\"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\", \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\")\n         .withSessionTimeout(3600).withSessionCacheSize(1024).build();\n}\n\n@Bean\npublic SslContextFactory.Server sslContextFactory(SSLFactory sslFactory) {\n         return JettySslUtils.forServer(sslFactory);\n}\">@Bean\npublic ConfigurableServletWebServerFactory webServerFactory(\n                        SslContextFactory.Server sslContextFactory,\n                        @Value(\"${server.port}\") int serverPort) {\n     JettyServletWebServerFactory factory = new JettyServletWebServerFactory();\n     JettyServerCustomizer jettyServerCustomizer = server -> {\n          ServerConnector serverConnector = new ServerConnector(server, sslContextFactory);\n          serverConnector.setPort(serverPort);\n          server.setConnectors(new Connector[] {serverConnector});\n     };\n     factory.setServerCustomizers(Collections.singletonList(jettyServerCustomizer));\n     return factory;\n}\n\n@Bean\npublic SSLFactory sslFactory(@Value(\"${ssl.keystore-path}\") String keyStorePath,\n                        @Value(\"${ssl.keystore-password}\") String keyStorePassword,\n                        @Value(\"${ssl.truststore-path}\") String trustStorePath,\n                        @Value(\"${ssl.truststore-password}\") String trustStorePassword)\n                        throws Exception {\n    ...\n    return SSLFactory.builder()\n         .withIdentityMaterial(identityKeystore.toPath(), keyStorePassword.toCharArray())\n         .withTrustMaterial(identityTruststore.toPath(),   trustStorePassword.toCharArray())\n         .withSwappableIdentityMaterial().withSwappableTrustMaterial()\n         .withNeedClientAuthentication(Boolean.TRUE)\n         .withProtocols(\"TLSv1.3\", \"TLSv1.2\")\n         .withCiphers(\"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\", \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\")\n         .withSessionTimeout(3600).withSessionCacheSize(1024).build();\n}\n\n@Bean\npublic SslContextFactory.Server sslContextFactory(SSLFactory sslFactory) {\n         return JettySslUtils.forServer(sslFactory);\n}\nCommand to check issue:\nopenssl s_client -showcerts -servername 127.0.0.1 -connect 127.0.0.1:8443 </dev/nul\nPartial reponse:\nServer certificate\nsubject=CN = ssl-server-cert\nissuer=CN = ssl-ca-cert\n\nAcceptable client certificate CA names\nCN = ssl-ca-cert\nCN = admin@localhost.local\nCN = demo01@hotmail.com\nCN = demo02@hotmail.com\nClient Certificate Types: ECDSA sign, RSA sign, DSA sign\nRequested Signature Algorithms: ECDSA+SHA256:ECDSA+SHA384:ECDSA+SHA512:Ed25519:Ed448:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA+SHA256:RSA+SHA384:RSA+SHA512:DSA+SHA256:ECDSA+SHA224:RSA+SHA224:DSA+SHA224:ECDSA+SHA1:RSA+SHA1:DSA+SHA1\nShared Requested Signature Algorithms: ECDSA+SHA256:ECDSA+SHA384:ECDSA+SHA512:Ed25519:Ed448:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA-PSS+SHA256:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA+SHA256:RSA+SHA384:RSA+SHA512:DSA+SHA256:ECDSA+SHA224:RSA+SHA224:DSA+SHA224\nPeer signing digest: SHA256\nPeer signature type: RSA-PSS\nServer Temp Key: X25519, 253 bits\n\nSSL handshake has read 2228 bytes and written 472 bytes\nVerification error: self-signed certificate in certificate chain\nHow can I disable the response of allowed clients in the truststore file?\nBest regards :-)\n"
}