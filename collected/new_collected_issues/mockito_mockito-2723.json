{
  "issue_id": 2720,
  "issue_url": "https://github.com/mockito/mockito/issues/2720",
  "title": "LocationImpl adds performance overheads due to instantiating a stack trace",
  "description": "<p dir=\"auto\">I'm trying to use Mockito in a test of a Java class I didn't write. It takes a dependency which I am stubbing out using Mockito. Skipping all of the business logic, the code ends up being rather similar to this:</p>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"SomeClass mocked = mock(SomeClass.class, Mockito.withSettings().stubOnly());\nwhen(mocked.someParam()).thenReturn(0);\n\nfor (int i = 0; i < bigNumber; i++) {\n    mocked.someParam();\n}\"><pre class=\"notranslate\"><span class=\"pl-smi\">SomeClass</span> <span class=\"pl-s1\">mocked</span> = <span class=\"pl-en\">mock</span>(<span class=\"pl-smi\">SomeClass</span>.<span class=\"pl-k\">class</span>, <span class=\"pl-smi\">Mockito</span>.<span class=\"pl-en\">withSettings</span>().<span class=\"pl-en\">stubOnly</span>());\n<span class=\"pl-en\">when</span>(<span class=\"pl-s1\">mocked</span>.<span class=\"pl-en\">someParam</span>()).<span class=\"pl-en\">thenReturn</span>(<span class=\"pl-c1\">0</span>);\n\n<span class=\"pl-k\">for</span> (<span class=\"pl-smi\">int</span> <span class=\"pl-s1\">i</span> = <span class=\"pl-c1\">0</span>; <span class=\"pl-s1\">i</span> < <span class=\"pl-s1\">bigNumber</span>; <span class=\"pl-s1\">i</span>++) {\n    <span class=\"pl-s1\">mocked</span>.<span class=\"pl-en\">someParam</span>();\n}</pre></div>\n<p dir=\"auto\">This is in Mockito 4.6.1. This is extremely slow, and looking at Mockito this seems to be a problem for two reasons.</p>\n<p dir=\"auto\">Firstly, when a mock invocation occurs, LocationImpl is instantiated. This instantiates a Throwable, which constructs a stack trace, error message, etc (which is then discarded). In my test, Mockito was generating 70k exceptions per second.</p>\n<p dir=\"auto\">The second slowdown that seemed to be affecting me comes from TypeSafeMatching.getArgumentType. This iterates through all of the methods on the argument matcher class to find the appropriate matches method, seemingly also for each method call. By performing this operation, a lot of JVM internal datastructures get copied - it calls Class.getMethods, which copies all the methods on the class. This method could probably be cached on a per-class basis.</p>\n<p dir=\"auto\">This dramatically affected my application's allocation rate; Mockito was leading to approx 3.4GiB/sec allocations. In the end, I rewrote my mock using ByteBuddy proxies directly. It took the test runtime from 30 seconds down to 1, with the number of exceptions being created per second going down from 70k to ~0.</p>\n<p dir=\"auto\">I know that Mockito isn't meant to be a Netty-like high performance library, but wanted to flag these two codepaths as affecting every mock call.</p>",
  "description_text": "I'm trying to use Mockito in a test of a Java class I didn't write. It takes a dependency which I am stubbing out using Mockito. Skipping all of the business logic, the code ends up being rather similar to this:\nSomeClass mocked = mock(SomeClass.class, Mockito.withSettings().stubOnly());\nwhen(mocked.someParam()).thenReturn(0);\n\nfor (int i = 0; i < bigNumber; i++) {\n    mocked.someParam();\n}\nThis is in Mockito 4.6.1. This is extremely slow, and looking at Mockito this seems to be a problem for two reasons.\nFirstly, when a mock invocation occurs, LocationImpl is instantiated. This instantiates a Throwable, which constructs a stack trace, error message, etc (which is then discarded). In my test, Mockito was generating 70k exceptions per second.\nThe second slowdown that seemed to be affecting me comes from TypeSafeMatching.getArgumentType. This iterates through all of the methods on the argument matcher class to find the appropriate matches method, seemingly also for each method call. By performing this operation, a lot of JVM internal datastructures get copied - it calls Class.getMethods, which copies all the methods on the class. This method could probably be cached on a per-class basis.\nThis dramatically affected my application's allocation rate; Mockito was leading to approx 3.4GiB/sec allocations. In the end, I rewrote my mock using ByteBuddy proxies directly. It took the test runtime from 30 seconds down to 1, with the number of exceptions being created per second going down from 70k to ~0.\nI know that Mockito isn't meant to be a Netty-like high performance library, but wanted to flag these two codepaths as affecting every mock call."
}