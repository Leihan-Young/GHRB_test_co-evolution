{
  "1": {
    "commit_src": "2b4a3c14458f564e7e0178f71979a41e7b7a42b7",
    "commit_tgt": "ef18bab1badbe6ce537254b3ff8fd288da1e7d4d",
    "changed_tests": [
      "pulsar-functions/utils/src/test/java/org/apache/pulsar/functions/utils/FunctionCommonTest.java"
    ],
    "refer_PR": "apache_pulsar-19750",
    "test_src": ".org.apache.pulsar.functions.utils.FunctionCommonTest#testDownloadFile",
    "test_tgt": [
      ".org.apache.pulsar.functions.utils.FunctionCommonTest#testDownloadFile",
      ".org.apache.pulsar.functions.utils.FunctionCommonTest#testDownloadFileWithBasicAuth"
    ],
    "test_src_code": "    @Test\n    public void testDownloadFile() throws Exception {\n        String jarHttpUrl = \"https://repo1.maven.org/maven2/org/apache/pulsar/pulsar-common/2.4.2/pulsar-common-2.4.2.jar\";\n        String testDir = FunctionCommonTest.class.getProtectionDomain().getCodeSource().getLocation().getPath();\n        File pkgFile = new File(testDir, UUID.randomUUID().toString());\n        FunctionCommon.downloadFromHttpUrl(jarHttpUrl, pkgFile);\n        Assert.assertTrue(pkgFile.exists());\n        pkgFile.delete();\n    }\n",
    "test_tgt_code": "    @Test\n    public void testDownloadFile() throws Exception {\n        final String jarHttpUrl = \"https://repo1.maven.org/maven2/org/apache/pulsar/pulsar-common/2.4.2/pulsar-common-2.4.2.jar\";\n        final File file = Files.newTemporaryFile();\n        file.deleteOnExit();\n        assertThat(file.length()).isZero();\n        FunctionCommon.downloadFromHttpUrl(jarHttpUrl, file);\n        assertThat(file.length()).isGreaterThan(0);\n    }\n",
    "focal_path_src": [
      "pulsar-functions/utils/src/main/java/org/apache/pulsar/functions/utils/FunctionCommon.java#downloadFromHttpUrl"
    ],
    "focal_path_tgt": [
      "pulsar-functions/utils/src/main/java/org/apache/pulsar/functions/utils/FunctionCommon.java#downloadFromHttpUrl"
    ],
    "focal_src": [
      "    public static void downloadFromHttpUrl(String destPkgUrl, File targetFile) throws IOException {\n        URL website = new URL(destPkgUrl);\n        try (InputStream in = website.openStream()) {\n            log.info(\"Downloading function package from {} to {} ...\", destPkgUrl, targetFile.getAbsoluteFile());\n            Files.copy(in, targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n        }\n        log.info(\"Downloading function package from {} to {} completed!\", destPkgUrl, targetFile.getAbsoluteFile());\n    }\n"
    ],
    "focal_tgt": [
      "    public static void downloadFromHttpUrl(String destPkgUrl, File targetFile) throws IOException {\n        final URL url = new URL(destPkgUrl);\n        final URLConnection connection = url.openConnection();\n        if (StringUtils.isNotEmpty(url.getUserInfo())) {\n            final AuthenticationDataBasic authBasic = new AuthenticationDataBasic(url.getUserInfo());\n            for (Map.Entry<String, String> header : authBasic.getHttpHeaders()) {\n                connection.setRequestProperty(header.getKey(), header.getValue());\n            }\n        }\n        try (InputStream in = connection.getInputStream()) {\n            log.info(\"Downloading function package from {} to {} ...\", destPkgUrl, targetFile.getAbsoluteFile());\n            Files.copy(in, targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n        }\n        log.info(\"Downloading function package from {} to {} completed!\", destPkgUrl, targetFile.getAbsoluteFile());\n    }\n"
    ],
    "test_id": 1,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testDownloadFile() throws Exception {\n    String jarHttpUrl = \"https://repo1.maven.org/maven2/org/apache/pulsar/pulsar-common/2.4.2/pulsar-common-2.4.2.jar\";\n    String testDir = FunctionCommonTest.class.getProtectionDomain().getCodeSource().getLocation().getPath();\n    File pkgFile = new File(testDir, UUID.randomUUID().toString());\n    FunctionCommon.downloadFromHttpUrl(jarHttpUrl, pkgFile);\n    Assert.assertTrue(pkgFile.exists());\n    pkgFile.delete();\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testDownloadFile() throws Exception {\n    String jarHttpUrl = \"https://repo1.maven.org/maven2/org/apache/pulsar/pulsar-common/2.4.2/pulsar-common-2.4.2.jar\";\n    String testDir = FunctionCommonTest.class.getProtectionDomain().getCodeSource().getLocation().getPath();\n    File pkgFile = new File(testDir, UUID.randomUUID().toString());\n    FunctionCommon.downloadFromHttpUrl(jarHttpUrl, pkgFile);\n    Assert.assertTrue(pkgFile.exists());\n    pkgFile.delete();\n}\n"
    ]
  },
  "2": {
    "commit_src": "d0d626be8f59107d9de624f813dd0d5012cc1311",
    "commit_tgt": "43a989862f548fa3f67708a5fff62eb764af878c",
    "changed_tests": [
      "pulsar-functions/instance/src/test/java/org/apache/pulsar/functions/source/TopicSchemaTest.java",
      "tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarFunctionsTest.java",
      "tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarFunctionsTestBase.java",
      "tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaTest.java",
      "tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainTest.java",
      "tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/utils/CommandGenerator.java"
    ],
    "refer_PR": "apache_pulsar-20115",
    "test_src": ".org.apache.pulsar.functions.source.TopicSchemaTest#testGetSchema",
    "test_tgt": [
      ".org.apache.pulsar.functions.source.TopicSchemaTest#testGetSchema"
    ],
    "test_src_code": "    @Test\n    public void testGetSchema() {\n        TopicSchema topicSchema = new TopicSchema(null);\n\n        String TOPIC = \"public/default/test\";\n        Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n        assertEquals(schema.getClass(), JSONSchema.class);\n\n        schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n        assertEquals(schema.getClass(), AvroSchema.class);\n\n        // use an arbitrary protobuf class for testing purpose\n        schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n        assertEquals(schema.getClass(), ProtobufSchema.class);\n\n        schema = topicSchema\n                .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n        assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n    }\n",
    "test_tgt_code": "    @Test\n    public void testGetSchema() {\n        TopicSchema topicSchema = new TopicSchema(null, Thread.currentThread().getContextClassLoader());\n\n        String TOPIC = \"public/default/test\";\n        Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n        assertEquals(schema.getClass(), JSONSchema.class);\n\n        schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n        assertEquals(schema.getClass(), AvroSchema.class);\n\n        // use an arbitrary protobuf class for testing purpose\n        schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n        assertEquals(schema.getClass(), ProtobufSchema.class);\n\n        schema = topicSchema\n                .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n        assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n    }\n",
    "focal_path_src": [
      "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/source/TopicSchema.java#TopicSchema"
    ],
    "focal_path_tgt": [
      "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/source/TopicSchema.java#TopicSchema"
    ],
    "focal_src": [
      "    public TopicSchema(PulsarClient client) {\n        this.client = client;\n    }\n"
    ],
    "focal_tgt": [
      "    public TopicSchema(PulsarClient client, ClassLoader functionsClassloader) {\n        this.client = client;\n        this.functionsClassloader = AccessController.doPrivileged(\n                (PrivilegedAction<URLClassLoader>) () -> new URLClassLoader(new URL[0], functionsClassloader)\n        );\n    }\n"
    ],
    "test_id": 2,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetSchema() {\n    TopicSchema topicSchema = new TopicSchema(null, getClass().getClassLoader());\n\n    String TOPIC = \"public/default/test\";\n    Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n    assertEquals(schema.getClass(), JSONSchema.class);\n\n    schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n    assertEquals(schema.getClass(), AvroSchema.class);\n\n    // use an arbitrary protobuf class for testing purpose\n    schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n    assertEquals(schema.getClass(), ProtobufSchema.class);\n\n    schema = topicSchema\n            .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n    assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n}\n",
      "@Test\npublic void testGetSchema() {\n    TopicSchema topicSchema = new TopicSchema(null, getClass().getClassLoader());\n\n    String TOPIC = \"public/default/test\";\n    Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n    assertEquals(schema.getClass(), JSONSchema.class);\n\n    schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n    assertEquals(schema.getClass(), AvroSchema.class);\n\n    // use an arbitrary protobuf class for testing purpose\n    schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n    assertEquals(schema.getClass(), ProtobufSchema.class);\n\n    schema = topicSchema\n            .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n    assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n}\n",
      "@Test\npublic void testGetSchema() {\n    TopicSchema topicSchema = new TopicSchema(null, this.getClass().getClassLoader());\n\n    String TOPIC = \"public/default/test\";\n    Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n    assertEquals(schema.getClass(), JSONSchema.class);\n\n    schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n    assertEquals(schema.getClass(), AvroSchema.class);\n\n    // use an arbitrary protobuf class for testing purpose\n    schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n    assertEquals(schema.getClass(), ProtobufSchema.class);\n\n    schema = topicSchema\n            .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n    assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n}\n",
      "@Test\npublic void testGetSchema() {\n    // the class loader can be null if no function is used\n    TopicSchema topicSchema = new TopicSchema(null, null);\n\n    String TOPIC = \"public/default/test\";\n    Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n    assertEquals(schema.getClass(), JSONSchema.class);\n\n    schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n    assertEquals(schema.getClass(), AvroSchema.class);\n\n    // use an arbitrary protobuf class for testing purpose\n    schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n    assertEquals(schema.getClass(), ProtobufSchema.class);\n\n    schema = topicSchema\n            .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n    assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n}\n",
      "@Test\npublic void testGetSchema() {\n    TopicSchema topicSchema = new TopicSchema(null, null);\n\n    String TOPIC = \"public/default/test\";\n    Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n    assertEquals(schema.getClass(), JSONSchema.class);\n\n    schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n    assertEquals(schema.getClass(), AvroSchema.class);\n\n    // use an arbitrary protobuf class for testing purpose\n    schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n    assertEquals(schema.getClass(), ProtobufSchema.class);\n\n    schema = topicSchema\n            .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n    assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testGetSchema() {\n    TopicSchema topicSchema = new TopicSchema(null, getClass().getClassLoader());\n\n    String TOPIC = \"public/default/test\";\n    Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n    assertEquals(schema.getClass(), JSONSchema.class);\n\n    schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n    assertEquals(schema.getClass(), AvroSchema.class);\n\n    // use an arbitrary protobuf class for testing purpose\n    schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n    assertEquals(schema.getClass(), ProtobufSchema.class);\n\n    schema = topicSchema\n            .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n    assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n}\n",
      "@Test\npublic void testGetSchema() {\n    TopicSchema topicSchema = new TopicSchema(null, getClass().getClassLoader());\n\n    String TOPIC = \"public/default/test\";\n    Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n    assertEquals(schema.getClass(), JSONSchema.class);\n\n    schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n    assertEquals(schema.getClass(), AvroSchema.class);\n\n    // use an arbitrary protobuf class for testing purpose\n    schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n    assertEquals(schema.getClass(), ProtobufSchema.class);\n\n    schema = topicSchema\n            .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n    assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n}\n",
      "@Test\npublic void testGetSchema() {\n    TopicSchema topicSchema = new TopicSchema(null, this.getClass().getClassLoader());\n\n    String TOPIC = \"public/default/test\";\n    Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n    assertEquals(schema.getClass(), JSONSchema.class);\n\n    schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n    assertEquals(schema.getClass(), AvroSchema.class);\n\n    // use an arbitrary protobuf class for testing purpose\n    schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n    assertEquals(schema.getClass(), ProtobufSchema.class);\n\n    schema = topicSchema\n            .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n    assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n}\n",
      "@Test\npublic void testGetSchema() {\n    // the class loader can be null if no function is used\n    TopicSchema topicSchema = new TopicSchema(null, null);\n\n    String TOPIC = \"public/default/test\";\n    Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n    assertEquals(schema.getClass(), JSONSchema.class);\n\n    schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n    assertEquals(schema.getClass(), AvroSchema.class);\n\n    // use an arbitrary protobuf class for testing purpose\n    schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n    assertEquals(schema.getClass(), ProtobufSchema.class);\n\n    schema = topicSchema\n            .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n    assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n}\n",
      "@Test\npublic void testGetSchema() {\n    TopicSchema topicSchema = new TopicSchema(null, null);\n\n    String TOPIC = \"public/default/test\";\n    Schema<?> schema = topicSchema.getSchema(TOPIC + \"1\", DummyClass.class, Optional.of(SchemaType.JSON));\n    assertEquals(schema.getClass(), JSONSchema.class);\n\n    schema = topicSchema.getSchema(TOPIC + \"2\", DummyClass.class, Optional.of(SchemaType.AVRO));\n    assertEquals(schema.getClass(), AvroSchema.class);\n\n    // use an arbitrary protobuf class for testing purpose\n    schema = topicSchema.getSchema(TOPIC + \"3\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF));\n    assertEquals(schema.getClass(), ProtobufSchema.class);\n\n    schema = topicSchema\n            .getSchema(TOPIC + \"4\", Request.ServiceRequest.class, Optional.of(SchemaType.PROTOBUF_NATIVE));\n    assertEquals(schema.getClass(), ProtobufNativeSchema.class);\n}\n"
    ]
  },
  "3": {
    "commit_src": "8b3c085e9d26605cca544068e8611d72e7012468",
    "commit_tgt": "510744c20d0339c4b29366f07bf1849cabb81dec",
    "changed_tests": [
      "pulsar-functions/runtime/src/test/java/org/apache/pulsar/functions/runtime/RuntimeUtilsTest.java"
    ],
    "refer_PR": "apache_pulsar-20443",
    "test_src": ".org.apache.pulsar.functions.runtime.RuntimeUtilsTest#getGoInstanceCmd",
    "test_tgt": [
      ".org.apache.pulsar.functions.runtime.RuntimeUtilsTest#getGoInstanceCmd"
    ],
    "test_src_code": "    @Test(dataProvider = \"k8sRuntime\")\n    public void getGoInstanceCmd(boolean k8sRuntime) throws IOException {\n        HashMap<String, String> goInstanceConfig;\n\n        InstanceConfig instanceConfig = new InstanceConfig();\n        instanceConfig.setClusterName(\"kluster\");\n        instanceConfig.setInstanceId(3000);\n        instanceConfig.setFunctionId(\"func-7734\");\n        instanceConfig.setFunctionVersion(\"1.0.0\");\n        instanceConfig.setMaxBufferedTuples(5);\n        instanceConfig.setPort(1337);\n        instanceConfig.setMetricsPort(60000);\n\n        AuthenticationConfig authConfig = AuthenticationConfig.builder()\n                .clientAuthenticationPlugin(\"org.apache.pulsar.client.impl.auth.AuthenticationToken\")\n                .clientAuthenticationParameters(\"file:///secret/token.jwt\")\n                .tlsTrustCertsFilePath(\"/secret/ca.cert.pem\")\n                .tlsHostnameVerificationEnable(true)\n                .tlsAllowInsecureConnection(false)\n                .build();\n\n        JSONObject userConfig = new JSONObject();\n        userConfig.put(\"word-of-the-day\", \"der Weltschmerz\");\n\n        JSONObject secretsMap = new JSONObject();\n        secretsMap.put(\"secret\", \"cake is a lie\");\n\n        Function.SourceSpec sources = Function.SourceSpec.newBuilder()\n                .setCleanupSubscription(true)\n                .setSubscriptionName(\"go-func-sub\")\n                .setTimeoutMs(500)\n                .putInputSpecs(\"go-func-input\", Function.ConsumerSpec.newBuilder().setIsRegexPattern(false).build())\n                .build();\n\n        Function.RetryDetails retryDetails = Function.RetryDetails.newBuilder()\n                .setDeadLetterTopic(\"go-func-deadletter\")\n                .setMaxMessageRetries(1)\n                .build();\n\n        Function.Resources resources = Function.Resources.newBuilder()\n                .setCpu(2)\n                .setDisk(1024)\n                .setRam(32)\n                .build();\n\n        Function.FunctionDetails functionDetails = Function.FunctionDetails.newBuilder()\n                .setAutoAck(true)\n                .setTenant(\"public\")\n                .setNamespace(\"default\")\n                .setName(\"go-func\")\n                .setLogTopic(\"go-func-log\")\n                .setProcessingGuarantees(Function.ProcessingGuarantees.ATLEAST_ONCE)\n                .setRuntime(Function.FunctionDetails.Runtime.GO)\n                .setSecretsMap(secretsMap.toJSONString())\n                .setParallelism(1)\n                .setSource(sources)\n                .setRetryDetails(retryDetails)\n                .setResources(resources)\n                .setUserConfig(userConfig.toJSONString())\n                .build();\n\n        instanceConfig.setFunctionDetails(functionDetails);\n\n        List<String> commands = RuntimeUtils.getGoInstanceCmd(instanceConfig, authConfig,\"config\", \"pulsar://localhost:6650\", k8sRuntime);\n        if (k8sRuntime) {\n            goInstanceConfig = new ObjectMapper().readValue(commands.get(2).replaceAll(\"^\\'|\\'$\", \"\"), HashMap.class);\n        } else {\n            goInstanceConfig = new ObjectMapper().readValue(commands.get(2), HashMap.class);\n        }\n        Assert.assertEquals(commands.toArray().length, 3);\n        Assert.assertEquals(commands.get(0), \"config\");\n        Assert.assertEquals(commands.get(1), \"-instance-conf\");\n        Assert.assertEquals(goInstanceConfig.get(\"maxBufTuples\"), 5);\n        Assert.assertEquals(goInstanceConfig.get(\"maxMessageRetries\"), 1);\n        Assert.assertEquals(goInstanceConfig.get(\"killAfterIdleMs\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"parallelism\"), 1);\n        Assert.assertEquals(goInstanceConfig.get(\"className\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"sourceSpecsTopic\"), \"go-func-input\");\n        Assert.assertEquals(goInstanceConfig.get(\"secretsMap\"), secretsMap.toString());\n        Assert.assertEquals(goInstanceConfig.get(\"sourceSchemaType\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"sinkSpecsTopic\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"clusterName\"), \"kluster\");\n        Assert.assertEquals(goInstanceConfig.get(\"nameSpace\"), \"default\");\n        Assert.assertEquals(goInstanceConfig.get(\"receiverQueueSize\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"tenant\"), \"public\");\n        Assert.assertEquals(goInstanceConfig.get(\"ram\"), 32);\n        Assert.assertEquals(goInstanceConfig.get(\"logTopic\"), \"go-func-log\");\n        Assert.assertEquals(goInstanceConfig.get(\"processingGuarantees\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"autoAck\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"regexPatternSubscription\"), false);\n        Assert.assertEquals(goInstanceConfig.get(\"pulsarServiceURL\"), \"pulsar://localhost:6650\");\n        Assert.assertEquals(goInstanceConfig.get(\"runtime\"), 3);\n        Assert.assertEquals(goInstanceConfig.get(\"cpu\"), 2.0);\n        Assert.assertEquals(goInstanceConfig.get(\"funcID\"), \"func-7734\");\n        Assert.assertEquals(goInstanceConfig.get(\"funcVersion\"), \"1.0.0\");\n        Assert.assertEquals(goInstanceConfig.get(\"disk\"), 1024);\n        Assert.assertEquals(goInstanceConfig.get(\"instanceID\"), 3000);\n        Assert.assertEquals(goInstanceConfig.get(\"cleanupSubscription\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"port\"), 1337);\n        Assert.assertEquals(goInstanceConfig.get(\"subscriptionType\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"timeoutMs\"), 500);\n        Assert.assertEquals(goInstanceConfig.get(\"subscriptionName\"), \"go-func-sub\");\n        Assert.assertEquals(goInstanceConfig.get(\"name\"), \"go-func\");\n        Assert.assertEquals(goInstanceConfig.get(\"expectedHealthCheckInterval\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"deadLetterTopic\"), \"go-func-deadletter\");\n        Assert.assertEquals(goInstanceConfig.get(\"userConfig\"), userConfig.toString());\n        Assert.assertEquals(goInstanceConfig.get(\"metricsPort\"), 60000);\n        Assert.assertEquals(goInstanceConfig.get(\"clientAuthenticationPlugin\"), \"org.apache.pulsar.client.impl.auth.AuthenticationToken\");\n        Assert.assertEquals(goInstanceConfig.get(\"clientAuthenticationParameters\"), \"file:///secret/token.jwt\");\n        Assert.assertEquals(goInstanceConfig.get(\"tlsTrustCertsFilePath\"), \"/secret/ca.cert.pem\");\n        Assert.assertEquals(goInstanceConfig.get(\"tlsHostnameVerificationEnable\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"tlsAllowInsecureConnection\"), false);\n    }\n",
    "test_tgt_code": "    @Test(dataProvider = \"k8sRuntime\")\n    public void getGoInstanceCmd(boolean k8sRuntime) throws IOException {\n        HashMap<String, String> goInstanceConfig;\n\n        InstanceConfig instanceConfig = new InstanceConfig();\n        instanceConfig.setClusterName(\"kluster\");\n        instanceConfig.setInstanceId(3000);\n        instanceConfig.setFunctionId(\"func-7734\");\n        instanceConfig.setFunctionVersion(\"1.0.0\");\n        instanceConfig.setMaxBufferedTuples(5);\n        instanceConfig.setPort(1337);\n        instanceConfig.setMetricsPort(60000);\n\n        AuthenticationConfig authConfig = AuthenticationConfig.builder()\n                .clientAuthenticationPlugin(\"org.apache.pulsar.client.impl.auth.AuthenticationToken\")\n                .clientAuthenticationParameters(\"file:///secret/token.jwt\")\n                .tlsTrustCertsFilePath(\"/secret/ca.cert.pem\")\n                .tlsHostnameVerificationEnable(true)\n                .tlsAllowInsecureConnection(false)\n                .build();\n\n        JSONObject userConfig = new JSONObject();\n        userConfig.put(\"word-of-the-day\", \"der Weltschmerz\");\n\n        JSONObject secretsMap = new JSONObject();\n        secretsMap.put(\"secret\", \"cake is a lie\");\n\n        Function.SourceSpec sources = Function.SourceSpec.newBuilder()\n                .setCleanupSubscription(true)\n                .setSubscriptionName(\"go-func-sub\")\n                .setTimeoutMs(500)\n                .putInputSpecs(\"go-func-input\", Function.ConsumerSpec.newBuilder().setIsRegexPattern(false).build())\n                .build();\n\n        Function.RetryDetails retryDetails = Function.RetryDetails.newBuilder()\n                .setDeadLetterTopic(\"go-func-deadletter\")\n                .setMaxMessageRetries(1)\n                .build();\n\n        Function.Resources resources = Function.Resources.newBuilder()\n                .setCpu(2)\n                .setDisk(1024)\n                .setRam(32)\n                .build();\n\n        Function.FunctionDetails functionDetails = Function.FunctionDetails.newBuilder()\n                .setAutoAck(true)\n                .setTenant(\"public\")\n                .setNamespace(\"default\")\n                .setName(\"go-func\")\n                .setLogTopic(\"go-func-log\")\n                .setProcessingGuarantees(Function.ProcessingGuarantees.ATLEAST_ONCE)\n                .setRuntime(Function.FunctionDetails.Runtime.GO)\n                .setSecretsMap(secretsMap.toJSONString())\n                .setParallelism(1)\n                .setSource(sources)\n                .setRetryDetails(retryDetails)\n                .setResources(resources)\n                .setUserConfig(userConfig.toJSONString())\n                .build();\n\n        instanceConfig.setFunctionDetails(functionDetails);\n        instanceConfig.setExposePulsarAdminClientEnabled(true);\n\n        List<String> commands = RuntimeUtils.getGoInstanceCmd(instanceConfig, authConfig, \"config\", \"pulsar://localhost:6650\", \"bk://localhost:4181\",  \"http://localhost:8080\", k8sRuntime);\n        if (k8sRuntime) {\n            goInstanceConfig = new ObjectMapper().readValue(commands.get(2).replaceAll(\"^\\'|\\'$\", \"\"), HashMap.class);\n        } else {\n            goInstanceConfig = new ObjectMapper().readValue(commands.get(2), HashMap.class);\n        }\n        Assert.assertEquals(commands.toArray().length, 3);\n        Assert.assertEquals(commands.get(0), \"config\");\n        Assert.assertEquals(commands.get(1), \"-instance-conf\");\n        Assert.assertEquals(goInstanceConfig.get(\"maxBufTuples\"), 5);\n        Assert.assertEquals(goInstanceConfig.get(\"maxMessageRetries\"), 1);\n        Assert.assertEquals(goInstanceConfig.get(\"killAfterIdleMs\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"parallelism\"), 1);\n        Assert.assertEquals(goInstanceConfig.get(\"className\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"sourceSpecsTopic\"), \"go-func-input\");\n        Assert.assertEquals(goInstanceConfig.get(\"secretsMap\"), secretsMap.toString());\n        Assert.assertEquals(goInstanceConfig.get(\"sourceSchemaType\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"sinkSpecsTopic\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"clusterName\"), \"kluster\");\n        Assert.assertEquals(goInstanceConfig.get(\"nameSpace\"), \"default\");\n        Assert.assertEquals(goInstanceConfig.get(\"receiverQueueSize\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"tenant\"), \"public\");\n        Assert.assertEquals(goInstanceConfig.get(\"ram\"), 32);\n        Assert.assertEquals(goInstanceConfig.get(\"logTopic\"), \"go-func-log\");\n        Assert.assertEquals(goInstanceConfig.get(\"processingGuarantees\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"autoAck\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"regexPatternSubscription\"), false);\n        Assert.assertEquals(goInstanceConfig.get(\"pulsarServiceURL\"), \"pulsar://localhost:6650\");\n        Assert.assertEquals(goInstanceConfig.get(\"stateStorageServiceUrl\"), \"bk://localhost:4181\");\n        Assert.assertEquals(goInstanceConfig.get(\"pulsarWebServiceUrl\"), \"http://localhost:8080\");\n        Assert.assertEquals(goInstanceConfig.get(\"runtime\"), 3);\n        Assert.assertEquals(goInstanceConfig.get(\"cpu\"), 2.0);\n        Assert.assertEquals(goInstanceConfig.get(\"funcID\"), \"func-7734\");\n        Assert.assertEquals(goInstanceConfig.get(\"funcVersion\"), \"1.0.0\");\n        Assert.assertEquals(goInstanceConfig.get(\"disk\"), 1024);\n        Assert.assertEquals(goInstanceConfig.get(\"instanceID\"), 3000);\n        Assert.assertEquals(goInstanceConfig.get(\"cleanupSubscription\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"port\"), 1337);\n        Assert.assertEquals(goInstanceConfig.get(\"subscriptionType\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"timeoutMs\"), 500);\n        Assert.assertEquals(goInstanceConfig.get(\"subscriptionName\"), \"go-func-sub\");\n        Assert.assertEquals(goInstanceConfig.get(\"name\"), \"go-func\");\n        Assert.assertEquals(goInstanceConfig.get(\"expectedHealthCheckInterval\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"deadLetterTopic\"), \"go-func-deadletter\");\n        Assert.assertEquals(goInstanceConfig.get(\"userConfig\"), userConfig.toString());\n        Assert.assertEquals(goInstanceConfig.get(\"metricsPort\"), 60000);\n        Assert.assertEquals(goInstanceConfig.get(\"clientAuthenticationPlugin\"), \"org.apache.pulsar.client.impl.auth.AuthenticationToken\");\n        Assert.assertEquals(goInstanceConfig.get(\"clientAuthenticationParameters\"), \"file:///secret/token.jwt\");\n        Assert.assertEquals(goInstanceConfig.get(\"tlsTrustCertsFilePath\"), \"/secret/ca.cert.pem\");\n        Assert.assertEquals(goInstanceConfig.get(\"tlsHostnameVerificationEnable\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"tlsAllowInsecureConnection\"), false);\n    }\n",
    "focal_path_src": [
      "pulsar-functions/runtime/src/main/java/org/apache/pulsar/functions/runtime/RuntimeUtils.java#getGoInstanceCmd"
    ],
    "focal_path_tgt": [
      "pulsar-functions/runtime/src/main/java/org/apache/pulsar/functions/runtime/RuntimeUtils.java#getGoInstanceCmd"
    ],
    "focal_src": [
      "    /**\n     * Different from python and java function, Go function uploads a complete executable file(including:\n     * instance file + user code file). Its parameter list is provided to the broker in the form of a yaml file,\n     * the advantage of this approach is that backward compatibility is guaranteed.\n     *\n     * In Java and Python the instance is managed by broker (or function worker) so the changes in command line\n     * is under control; but in Go the instance is compiled with the user function, so pulsar doesn't have the\n     * control what instance is used in the function. Hence in order to support BC for go function, we can't\n     * dynamically add more commandline arguments. Using an instance config to pass the parameters from function\n     * worker to go instance is the best way for maintaining the BC.\n     * <p>\n     * When we run the go function, we only need to specify the location of the go-function file and the yaml file.\n     * The content of the yaml file will be automatically generated according to the content provided by instanceConfig.\n     */\n\n    public static List<String> getGoInstanceCmd(InstanceConfig instanceConfig,\n                                                AuthenticationConfig authConfig,\n                                                String originalCodeFileName,\n                                                String pulsarServiceUrl,\n                                                boolean k8sRuntime) throws IOException {\n        final List<String> args = new LinkedList<>();\n        GoInstanceConfig goInstanceConfig = new GoInstanceConfig();\n\n        if (instanceConfig.getClusterName() != null) {\n            goInstanceConfig.setClusterName(instanceConfig.getClusterName());\n        }\n\n        if (instanceConfig.getInstanceId() != 0) {\n            goInstanceConfig.setInstanceID(instanceConfig.getInstanceId());\n        }\n\n        if (instanceConfig.getFunctionId() != null) {\n            goInstanceConfig.setFuncID(instanceConfig.getFunctionId());\n        }\n\n        if (instanceConfig.getFunctionVersion() != null) {\n            goInstanceConfig.setFuncVersion(instanceConfig.getFunctionVersion());\n        }\n\n        if (instanceConfig.getFunctionDetails().getAutoAck()) {\n            goInstanceConfig.setAutoAck(instanceConfig.getFunctionDetails().getAutoAck());\n        }\n\n        if (instanceConfig.getFunctionDetails().getTenant() != null) {\n            goInstanceConfig.setTenant(instanceConfig.getFunctionDetails().getTenant());\n        }\n\n        if (instanceConfig.getFunctionDetails().getNamespace() != null) {\n            goInstanceConfig.setNameSpace(instanceConfig.getFunctionDetails().getNamespace());\n        }\n\n        if (instanceConfig.getFunctionDetails().getName() != null) {\n            goInstanceConfig.setName(instanceConfig.getFunctionDetails().getName());\n        }\n\n        if (instanceConfig.getFunctionDetails().getLogTopic() != null) {\n            goInstanceConfig.setLogTopic(instanceConfig.getFunctionDetails().getLogTopic());\n        }\n        if (instanceConfig.getFunctionDetails().getProcessingGuarantees() != null) {\n            goInstanceConfig\n                    .setProcessingGuarantees(instanceConfig.getFunctionDetails().getProcessingGuaranteesValue());\n        }\n        if (instanceConfig.getFunctionDetails().getRuntime() != null) {\n            goInstanceConfig.setRuntime(instanceConfig.getFunctionDetails().getRuntimeValue());\n        }\n        if (instanceConfig.getFunctionDetails().getSecretsMap() != null) {\n            goInstanceConfig.setSecretsMap(instanceConfig.getFunctionDetails().getSecretsMap());\n        }\n        if (instanceConfig.getFunctionDetails().getUserConfig() != null) {\n            goInstanceConfig.setUserConfig(instanceConfig.getFunctionDetails().getUserConfig());\n        }\n        if (instanceConfig.getFunctionDetails().getParallelism() != 0) {\n            goInstanceConfig.setParallelism(instanceConfig.getFunctionDetails().getParallelism());\n        }\n\n        if (authConfig != null) {\n            if (isNotBlank(authConfig.getClientAuthenticationPlugin())\n                    && isNotBlank(authConfig.getClientAuthenticationParameters())) {\n                goInstanceConfig.setClientAuthenticationPlugin(authConfig.getClientAuthenticationPlugin());\n                goInstanceConfig.setClientAuthenticationParameters(authConfig.getClientAuthenticationParameters());\n            }\n            goInstanceConfig.setTlsAllowInsecureConnection(\n                    authConfig.isTlsAllowInsecureConnection());\n            goInstanceConfig.setTlsHostnameVerificationEnable(\n                    authConfig.isTlsHostnameVerificationEnable());\n            if (isNotBlank(authConfig.getTlsTrustCertsFilePath())){\n                goInstanceConfig.setTlsTrustCertsFilePath(\n                        authConfig.getTlsTrustCertsFilePath());\n            }\n\n        }\n\n        if (instanceConfig.getMaxBufferedTuples() != 0) {\n            goInstanceConfig.setMaxBufTuples(instanceConfig.getMaxBufferedTuples());\n        }\n\n        if (pulsarServiceUrl != null) {\n            goInstanceConfig.setPulsarServiceURL(pulsarServiceUrl);\n        }\n        if (instanceConfig.getFunctionDetails().getSource().getCleanupSubscription()) {\n            goInstanceConfig\n                    .setCleanupSubscription(instanceConfig.getFunctionDetails().getSource().getCleanupSubscription());\n        }\n        if (instanceConfig.getFunctionDetails().getSource().getSubscriptionName() != null) {\n            goInstanceConfig.setSubscriptionName(instanceConfig.getFunctionDetails().getSource().getSubscriptionName());\n        }\n        goInstanceConfig.setSubscriptionPosition(\n                instanceConfig.getFunctionDetails().getSource().getSubscriptionPosition().getNumber());\n\n        if (instanceConfig.getFunctionDetails().getSource().getInputSpecsMap() != null) {\n            Map<String, String> sourceInputSpecs = new HashMap<>();\n            for (Map.Entry<String, Function.ConsumerSpec> entry :\n                    instanceConfig.getFunctionDetails().getSource().getInputSpecsMap().entrySet()) {\n                String topic = entry.getKey();\n                Function.ConsumerSpec spec = entry.getValue();\n                sourceInputSpecs.put(topic, JsonFormat.printer().omittingInsignificantWhitespace().print(spec));\n                goInstanceConfig.setSourceSpecsTopic(topic);\n            }\n            goInstanceConfig.setSourceInputSpecs(sourceInputSpecs);\n        }\n\n        if (instanceConfig.getFunctionDetails().getSource().getTimeoutMs() != 0) {\n            goInstanceConfig.setTimeoutMs(instanceConfig.getFunctionDetails().getSource().getTimeoutMs());\n        }\n\n        if (instanceConfig.getFunctionDetails().getSink().getTopic() != null) {\n            goInstanceConfig.setSinkSpecsTopic(instanceConfig.getFunctionDetails().getSink().getTopic());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getCpu() != 0) {\n            goInstanceConfig.setCpu(instanceConfig.getFunctionDetails().getResources().getCpu());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getRam() != 0) {\n            goInstanceConfig.setRam(instanceConfig.getFunctionDetails().getResources().getRam());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getDisk() != 0) {\n            goInstanceConfig.setDisk(instanceConfig.getFunctionDetails().getResources().getDisk());\n        }\n\n        if (instanceConfig.getFunctionDetails().getRetryDetails().getDeadLetterTopic() != null) {\n            goInstanceConfig\n                    .setDeadLetterTopic(instanceConfig.getFunctionDetails().getRetryDetails().getDeadLetterTopic());\n        }\n\n        if (instanceConfig.getFunctionDetails().getRetryDetails().getMaxMessageRetries() != 0) {\n            goInstanceConfig\n                    .setMaxMessageRetries(instanceConfig.getFunctionDetails().getRetryDetails().getMaxMessageRetries());\n        }\n\n        if (instanceConfig.hasValidMetricsPort()) {\n            goInstanceConfig.setMetricsPort(instanceConfig.getMetricsPort());\n        }\n\n        goInstanceConfig.setKillAfterIdleMs(0);\n        goInstanceConfig.setPort(instanceConfig.getPort());\n\n        // Parse the contents of goInstanceConfig into json form string\n        ObjectMapper objectMapper = ObjectMapperFactory.getMapper().getObjectMapper();\n        String configContent = objectMapper.writeValueAsString(goInstanceConfig);\n\n        args.add(originalCodeFileName);\n        args.add(\"-instance-conf\");\n        if (k8sRuntime) {\n            args.add(\"'\" + configContent + \"'\");\n        } else {\n            args.add(configContent);\n        }\n        return args;\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * Different from python and java function, Go function uploads a complete executable file(including:\n     * instance file + user code file). Its parameter list is provided to the broker in the form of a yaml file,\n     * the advantage of this approach is that backward compatibility is guaranteed.\n     *\n     * In Java and Python the instance is managed by broker (or function worker) so the changes in command line\n     * is under control; but in Go the instance is compiled with the user function, so pulsar doesn't have the\n     * control what instance is used in the function. Hence in order to support BC for go function, we can't\n     * dynamically add more commandline arguments. Using an instance config to pass the parameters from function\n     * worker to go instance is the best way for maintaining the BC.\n     * <p>\n     * When we run the go function, we only need to specify the location of the go-function file and the yaml file.\n     * The content of the yaml file will be automatically generated according to the content provided by instanceConfig.\n     */\n\n    public static List<String> getGoInstanceCmd(InstanceConfig instanceConfig,\n                                                AuthenticationConfig authConfig,\n                                                String originalCodeFileName,\n                                                String pulsarServiceUrl,\n                                                String stateStorageServiceUrl,\n                                                String pulsarWebServiceUrl,\n                                                boolean k8sRuntime) throws IOException {\n        final List<String> args = new LinkedList<>();\n        GoInstanceConfig goInstanceConfig = new GoInstanceConfig();\n\n        if (instanceConfig.getClusterName() != null) {\n            goInstanceConfig.setClusterName(instanceConfig.getClusterName());\n        }\n\n        if (null != stateStorageServiceUrl) {\n            goInstanceConfig.setStateStorageServiceUrl(stateStorageServiceUrl);\n        }\n\n        if (instanceConfig.isExposePulsarAdminClientEnabled() && StringUtils.isNotBlank(pulsarWebServiceUrl)) {\n            goInstanceConfig.setPulsarWebServiceUrl(pulsarWebServiceUrl);\n        }\n\n        if (instanceConfig.getInstanceId() != 0) {\n            goInstanceConfig.setInstanceID(instanceConfig.getInstanceId());\n        }\n\n        if (instanceConfig.getFunctionId() != null) {\n            goInstanceConfig.setFuncID(instanceConfig.getFunctionId());\n        }\n\n        if (instanceConfig.getFunctionVersion() != null) {\n            goInstanceConfig.setFuncVersion(instanceConfig.getFunctionVersion());\n        }\n\n        if (instanceConfig.getFunctionDetails().getAutoAck()) {\n            goInstanceConfig.setAutoAck(instanceConfig.getFunctionDetails().getAutoAck());\n        }\n\n        if (instanceConfig.getFunctionDetails().getTenant() != null) {\n            goInstanceConfig.setTenant(instanceConfig.getFunctionDetails().getTenant());\n        }\n\n        if (instanceConfig.getFunctionDetails().getNamespace() != null) {\n            goInstanceConfig.setNameSpace(instanceConfig.getFunctionDetails().getNamespace());\n        }\n\n        if (instanceConfig.getFunctionDetails().getName() != null) {\n            goInstanceConfig.setName(instanceConfig.getFunctionDetails().getName());\n        }\n\n        if (instanceConfig.getFunctionDetails().getLogTopic() != null) {\n            goInstanceConfig.setLogTopic(instanceConfig.getFunctionDetails().getLogTopic());\n        }\n        if (instanceConfig.getFunctionDetails().getProcessingGuarantees() != null) {\n            goInstanceConfig\n                    .setProcessingGuarantees(instanceConfig.getFunctionDetails().getProcessingGuaranteesValue());\n        }\n        if (instanceConfig.getFunctionDetails().getRuntime() != null) {\n            goInstanceConfig.setRuntime(instanceConfig.getFunctionDetails().getRuntimeValue());\n        }\n        if (instanceConfig.getFunctionDetails().getSecretsMap() != null) {\n            goInstanceConfig.setSecretsMap(instanceConfig.getFunctionDetails().getSecretsMap());\n        }\n        if (instanceConfig.getFunctionDetails().getUserConfig() != null) {\n            goInstanceConfig.setUserConfig(instanceConfig.getFunctionDetails().getUserConfig());\n        }\n        if (instanceConfig.getFunctionDetails().getParallelism() != 0) {\n            goInstanceConfig.setParallelism(instanceConfig.getFunctionDetails().getParallelism());\n        }\n\n        if (authConfig != null) {\n            if (isNotBlank(authConfig.getClientAuthenticationPlugin())\n                    && isNotBlank(authConfig.getClientAuthenticationParameters())) {\n                goInstanceConfig.setClientAuthenticationPlugin(authConfig.getClientAuthenticationPlugin());\n                goInstanceConfig.setClientAuthenticationParameters(authConfig.getClientAuthenticationParameters());\n            }\n            goInstanceConfig.setTlsAllowInsecureConnection(\n                    authConfig.isTlsAllowInsecureConnection());\n            goInstanceConfig.setTlsHostnameVerificationEnable(\n                    authConfig.isTlsHostnameVerificationEnable());\n            if (isNotBlank(authConfig.getTlsTrustCertsFilePath())){\n                goInstanceConfig.setTlsTrustCertsFilePath(\n                        authConfig.getTlsTrustCertsFilePath());\n            }\n\n        }\n\n        if (instanceConfig.getMaxBufferedTuples() != 0) {\n            goInstanceConfig.setMaxBufTuples(instanceConfig.getMaxBufferedTuples());\n        }\n\n        if (pulsarServiceUrl != null) {\n            goInstanceConfig.setPulsarServiceURL(pulsarServiceUrl);\n        }\n        if (instanceConfig.getFunctionDetails().getSource().getCleanupSubscription()) {\n            goInstanceConfig\n                    .setCleanupSubscription(instanceConfig.getFunctionDetails().getSource().getCleanupSubscription());\n        }\n        if (instanceConfig.getFunctionDetails().getSource().getSubscriptionName() != null) {\n            goInstanceConfig.setSubscriptionName(instanceConfig.getFunctionDetails().getSource().getSubscriptionName());\n        }\n        goInstanceConfig.setSubscriptionPosition(\n                instanceConfig.getFunctionDetails().getSource().getSubscriptionPosition().getNumber());\n\n        if (instanceConfig.getFunctionDetails().getSource().getInputSpecsMap() != null) {\n            Map<String, String> sourceInputSpecs = new HashMap<>();\n            for (Map.Entry<String, Function.ConsumerSpec> entry :\n                    instanceConfig.getFunctionDetails().getSource().getInputSpecsMap().entrySet()) {\n                String topic = entry.getKey();\n                Function.ConsumerSpec spec = entry.getValue();\n                sourceInputSpecs.put(topic, JsonFormat.printer().omittingInsignificantWhitespace().print(spec));\n                goInstanceConfig.setSourceSpecsTopic(topic);\n            }\n            goInstanceConfig.setSourceInputSpecs(sourceInputSpecs);\n        }\n\n        if (instanceConfig.getFunctionDetails().getSource().getTimeoutMs() != 0) {\n            goInstanceConfig.setTimeoutMs(instanceConfig.getFunctionDetails().getSource().getTimeoutMs());\n        }\n\n        if (instanceConfig.getFunctionDetails().getSink().getTopic() != null) {\n            goInstanceConfig.setSinkSpecsTopic(instanceConfig.getFunctionDetails().getSink().getTopic());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getCpu() != 0) {\n            goInstanceConfig.setCpu(instanceConfig.getFunctionDetails().getResources().getCpu());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getRam() != 0) {\n            goInstanceConfig.setRam(instanceConfig.getFunctionDetails().getResources().getRam());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getDisk() != 0) {\n            goInstanceConfig.setDisk(instanceConfig.getFunctionDetails().getResources().getDisk());\n        }\n\n        if (instanceConfig.getFunctionDetails().getRetryDetails().getDeadLetterTopic() != null) {\n            goInstanceConfig\n                    .setDeadLetterTopic(instanceConfig.getFunctionDetails().getRetryDetails().getDeadLetterTopic());\n        }\n\n        if (instanceConfig.getFunctionDetails().getRetryDetails().getMaxMessageRetries() != 0) {\n            goInstanceConfig\n                    .setMaxMessageRetries(instanceConfig.getFunctionDetails().getRetryDetails().getMaxMessageRetries());\n        }\n\n        if (instanceConfig.hasValidMetricsPort()) {\n            goInstanceConfig.setMetricsPort(instanceConfig.getMetricsPort());\n        }\n\n        goInstanceConfig.setKillAfterIdleMs(0);\n        goInstanceConfig.setPort(instanceConfig.getPort());\n\n        // Parse the contents of goInstanceConfig into json form string\n        ObjectMapper objectMapper = ObjectMapperFactory.getMapper().getObjectMapper();\n        String configContent = objectMapper.writeValueAsString(goInstanceConfig);\n\n        args.add(originalCodeFileName);\n        args.add(\"-instance-conf\");\n        if (k8sRuntime) {\n            args.add(\"'\" + configContent + \"'\");\n        } else {\n            args.add(configContent);\n        }\n        return args;\n    }\n"
    ],
    "test_id": 3,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test(dataProvider = \"k8sRuntime\")\npublic void getGoInstanceCmd(boolean k8sRuntime) throws IOException {\n    HashMap<String, String> goInstanceConfig;\n\n    InstanceConfig instanceConfig = new InstanceConfig();\n    instanceConfig.setClusterName(\"kluster\");\n    instanceConfig.setInstanceId(3000);\n    instanceConfig.setFunctionId(\"func-7734\");\n    instanceConfig.setFunctionVersion(\"1.0.0\");\n    instanceConfig.setMaxBufferedTuples(5);\n    instanceConfig.setPort(1337);\n    instanceConfig.setMetricsPort(60000);\n\n    AuthenticationConfig authConfig = AuthenticationConfig.builder()\n            .clientAuthenticationPlugin(\"org.apache.pulsar.client.impl.auth.AuthenticationToken\")\n            .clientAuthenticationParameters(\"file:///secret/token.jwt\")\n            .tlsTrustCertsFilePath(\"/secret/ca.cert.pem\")\n            .tlsHostnameVerificationEnable(true)\n            .tlsAllowInsecureConnection(false)\n            .build();\n\n    JSONObject userConfig = new JSONObject();\n    userConfig.put(\"word-of-the-day\", \"der Weltschmerz\");\n\n    JSONObject secretsMap = new JSONObject();\n    secretsMap.put(\"secret\", \"cake is a lie\");\n\n    Function.SourceSpec sources = Function.SourceSpec.newBuilder()\n            .setCleanupSubscription(true)\n            .setSubscriptionName(\"go-func-sub\")\n            .setTimeoutMs(500)\n            .putInputSpecs(\"go-func-input\", Function.ConsumerSpec.newBuilder().setIsRegexPattern(false).build())\n            .build();\n\n    Function.RetryDetails retryDetails = Function.RetryDetails.newBuilder()\n            .setDeadLetterTopic(\"go-func-deadletter\")\n            .setMaxMessageRetries(1)\n            .build();\n\n    Function.Resources resources = Function.Resources.newBuilder()\n            .setCpu(2)\n            .setDisk(1024)\n            .setRam(32)\n            .build();\n\n    Function.FunctionDetails functionDetails = Function.FunctionDetails.newBuilder()\n            .setAutoAck(true)\n            .setTenant(\"public\")\n            .setNamespace(\"default\")\n            .setName(\"go-func\")\n            .setLogTopic(\"go-func-log\")\n            .setProcessingGuarantees(Function.ProcessingGuarantees.ATLEAST_ONCE)\n            .setRuntime(Function.FunctionDetails.Runtime.GO)\n            .setSecretsMap(secretsMap.toJSONString())\n            .setParallelism(1)\n            .setSource(sources)\n            .setRetryDetails(retryDetails)\n            .setResources(resources)\n            .setUserConfig(userConfig.toJSONString())\n            .build();\n\n    instanceConfig.setFunctionDetails(functionDetails);\n\n    List<String> commands = RuntimeUtils.getGoInstanceCmd(instanceConfig, authConfig,\"config\", \"pulsar://localhost:6650\", k8sRuntime);\n    if (k8sRuntime) {\n        goInstanceConfig = new ObjectMapper().readValue(commands.get(2).replaceAll(\"^\\'|\\'$\", \"\"), HashMap.class);\n    } else {\n        goInstanceConfig = new ObjectMapper().readValue(commands.get(2), HashMap.class);\n    }\n    Assert.assertEquals(commands.toArray().length, 3);\n    Assert.assertEquals(commands.get(0), \"config\");\n    Assert.assertEquals(commands.get(1), \"-instance-conf\");\n    Assert.assertEquals(goInstanceConfig.get(\"maxBufTuples\"), 5);\n    Assert.assertEquals(goInstanceConfig.get(\"maxMessageRetries\"), 1);\n    Assert.assertEquals(goInstanceConfig.get(\"killAfterIdleMs\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"parallelism\"), 1);\n    Assert.assertEquals(goInstanceConfig.get(\"className\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"sourceSpecsTopic\"), \"go-func-input\");\n    Assert.assertEquals(goInstanceConfig.get(\"secretsMap\"), secretsMap.toString());\n    Assert.assertEquals(goInstanceConfig.get(\"sourceSchemaType\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"sinkSpecsTopic\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"clusterName\"), \"kluster\");\n    Assert.assertEquals(goInstanceConfig.get(\"nameSpace\"), \"default\");\n    Assert.assertEquals(goInstanceConfig.get(\"receiverQueueSize\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"tenant\"), \"public\");\n    Assert.assertEquals(goInstanceConfig.get(\"ram\"), 32);\n    Assert.assertEquals(goInstanceConfig.get(\"logTopic\"), \"go-func-log\");\n    Assert.assertEquals(goInstanceConfig.get(\"processingGuarantees\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"autoAck\"), true);\n    Assert.assertEquals(goInstanceConfig.get(\"regexPatternSubscription\"), false);\n    Assert.assertEquals(goInstanceConfig.get(\"pulsarServiceURL\"), \"pulsar://localhost:6650\");\n    Assert.assertEquals(goInstanceConfig.get(\"runtime\"), 3);\n    Assert.assertEquals(goInstanceConfig.get(\"cpu\"), 2.0);\n    Assert.assertEquals(goInstanceConfig.get(\"funcID\"), \"func-7734\");\n    Assert.assertEquals(goInstanceConfig.get(\"funcVersion\"), \"1.0.0\");\n    Assert.assertEquals(goInstanceConfig.get(\"disk\"), 1024);\n    Assert.assertEquals(goInstanceConfig.get(\"instanceID\"), 3000);\n    Assert.assertEquals(goInstanceConfig.get(\"cleanupSubscription\"), true);\n    Assert.assertEquals(goInstanceConfig.get(\"port\"), 1337);\n    Assert.assertEquals(goInstanceConfig.get(\"subscriptionType\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"timeoutMs\"), 500);\n    Assert.assertEquals(goInstanceConfig.get(\"subscriptionName\"), \"go-func-sub\");\n    Assert.assertEquals(goInstanceConfig.get(\"name\"), \"go-func\");\n    Assert.assertEquals(goInstanceConfig.get(\"expectedHealthCheckInterval\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"deadLetterTopic\"), \"go-func-deadletter\");\n    Assert.assertEquals(goInstanceConfig.get(\"userConfig\"), userConfig.toString());\n    Assert.assertEquals(goInstanceConfig.get(\"metricsPort\"), 60000);\n    Assert.assertEquals(goInstanceConfig.get(\"clientAuthenticationPlugin\"), \"org.apache.pulsar.client.impl.auth.AuthenticationToken\");\n    Assert.assertEquals(goInstanceConfig.get(\"clientAuthenticationParameters\"), \"file:///secret/token.jwt\");\n    Assert.assertEquals(goInstanceConfig.get(\"tlsTrustCertsFilePath\"), \"/secret/ca.cert.pem\");\n    Assert.assertEquals(goInstanceConfig.get(\"tlsHostnameVerificationEnable\"), true);\n    Assert.assertEquals(goInstanceConfig.get(\"tlsAllowInsecureConnection\"), false);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test(dataProvider = \"k8sRuntime\")\npublic void getGoInstanceCmd(boolean k8sRuntime) throws IOException {\n    HashMap<String, String> goInstanceConfig;\n\n    InstanceConfig instanceConfig = new InstanceConfig();\n    instanceConfig.setClusterName(\"kluster\");\n    instanceConfig.setInstanceId(3000);\n    instanceConfig.setFunctionId(\"func-7734\");\n    instanceConfig.setFunctionVersion(\"1.0.0\");\n    instanceConfig.setMaxBufferedTuples(5);\n    instanceConfig.setPort(1337);\n    instanceConfig.setMetricsPort(60000);\n\n    AuthenticationConfig authConfig = AuthenticationConfig.builder()\n            .clientAuthenticationPlugin(\"org.apache.pulsar.client.impl.auth.AuthenticationToken\")\n            .clientAuthenticationParameters(\"file:///secret/token.jwt\")\n            .tlsTrustCertsFilePath(\"/secret/ca.cert.pem\")\n            .tlsHostnameVerificationEnable(true)\n            .tlsAllowInsecureConnection(false)\n            .build();\n\n    JSONObject userConfig = new JSONObject();\n    userConfig.put(\"word-of-the-day\", \"der Weltschmerz\");\n\n    JSONObject secretsMap = new JSONObject();\n    secretsMap.put(\"secret\", \"cake is a lie\");\n\n    Function.SourceSpec sources = Function.SourceSpec.newBuilder()\n            .setCleanupSubscription(true)\n            .setSubscriptionName(\"go-func-sub\")\n            .setTimeoutMs(500)\n            .putInputSpecs(\"go-func-input\", Function.ConsumerSpec.newBuilder().setIsRegexPattern(false).build())\n            .build();\n\n    Function.RetryDetails retryDetails = Function.RetryDetails.newBuilder()\n            .setDeadLetterTopic(\"go-func-deadletter\")\n            .setMaxMessageRetries(1)\n            .build();\n\n    Function.Resources resources = Function.Resources.newBuilder()\n            .setCpu(2)\n            .setDisk(1024)\n            .setRam(32)\n            .build();\n\n    Function.FunctionDetails functionDetails = Function.FunctionDetails.newBuilder()\n            .setAutoAck(true)\n            .setTenant(\"public\")\n            .setNamespace(\"default\")\n            .setName(\"go-func\")\n            .setLogTopic(\"go-func-log\")\n            .setProcessingGuarantees(Function.ProcessingGuarantees.ATLEAST_ONCE)\n            .setRuntime(Function.FunctionDetails.Runtime.GO)\n            .setSecretsMap(secretsMap.toJSONString())\n            .setParallelism(1)\n            .setSource(sources)\n            .setRetryDetails(retryDetails)\n            .setResources(resources)\n            .setUserConfig(userConfig.toJSONString())\n            .build();\n\n    instanceConfig.setFunctionDetails(functionDetails);\n\n    List<String> commands = RuntimeUtils.getGoInstanceCmd(instanceConfig, authConfig,\"config\", \"pulsar://localhost:6650\", k8sRuntime);\n    if (k8sRuntime) {\n        goInstanceConfig = new ObjectMapper().readValue(commands.get(2).replaceAll(\"^\\'|\\'$\", \"\"), HashMap.class);\n    } else {\n        goInstanceConfig = new ObjectMapper().readValue(commands.get(2), HashMap.class);\n    }\n    Assert.assertEquals(commands.toArray().length, 3);\n    Assert.assertEquals(commands.get(0), \"config\");\n    Assert.assertEquals(commands.get(1), \"-instance-conf\");\n    Assert.assertEquals(goInstanceConfig.get(\"maxBufTuples\"), 5);\n    Assert.assertEquals(goInstanceConfig.get(\"maxMessageRetries\"), 1);\n    Assert.assertEquals(goInstanceConfig.get(\"killAfterIdleMs\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"parallelism\"), 1);\n    Assert.assertEquals(goInstanceConfig.get(\"className\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"sourceSpecsTopic\"), \"go-func-input\");\n    Assert.assertEquals(goInstanceConfig.get(\"secretsMap\"), secretsMap.toString());\n    Assert.assertEquals(goInstanceConfig.get(\"sourceSchemaType\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"sinkSpecsTopic\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"clusterName\"), \"kluster\");\n    Assert.assertEquals(goInstanceConfig.get(\"nameSpace\"), \"default\");\n    Assert.assertEquals(goInstanceConfig.get(\"receiverQueueSize\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"tenant\"), \"public\");\n    Assert.assertEquals(goInstanceConfig.get(\"ram\"), 32);\n    Assert.assertEquals(goInstanceConfig.get(\"logTopic\"), \"go-func-log\");\n    Assert.assertEquals(goInstanceConfig.get(\"processingGuarantees\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"autoAck\"), true);\n    Assert.assertEquals(goInstanceConfig.get(\"regexPatternSubscription\"), false);\n    Assert.assertEquals(goInstanceConfig.get(\"pulsarServiceURL\"), \"pulsar://localhost:6650\");\n    Assert.assertEquals(goInstanceConfig.get(\"runtime\"), 3);\n    Assert.assertEquals(goInstanceConfig.get(\"cpu\"), 2.0);\n    Assert.assertEquals(goInstanceConfig.get(\"funcID\"), \"func-7734\");\n    Assert.assertEquals(goInstanceConfig.get(\"funcVersion\"), \"1.0.0\");\n    Assert.assertEquals(goInstanceConfig.get(\"disk\"), 1024);\n    Assert.assertEquals(goInstanceConfig.get(\"instanceID\"), 3000);\n    Assert.assertEquals(goInstanceConfig.get(\"cleanupSubscription\"), true);\n    Assert.assertEquals(goInstanceConfig.get(\"port\"), 1337);\n    Assert.assertEquals(goInstanceConfig.get(\"subscriptionType\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"timeoutMs\"), 500);\n    Assert.assertEquals(goInstanceConfig.get(\"subscriptionName\"), \"go-func-sub\");\n    Assert.assertEquals(goInstanceConfig.get(\"name\"), \"go-func\");\n    Assert.assertEquals(goInstanceConfig.get(\"expectedHealthCheckInterval\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"deadLetterTopic\"), \"go-func-deadletter\");\n    Assert.assertEquals(goInstanceConfig.get(\"userConfig\"), userConfig.toString());\n    Assert.assertEquals(goInstanceConfig.get(\"metricsPort\"), 60000);\n    Assert.assertEquals(goInstanceConfig.get(\"clientAuthenticationPlugin\"), \"org.apache.pulsar.client.impl.auth.AuthenticationToken\");\n    Assert.assertEquals(goInstanceConfig.get(\"clientAuthenticationParameters\"), \"file:///secret/token.jwt\");\n    Assert.assertEquals(goInstanceConfig.get(\"tlsTrustCertsFilePath\"), \"/secret/ca.cert.pem\");\n    Assert.assertEquals(goInstanceConfig.get(\"tlsHostnameVerificationEnable\"), true);\n    Assert.assertEquals(goInstanceConfig.get(\"tlsAllowInsecureConnection\"), false);\n}\n"
    ]
  },
  "4": {
    "commit_src": "ceed19cf3b8536a8c9059bfbcb29ef972841b412",
    "commit_tgt": "8b3c085e9d26605cca544068e8611d72e7012468",
    "changed_tests": [
      "pulsar-functions/runtime/src/test/java/org/apache/pulsar/functions/runtime/RuntimeUtilsTest.java"
    ],
    "refer_PR": "apache_pulsar-20468",
    "test_src": ".org.apache.pulsar.functions.runtime.RuntimeUtilsTest#getGoInstanceCmd",
    "test_tgt": [
      ".org.apache.pulsar.functions.runtime.RuntimeUtilsTest#getGoInstanceCmd"
    ],
    "test_src_code": "    @Test(dataProvider = \"k8sRuntime\")\n    public void getGoInstanceCmd(boolean k8sRuntime) throws IOException {\n        HashMap<String, String> goInstanceConfig;\n\n        InstanceConfig instanceConfig = new InstanceConfig();\n        instanceConfig.setClusterName(\"kluster\");\n        instanceConfig.setInstanceId(3000);\n        instanceConfig.setFunctionId(\"func-7734\");\n        instanceConfig.setFunctionVersion(\"1.0.0\");\n        instanceConfig.setMaxBufferedTuples(5);\n        instanceConfig.setPort(1337);\n        instanceConfig.setMetricsPort(60000);\n\n\n        JSONObject userConfig = new JSONObject();\n        userConfig.put(\"word-of-the-day\", \"der Weltschmerz\");\n\n        JSONObject secretsMap = new JSONObject();\n        secretsMap.put(\"secret\", \"cake is a lie\");\n\n        Function.SourceSpec sources = Function.SourceSpec.newBuilder()\n                .setCleanupSubscription(true)\n                .setSubscriptionName(\"go-func-sub\")\n                .setTimeoutMs(500)\n                .putInputSpecs(\"go-func-input\", Function.ConsumerSpec.newBuilder().setIsRegexPattern(false).build())\n                .build();\n\n        Function.RetryDetails retryDetails = Function.RetryDetails.newBuilder()\n                .setDeadLetterTopic(\"go-func-deadletter\")\n                .setMaxMessageRetries(1)\n                .build();\n\n        Function.Resources resources = Function.Resources.newBuilder()\n                .setCpu(2)\n                .setDisk(1024)\n                .setRam(32)\n                .build();\n\n        Function.FunctionDetails functionDetails = Function.FunctionDetails.newBuilder()\n                .setAutoAck(true)\n                .setTenant(\"public\")\n                .setNamespace(\"default\")\n                .setName(\"go-func\")\n                .setLogTopic(\"go-func-log\")\n                .setProcessingGuarantees(Function.ProcessingGuarantees.ATLEAST_ONCE)\n                .setRuntime(Function.FunctionDetails.Runtime.GO)\n                .setSecretsMap(secretsMap.toJSONString())\n                .setParallelism(1)\n                .setSource(sources)\n                .setRetryDetails(retryDetails)\n                .setResources(resources)\n                .setUserConfig(userConfig.toJSONString())\n                .build();\n\n        instanceConfig.setFunctionDetails(functionDetails);\n\n        List<String> commands = RuntimeUtils.getGoInstanceCmd(instanceConfig, \"config\", \"pulsar://localhost:6650\", k8sRuntime);\n        if (k8sRuntime) {\n            goInstanceConfig = new ObjectMapper().readValue(commands.get(2).replaceAll(\"^\\'|\\'$\", \"\"), HashMap.class);\n        } else {\n            goInstanceConfig = new ObjectMapper().readValue(commands.get(2), HashMap.class);\n        }\n        Assert.assertEquals(commands.toArray().length, 3);\n        Assert.assertEquals(commands.get(0), \"config\");\n        Assert.assertEquals(commands.get(1), \"-instance-conf\");\n        Assert.assertEquals(goInstanceConfig.get(\"maxBufTuples\"), 5);\n        Assert.assertEquals(goInstanceConfig.get(\"maxMessageRetries\"), 1);\n        Assert.assertEquals(goInstanceConfig.get(\"killAfterIdleMs\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"parallelism\"), 1);\n        Assert.assertEquals(goInstanceConfig.get(\"className\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"sourceSpecsTopic\"), \"go-func-input\");\n        Assert.assertEquals(goInstanceConfig.get(\"secretsMap\"), secretsMap.toString());\n        Assert.assertEquals(goInstanceConfig.get(\"sourceSchemaType\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"sinkSpecsTopic\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"clusterName\"), \"kluster\");\n        Assert.assertEquals(goInstanceConfig.get(\"nameSpace\"), \"default\");\n        Assert.assertEquals(goInstanceConfig.get(\"receiverQueueSize\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"tenant\"), \"public\");\n        Assert.assertEquals(goInstanceConfig.get(\"ram\"), 32);\n        Assert.assertEquals(goInstanceConfig.get(\"logTopic\"), \"go-func-log\");\n        Assert.assertEquals(goInstanceConfig.get(\"processingGuarantees\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"autoAck\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"regexPatternSubscription\"), false);\n        Assert.assertEquals(goInstanceConfig.get(\"pulsarServiceURL\"), \"pulsar://localhost:6650\");\n        Assert.assertEquals(goInstanceConfig.get(\"runtime\"), 3);\n        Assert.assertEquals(goInstanceConfig.get(\"cpu\"), 2.0);\n        Assert.assertEquals(goInstanceConfig.get(\"funcID\"), \"func-7734\");\n        Assert.assertEquals(goInstanceConfig.get(\"funcVersion\"), \"1.0.0\");\n        Assert.assertEquals(goInstanceConfig.get(\"disk\"), 1024);\n        Assert.assertEquals(goInstanceConfig.get(\"instanceID\"), 3000);\n        Assert.assertEquals(goInstanceConfig.get(\"cleanupSubscription\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"port\"), 1337);\n        Assert.assertEquals(goInstanceConfig.get(\"subscriptionType\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"timeoutMs\"), 500);\n        Assert.assertEquals(goInstanceConfig.get(\"subscriptionName\"), \"go-func-sub\");\n        Assert.assertEquals(goInstanceConfig.get(\"name\"), \"go-func\");\n        Assert.assertEquals(goInstanceConfig.get(\"expectedHealthCheckInterval\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"deadLetterTopic\"), \"go-func-deadletter\");\n        Assert.assertEquals(goInstanceConfig.get(\"userConfig\"), userConfig.toString());\n        Assert.assertEquals(goInstanceConfig.get(\"metricsPort\"), 60000);\n    }\n",
    "test_tgt_code": "    @Test(dataProvider = \"k8sRuntime\")\n    public void getGoInstanceCmd(boolean k8sRuntime) throws IOException {\n        HashMap<String, String> goInstanceConfig;\n\n        InstanceConfig instanceConfig = new InstanceConfig();\n        instanceConfig.setClusterName(\"kluster\");\n        instanceConfig.setInstanceId(3000);\n        instanceConfig.setFunctionId(\"func-7734\");\n        instanceConfig.setFunctionVersion(\"1.0.0\");\n        instanceConfig.setMaxBufferedTuples(5);\n        instanceConfig.setPort(1337);\n        instanceConfig.setMetricsPort(60000);\n\n        AuthenticationConfig authConfig = AuthenticationConfig.builder()\n                .clientAuthenticationPlugin(\"org.apache.pulsar.client.impl.auth.AuthenticationToken\")\n                .clientAuthenticationParameters(\"file:///secret/token.jwt\")\n                .tlsTrustCertsFilePath(\"/secret/ca.cert.pem\")\n                .tlsHostnameVerificationEnable(true)\n                .tlsAllowInsecureConnection(false)\n                .build();\n\n        JSONObject userConfig = new JSONObject();\n        userConfig.put(\"word-of-the-day\", \"der Weltschmerz\");\n\n        JSONObject secretsMap = new JSONObject();\n        secretsMap.put(\"secret\", \"cake is a lie\");\n\n        Function.SourceSpec sources = Function.SourceSpec.newBuilder()\n                .setCleanupSubscription(true)\n                .setSubscriptionName(\"go-func-sub\")\n                .setTimeoutMs(500)\n                .putInputSpecs(\"go-func-input\", Function.ConsumerSpec.newBuilder().setIsRegexPattern(false).build())\n                .build();\n\n        Function.RetryDetails retryDetails = Function.RetryDetails.newBuilder()\n                .setDeadLetterTopic(\"go-func-deadletter\")\n                .setMaxMessageRetries(1)\n                .build();\n\n        Function.Resources resources = Function.Resources.newBuilder()\n                .setCpu(2)\n                .setDisk(1024)\n                .setRam(32)\n                .build();\n\n        Function.FunctionDetails functionDetails = Function.FunctionDetails.newBuilder()\n                .setAutoAck(true)\n                .setTenant(\"public\")\n                .setNamespace(\"default\")\n                .setName(\"go-func\")\n                .setLogTopic(\"go-func-log\")\n                .setProcessingGuarantees(Function.ProcessingGuarantees.ATLEAST_ONCE)\n                .setRuntime(Function.FunctionDetails.Runtime.GO)\n                .setSecretsMap(secretsMap.toJSONString())\n                .setParallelism(1)\n                .setSource(sources)\n                .setRetryDetails(retryDetails)\n                .setResources(resources)\n                .setUserConfig(userConfig.toJSONString())\n                .build();\n\n        instanceConfig.setFunctionDetails(functionDetails);\n\n        List<String> commands = RuntimeUtils.getGoInstanceCmd(instanceConfig, authConfig,\"config\", \"pulsar://localhost:6650\", k8sRuntime);\n        if (k8sRuntime) {\n            goInstanceConfig = new ObjectMapper().readValue(commands.get(2).replaceAll(\"^\\'|\\'$\", \"\"), HashMap.class);\n        } else {\n            goInstanceConfig = new ObjectMapper().readValue(commands.get(2), HashMap.class);\n        }\n        Assert.assertEquals(commands.toArray().length, 3);\n        Assert.assertEquals(commands.get(0), \"config\");\n        Assert.assertEquals(commands.get(1), \"-instance-conf\");\n        Assert.assertEquals(goInstanceConfig.get(\"maxBufTuples\"), 5);\n        Assert.assertEquals(goInstanceConfig.get(\"maxMessageRetries\"), 1);\n        Assert.assertEquals(goInstanceConfig.get(\"killAfterIdleMs\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"parallelism\"), 1);\n        Assert.assertEquals(goInstanceConfig.get(\"className\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"sourceSpecsTopic\"), \"go-func-input\");\n        Assert.assertEquals(goInstanceConfig.get(\"secretsMap\"), secretsMap.toString());\n        Assert.assertEquals(goInstanceConfig.get(\"sourceSchemaType\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"sinkSpecsTopic\"), \"\");\n        Assert.assertEquals(goInstanceConfig.get(\"clusterName\"), \"kluster\");\n        Assert.assertEquals(goInstanceConfig.get(\"nameSpace\"), \"default\");\n        Assert.assertEquals(goInstanceConfig.get(\"receiverQueueSize\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"tenant\"), \"public\");\n        Assert.assertEquals(goInstanceConfig.get(\"ram\"), 32);\n        Assert.assertEquals(goInstanceConfig.get(\"logTopic\"), \"go-func-log\");\n        Assert.assertEquals(goInstanceConfig.get(\"processingGuarantees\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"autoAck\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"regexPatternSubscription\"), false);\n        Assert.assertEquals(goInstanceConfig.get(\"pulsarServiceURL\"), \"pulsar://localhost:6650\");\n        Assert.assertEquals(goInstanceConfig.get(\"runtime\"), 3);\n        Assert.assertEquals(goInstanceConfig.get(\"cpu\"), 2.0);\n        Assert.assertEquals(goInstanceConfig.get(\"funcID\"), \"func-7734\");\n        Assert.assertEquals(goInstanceConfig.get(\"funcVersion\"), \"1.0.0\");\n        Assert.assertEquals(goInstanceConfig.get(\"disk\"), 1024);\n        Assert.assertEquals(goInstanceConfig.get(\"instanceID\"), 3000);\n        Assert.assertEquals(goInstanceConfig.get(\"cleanupSubscription\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"port\"), 1337);\n        Assert.assertEquals(goInstanceConfig.get(\"subscriptionType\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"timeoutMs\"), 500);\n        Assert.assertEquals(goInstanceConfig.get(\"subscriptionName\"), \"go-func-sub\");\n        Assert.assertEquals(goInstanceConfig.get(\"name\"), \"go-func\");\n        Assert.assertEquals(goInstanceConfig.get(\"expectedHealthCheckInterval\"), 0);\n        Assert.assertEquals(goInstanceConfig.get(\"deadLetterTopic\"), \"go-func-deadletter\");\n        Assert.assertEquals(goInstanceConfig.get(\"userConfig\"), userConfig.toString());\n        Assert.assertEquals(goInstanceConfig.get(\"metricsPort\"), 60000);\n        Assert.assertEquals(goInstanceConfig.get(\"clientAuthenticationPlugin\"), \"org.apache.pulsar.client.impl.auth.AuthenticationToken\");\n        Assert.assertEquals(goInstanceConfig.get(\"clientAuthenticationParameters\"), \"file:///secret/token.jwt\");\n        Assert.assertEquals(goInstanceConfig.get(\"tlsTrustCertsFilePath\"), \"/secret/ca.cert.pem\");\n        Assert.assertEquals(goInstanceConfig.get(\"tlsHostnameVerificationEnable\"), true);\n        Assert.assertEquals(goInstanceConfig.get(\"tlsAllowInsecureConnection\"), false);\n    }\n",
    "focal_path_src": [
      "pulsar-functions/runtime/src/main/java/org/apache/pulsar/functions/runtime/RuntimeUtils.java#getGoInstanceCmd"
    ],
    "focal_path_tgt": [
      "pulsar-functions/runtime/src/main/java/org/apache/pulsar/functions/runtime/RuntimeUtils.java#getGoInstanceCmd"
    ],
    "focal_src": [
      "    /**\n     * Different from python and java function, Go function uploads a complete executable file(including:\n     * instance file + user code file). Its parameter list is provided to the broker in the form of a yaml file,\n     * the advantage of this approach is that backward compatibility is guaranteed.\n     *\n     * In Java and Python the instance is managed by broker (or function worker) so the changes in command line\n     * is under control; but in Go the instance is compiled with the user function, so pulsar doesn't have the\n     * control what instance is used in the function. Hence in order to support BC for go function, we can't\n     * dynamically add more commandline arguments. Using an instance config to pass the parameters from function\n     * worker to go instance is the best way for maintaining the BC.\n     * <p>\n     * When we run the go function, we only need to specify the location of the go-function file and the yaml file.\n     * The content of the yaml file will be automatically generated according to the content provided by instanceConfig.\n     */\n\n    public static List<String> getGoInstanceCmd(InstanceConfig instanceConfig,\n                                                String originalCodeFileName,\n                                                String pulsarServiceUrl,\n                                                boolean k8sRuntime) throws IOException {\n        final List<String> args = new LinkedList<>();\n        GoInstanceConfig goInstanceConfig = new GoInstanceConfig();\n\n        if (instanceConfig.getClusterName() != null) {\n            goInstanceConfig.setClusterName(instanceConfig.getClusterName());\n        }\n\n        if (instanceConfig.getInstanceId() != 0) {\n            goInstanceConfig.setInstanceID(instanceConfig.getInstanceId());\n        }\n\n        if (instanceConfig.getFunctionId() != null) {\n            goInstanceConfig.setFuncID(instanceConfig.getFunctionId());\n        }\n\n        if (instanceConfig.getFunctionVersion() != null) {\n            goInstanceConfig.setFuncVersion(instanceConfig.getFunctionVersion());\n        }\n\n        if (instanceConfig.getFunctionDetails().getAutoAck()) {\n            goInstanceConfig.setAutoAck(instanceConfig.getFunctionDetails().getAutoAck());\n        }\n\n        if (instanceConfig.getFunctionDetails().getTenant() != null) {\n            goInstanceConfig.setTenant(instanceConfig.getFunctionDetails().getTenant());\n        }\n\n        if (instanceConfig.getFunctionDetails().getNamespace() != null) {\n            goInstanceConfig.setNameSpace(instanceConfig.getFunctionDetails().getNamespace());\n        }\n\n        if (instanceConfig.getFunctionDetails().getName() != null) {\n            goInstanceConfig.setName(instanceConfig.getFunctionDetails().getName());\n        }\n\n        if (instanceConfig.getFunctionDetails().getLogTopic() != null) {\n            goInstanceConfig.setLogTopic(instanceConfig.getFunctionDetails().getLogTopic());\n        }\n        if (instanceConfig.getFunctionDetails().getProcessingGuarantees() != null) {\n            goInstanceConfig\n                    .setProcessingGuarantees(instanceConfig.getFunctionDetails().getProcessingGuaranteesValue());\n        }\n        if (instanceConfig.getFunctionDetails().getRuntime() != null) {\n            goInstanceConfig.setRuntime(instanceConfig.getFunctionDetails().getRuntimeValue());\n        }\n        if (instanceConfig.getFunctionDetails().getSecretsMap() != null) {\n            goInstanceConfig.setSecretsMap(instanceConfig.getFunctionDetails().getSecretsMap());\n        }\n        if (instanceConfig.getFunctionDetails().getUserConfig() != null) {\n            goInstanceConfig.setUserConfig(instanceConfig.getFunctionDetails().getUserConfig());\n        }\n        if (instanceConfig.getFunctionDetails().getParallelism() != 0) {\n            goInstanceConfig.setParallelism(instanceConfig.getFunctionDetails().getParallelism());\n        }\n\n        if (instanceConfig.getMaxBufferedTuples() != 0) {\n            goInstanceConfig.setMaxBufTuples(instanceConfig.getMaxBufferedTuples());\n        }\n\n        if (pulsarServiceUrl != null) {\n            goInstanceConfig.setPulsarServiceURL(pulsarServiceUrl);\n        }\n        if (instanceConfig.getFunctionDetails().getSource().getCleanupSubscription()) {\n            goInstanceConfig\n                    .setCleanupSubscription(instanceConfig.getFunctionDetails().getSource().getCleanupSubscription());\n        }\n        if (instanceConfig.getFunctionDetails().getSource().getSubscriptionName() != null) {\n            goInstanceConfig.setSubscriptionName(instanceConfig.getFunctionDetails().getSource().getSubscriptionName());\n        }\n        goInstanceConfig.setSubscriptionPosition(\n                instanceConfig.getFunctionDetails().getSource().getSubscriptionPosition().getNumber());\n\n        if (instanceConfig.getFunctionDetails().getSource().getInputSpecsMap() != null) {\n            Map<String, String> sourceInputSpecs = new HashMap<>();\n            for (Map.Entry<String, Function.ConsumerSpec> entry :\n                    instanceConfig.getFunctionDetails().getSource().getInputSpecsMap().entrySet()) {\n                String topic = entry.getKey();\n                Function.ConsumerSpec spec = entry.getValue();\n                sourceInputSpecs.put(topic, JsonFormat.printer().omittingInsignificantWhitespace().print(spec));\n                goInstanceConfig.setSourceSpecsTopic(topic);\n            }\n            goInstanceConfig.setSourceInputSpecs(sourceInputSpecs);\n        }\n\n        if (instanceConfig.getFunctionDetails().getSource().getTimeoutMs() != 0) {\n            goInstanceConfig.setTimeoutMs(instanceConfig.getFunctionDetails().getSource().getTimeoutMs());\n        }\n\n        if (instanceConfig.getFunctionDetails().getSink().getTopic() != null) {\n            goInstanceConfig.setSinkSpecsTopic(instanceConfig.getFunctionDetails().getSink().getTopic());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getCpu() != 0) {\n            goInstanceConfig.setCpu(instanceConfig.getFunctionDetails().getResources().getCpu());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getRam() != 0) {\n            goInstanceConfig.setRam(instanceConfig.getFunctionDetails().getResources().getRam());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getDisk() != 0) {\n            goInstanceConfig.setDisk(instanceConfig.getFunctionDetails().getResources().getDisk());\n        }\n\n        if (instanceConfig.getFunctionDetails().getRetryDetails().getDeadLetterTopic() != null) {\n            goInstanceConfig\n                    .setDeadLetterTopic(instanceConfig.getFunctionDetails().getRetryDetails().getDeadLetterTopic());\n        }\n\n        if (instanceConfig.getFunctionDetails().getRetryDetails().getMaxMessageRetries() != 0) {\n            goInstanceConfig\n                    .setMaxMessageRetries(instanceConfig.getFunctionDetails().getRetryDetails().getMaxMessageRetries());\n        }\n\n        if (instanceConfig.hasValidMetricsPort()) {\n            goInstanceConfig.setMetricsPort(instanceConfig.getMetricsPort());\n        }\n\n        goInstanceConfig.setKillAfterIdleMs(0);\n        goInstanceConfig.setPort(instanceConfig.getPort());\n\n        // Parse the contents of goInstanceConfig into json form string\n        ObjectMapper objectMapper = ObjectMapperFactory.getMapper().getObjectMapper();\n        String configContent = objectMapper.writeValueAsString(goInstanceConfig);\n\n        args.add(originalCodeFileName);\n        args.add(\"-instance-conf\");\n        if (k8sRuntime) {\n            args.add(\"'\" + configContent + \"'\");\n        } else {\n            args.add(configContent);\n        }\n        return args;\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * Different from python and java function, Go function uploads a complete executable file(including:\n     * instance file + user code file). Its parameter list is provided to the broker in the form of a yaml file,\n     * the advantage of this approach is that backward compatibility is guaranteed.\n     *\n     * In Java and Python the instance is managed by broker (or function worker) so the changes in command line\n     * is under control; but in Go the instance is compiled with the user function, so pulsar doesn't have the\n     * control what instance is used in the function. Hence in order to support BC for go function, we can't\n     * dynamically add more commandline arguments. Using an instance config to pass the parameters from function\n     * worker to go instance is the best way for maintaining the BC.\n     * <p>\n     * When we run the go function, we only need to specify the location of the go-function file and the yaml file.\n     * The content of the yaml file will be automatically generated according to the content provided by instanceConfig.\n     */\n\n    public static List<String> getGoInstanceCmd(InstanceConfig instanceConfig,\n                                                AuthenticationConfig authConfig,\n                                                String originalCodeFileName,\n                                                String pulsarServiceUrl,\n                                                boolean k8sRuntime) throws IOException {\n        final List<String> args = new LinkedList<>();\n        GoInstanceConfig goInstanceConfig = new GoInstanceConfig();\n\n        if (instanceConfig.getClusterName() != null) {\n            goInstanceConfig.setClusterName(instanceConfig.getClusterName());\n        }\n\n        if (instanceConfig.getInstanceId() != 0) {\n            goInstanceConfig.setInstanceID(instanceConfig.getInstanceId());\n        }\n\n        if (instanceConfig.getFunctionId() != null) {\n            goInstanceConfig.setFuncID(instanceConfig.getFunctionId());\n        }\n\n        if (instanceConfig.getFunctionVersion() != null) {\n            goInstanceConfig.setFuncVersion(instanceConfig.getFunctionVersion());\n        }\n\n        if (instanceConfig.getFunctionDetails().getAutoAck()) {\n            goInstanceConfig.setAutoAck(instanceConfig.getFunctionDetails().getAutoAck());\n        }\n\n        if (instanceConfig.getFunctionDetails().getTenant() != null) {\n            goInstanceConfig.setTenant(instanceConfig.getFunctionDetails().getTenant());\n        }\n\n        if (instanceConfig.getFunctionDetails().getNamespace() != null) {\n            goInstanceConfig.setNameSpace(instanceConfig.getFunctionDetails().getNamespace());\n        }\n\n        if (instanceConfig.getFunctionDetails().getName() != null) {\n            goInstanceConfig.setName(instanceConfig.getFunctionDetails().getName());\n        }\n\n        if (instanceConfig.getFunctionDetails().getLogTopic() != null) {\n            goInstanceConfig.setLogTopic(instanceConfig.getFunctionDetails().getLogTopic());\n        }\n        if (instanceConfig.getFunctionDetails().getProcessingGuarantees() != null) {\n            goInstanceConfig\n                    .setProcessingGuarantees(instanceConfig.getFunctionDetails().getProcessingGuaranteesValue());\n        }\n        if (instanceConfig.getFunctionDetails().getRuntime() != null) {\n            goInstanceConfig.setRuntime(instanceConfig.getFunctionDetails().getRuntimeValue());\n        }\n        if (instanceConfig.getFunctionDetails().getSecretsMap() != null) {\n            goInstanceConfig.setSecretsMap(instanceConfig.getFunctionDetails().getSecretsMap());\n        }\n        if (instanceConfig.getFunctionDetails().getUserConfig() != null) {\n            goInstanceConfig.setUserConfig(instanceConfig.getFunctionDetails().getUserConfig());\n        }\n        if (instanceConfig.getFunctionDetails().getParallelism() != 0) {\n            goInstanceConfig.setParallelism(instanceConfig.getFunctionDetails().getParallelism());\n        }\n\n        if (authConfig != null) {\n            if (isNotBlank(authConfig.getClientAuthenticationPlugin())\n                    && isNotBlank(authConfig.getClientAuthenticationParameters())) {\n                goInstanceConfig.setClientAuthenticationPlugin(authConfig.getClientAuthenticationPlugin());\n                goInstanceConfig.setClientAuthenticationParameters(authConfig.getClientAuthenticationParameters());\n            }\n            goInstanceConfig.setTlsAllowInsecureConnection(\n                    authConfig.isTlsAllowInsecureConnection());\n            goInstanceConfig.setTlsHostnameVerificationEnable(\n                    authConfig.isTlsHostnameVerificationEnable());\n            if (isNotBlank(authConfig.getTlsTrustCertsFilePath())){\n                goInstanceConfig.setTlsTrustCertsFilePath(\n                        authConfig.getTlsTrustCertsFilePath());\n            }\n\n        }\n\n        if (instanceConfig.getMaxBufferedTuples() != 0) {\n            goInstanceConfig.setMaxBufTuples(instanceConfig.getMaxBufferedTuples());\n        }\n\n        if (pulsarServiceUrl != null) {\n            goInstanceConfig.setPulsarServiceURL(pulsarServiceUrl);\n        }\n        if (instanceConfig.getFunctionDetails().getSource().getCleanupSubscription()) {\n            goInstanceConfig\n                    .setCleanupSubscription(instanceConfig.getFunctionDetails().getSource().getCleanupSubscription());\n        }\n        if (instanceConfig.getFunctionDetails().getSource().getSubscriptionName() != null) {\n            goInstanceConfig.setSubscriptionName(instanceConfig.getFunctionDetails().getSource().getSubscriptionName());\n        }\n        goInstanceConfig.setSubscriptionPosition(\n                instanceConfig.getFunctionDetails().getSource().getSubscriptionPosition().getNumber());\n\n        if (instanceConfig.getFunctionDetails().getSource().getInputSpecsMap() != null) {\n            Map<String, String> sourceInputSpecs = new HashMap<>();\n            for (Map.Entry<String, Function.ConsumerSpec> entry :\n                    instanceConfig.getFunctionDetails().getSource().getInputSpecsMap().entrySet()) {\n                String topic = entry.getKey();\n                Function.ConsumerSpec spec = entry.getValue();\n                sourceInputSpecs.put(topic, JsonFormat.printer().omittingInsignificantWhitespace().print(spec));\n                goInstanceConfig.setSourceSpecsTopic(topic);\n            }\n            goInstanceConfig.setSourceInputSpecs(sourceInputSpecs);\n        }\n\n        if (instanceConfig.getFunctionDetails().getSource().getTimeoutMs() != 0) {\n            goInstanceConfig.setTimeoutMs(instanceConfig.getFunctionDetails().getSource().getTimeoutMs());\n        }\n\n        if (instanceConfig.getFunctionDetails().getSink().getTopic() != null) {\n            goInstanceConfig.setSinkSpecsTopic(instanceConfig.getFunctionDetails().getSink().getTopic());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getCpu() != 0) {\n            goInstanceConfig.setCpu(instanceConfig.getFunctionDetails().getResources().getCpu());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getRam() != 0) {\n            goInstanceConfig.setRam(instanceConfig.getFunctionDetails().getResources().getRam());\n        }\n\n        if (instanceConfig.getFunctionDetails().getResources().getDisk() != 0) {\n            goInstanceConfig.setDisk(instanceConfig.getFunctionDetails().getResources().getDisk());\n        }\n\n        if (instanceConfig.getFunctionDetails().getRetryDetails().getDeadLetterTopic() != null) {\n            goInstanceConfig\n                    .setDeadLetterTopic(instanceConfig.getFunctionDetails().getRetryDetails().getDeadLetterTopic());\n        }\n\n        if (instanceConfig.getFunctionDetails().getRetryDetails().getMaxMessageRetries() != 0) {\n            goInstanceConfig\n                    .setMaxMessageRetries(instanceConfig.getFunctionDetails().getRetryDetails().getMaxMessageRetries());\n        }\n\n        if (instanceConfig.hasValidMetricsPort()) {\n            goInstanceConfig.setMetricsPort(instanceConfig.getMetricsPort());\n        }\n\n        goInstanceConfig.setKillAfterIdleMs(0);\n        goInstanceConfig.setPort(instanceConfig.getPort());\n\n        // Parse the contents of goInstanceConfig into json form string\n        ObjectMapper objectMapper = ObjectMapperFactory.getMapper().getObjectMapper();\n        String configContent = objectMapper.writeValueAsString(goInstanceConfig);\n\n        args.add(originalCodeFileName);\n        args.add(\"-instance-conf\");\n        if (k8sRuntime) {\n            args.add(\"'\" + configContent + \"'\");\n        } else {\n            args.add(configContent);\n        }\n        return args;\n    }\n"
    ],
    "test_id": 4,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test(dataProvider = \"k8sRuntime\")\npublic void getGoInstanceCmd(boolean k8sRuntime) throws IOException {\n    HashMap<String, String> goInstanceConfig;\n\n    InstanceConfig instanceConfig = new InstanceConfig();\n    instanceConfig.setClusterName(\"kluster\");\n    instanceConfig.setInstanceId(3000);\n    instanceConfig.setFunctionId(\"func-7734\");\n    instanceConfig.setFunctionVersion(\"1.0.0\");\n    instanceConfig.setMaxBufferedTuples(5);\n    instanceConfig.setPort(1337);\n    instanceConfig.setMetricsPort(60000);\n\n\n    JSONObject userConfig = new JSONObject();\n    userConfig.put(\"word-of-the-day\", \"der Weltschmerz\");\n\n    JSONObject secretsMap = new JSONObject();\n    secretsMap.put(\"secret\", \"cake is a lie\");\n\n    Function.SourceSpec sources = Function.SourceSpec.newBuilder()\n            .setCleanupSubscription(true)\n            .setSubscriptionName(\"go-func-sub\")\n            .setTimeoutMs(500)\n            .putInputSpecs(\"go-func-input\", Function.ConsumerSpec.newBuilder().setIsRegexPattern(false).build())\n            .build();\n\n    Function.RetryDetails retryDetails = Function.RetryDetails.newBuilder()\n            .setDeadLetterTopic(\"go-func-deadletter\")\n            .setMaxMessageRetries(1)\n            .build();\n\n    Function.Resources resources = Function.Resources.newBuilder()\n            .setCpu(2)\n            .setDisk(1024)\n            .setRam(32)\n            .build();\n\n    Function.FunctionDetails functionDetails = Function.FunctionDetails.newBuilder()\n            .setAutoAck(true)\n            .setTenant(\"public\")\n            .setNamespace(\"default\")\n            .setName(\"go-func\")\n            .setLogTopic(\"go-func-log\")\n            .setProcessingGuarantees(Function.ProcessingGuarantees.ATLEAST_ONCE)\n            .setRuntime(Function.FunctionDetails.Runtime.GO)\n            .setSecretsMap(secretsMap.toJSONString())\n            .setParallelism(1)\n            .setSource(sources)\n            .setRetryDetails(retryDetails)\n            .setResources(resources)\n            .setUserConfig(userConfig.toJSONString())\n            .build();\n\n    instanceConfig.setFunctionDetails(functionDetails);\n\n    List<String> commands = RuntimeUtils.getGoInstanceCmd(instanceConfig, \"config\", \"pulsar://localhost:6650\", k8sRuntime);\n    if (k8sRuntime) {\n        goInstanceConfig = new ObjectMapper().readValue(commands.get(2).replaceAll(\"^\\'|\\'$\", \"\"), HashMap.class);\n    } else {\n        goInstanceConfig = new ObjectMapper().readValue(commands.get(2), HashMap.class);\n    }\n    Assert.assertEquals(commands.toArray().length, 3);\n    Assert.assertEquals(commands.get(0), \"config\");\n    Assert.assertEquals(commands.get(1), \"-instance-conf\");\n    Assert.assertEquals(goInstanceConfig.get(\"maxBufTuples\"), 5);\n    Assert.assertEquals(goInstanceConfig.get(\"maxMessageRetries\"), 1);\n    Assert.assertEquals(goInstanceConfig.get(\"killAfterIdleMs\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"parallelism\"), 1);\n    Assert.assertEquals(goInstanceConfig.get(\"className\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"sourceSpecsTopic\"), \"go-func-input\");\n    Assert.assertEquals(goInstanceConfig.get(\"secretsMap\"), secretsMap.toString());\n    Assert.assertEquals(goInstanceConfig.get(\"sourceSchemaType\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"sinkSpecsTopic\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"clusterName\"), \"kluster\");\n    Assert.assertEquals(goInstanceConfig.get(\"nameSpace\"), \"default\");\n    Assert.assertEquals(goInstanceConfig.get(\"receiverQueueSize\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"tenant\"), \"public\");\n    Assert.assertEquals(goInstanceConfig.get(\"ram\"), 32);\n    Assert.assertEquals(goInstanceConfig.get(\"logTopic\"), \"go-func-log\");\n    Assert.assertEquals(goInstanceConfig.get(\"processingGuarantees\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"autoAck\"), true);\n    Assert.assertEquals(goInstanceConfig.get(\"regexPatternSubscription\"), false);\n    Assert.assertEquals(goInstanceConfig.get(\"pulsarServiceURL\"), \"pulsar://localhost:6650\");\n    Assert.assertEquals(goInstanceConfig.get(\"runtime\"), 3);\n    Assert.assertEquals(goInstanceConfig.get(\"cpu\"), 2.0);\n    Assert.assertEquals(goInstanceConfig.get(\"funcID\"), \"func-7734\");\n    Assert.assertEquals(goInstanceConfig.get(\"funcVersion\"), \"1.0.0\");\n    Assert.assertEquals(goInstanceConfig.get(\"disk\"), 1024);\n    Assert.assertEquals(goInstanceConfig.get(\"instanceID\"), 3000);\n    Assert.assertEquals(goInstanceConfig.get(\"cleanupSubscription\"), true);\n    Assert.assertEquals(goInstanceConfig.get(\"port\"), 1337);\n    Assert.assertEquals(goInstanceConfig.get(\"subscriptionType\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"timeoutMs\"), 500);\n    Assert.assertEquals(goInstanceConfig.get(\"subscriptionName\"), \"go-func-sub\");\n    Assert.assertEquals(goInstanceConfig.get(\"name\"), \"go-func\");\n    Assert.assertEquals(goInstanceConfig.get(\"expectedHealthCheckInterval\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"deadLetterTopic\"), \"go-func-deadletter\");\n    Assert.assertEquals(goInstanceConfig.get(\"userConfig\"), userConfig.toString());\n    Assert.assertEquals(goInstanceConfig.get(\"metricsPort\"), 60000);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test(dataProvider = \"k8sRuntime\")\npublic void getGoInstanceCmd(boolean k8sRuntime) throws IOException {\n    HashMap<String, String> goInstanceConfig;\n\n    InstanceConfig instanceConfig = new InstanceConfig();\n    instanceConfig.setClusterName(\"kluster\");\n    instanceConfig.setInstanceId(3000);\n    instanceConfig.setFunctionId(\"func-7734\");\n    instanceConfig.setFunctionVersion(\"1.0.0\");\n    instanceConfig.setMaxBufferedTuples(5);\n    instanceConfig.setPort(1337);\n    instanceConfig.setMetricsPort(60000);\n\n\n    JSONObject userConfig = new JSONObject();\n    userConfig.put(\"word-of-the-day\", \"der Weltschmerz\");\n\n    JSONObject secretsMap = new JSONObject();\n    secretsMap.put(\"secret\", \"cake is a lie\");\n\n    Function.SourceSpec sources = Function.SourceSpec.newBuilder()\n            .setCleanupSubscription(true)\n            .setSubscriptionName(\"go-func-sub\")\n            .setTimeoutMs(500)\n            .putInputSpecs(\"go-func-input\", Function.ConsumerSpec.newBuilder().setIsRegexPattern(false).build())\n            .build();\n\n    Function.RetryDetails retryDetails = Function.RetryDetails.newBuilder()\n            .setDeadLetterTopic(\"go-func-deadletter\")\n            .setMaxMessageRetries(1)\n            .build();\n\n    Function.Resources resources = Function.Resources.newBuilder()\n            .setCpu(2)\n            .setDisk(1024)\n            .setRam(32)\n            .build();\n\n    Function.FunctionDetails functionDetails = Function.FunctionDetails.newBuilder()\n            .setAutoAck(true)\n            .setTenant(\"public\")\n            .setNamespace(\"default\")\n            .setName(\"go-func\")\n            .setLogTopic(\"go-func-log\")\n            .setProcessingGuarantees(Function.ProcessingGuarantees.ATLEAST_ONCE)\n            .setRuntime(Function.FunctionDetails.Runtime.GO)\n            .setSecretsMap(secretsMap.toJSONString())\n            .setParallelism(1)\n            .setSource(sources)\n            .setRetryDetails(retryDetails)\n            .setResources(resources)\n            .setUserConfig(userConfig.toJSONString())\n            .build();\n\n    instanceConfig.setFunctionDetails(functionDetails);\n\n    List<String> commands = RuntimeUtils.getGoInstanceCmd(instanceConfig, \"config\", \"pulsar://localhost:6650\", k8sRuntime);\n    if (k8sRuntime) {\n        goInstanceConfig = new ObjectMapper().readValue(commands.get(2).replaceAll(\"^\\'|\\'$\", \"\"), HashMap.class);\n    } else {\n        goInstanceConfig = new ObjectMapper().readValue(commands.get(2), HashMap.class);\n    }\n    Assert.assertEquals(commands.toArray().length, 3);\n    Assert.assertEquals(commands.get(0), \"config\");\n    Assert.assertEquals(commands.get(1), \"-instance-conf\");\n    Assert.assertEquals(goInstanceConfig.get(\"maxBufTuples\"), 5);\n    Assert.assertEquals(goInstanceConfig.get(\"maxMessageRetries\"), 1);\n    Assert.assertEquals(goInstanceConfig.get(\"killAfterIdleMs\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"parallelism\"), 1);\n    Assert.assertEquals(goInstanceConfig.get(\"className\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"sourceSpecsTopic\"), \"go-func-input\");\n    Assert.assertEquals(goInstanceConfig.get(\"secretsMap\"), secretsMap.toString());\n    Assert.assertEquals(goInstanceConfig.get(\"sourceSchemaType\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"sinkSpecsTopic\"), \"\");\n    Assert.assertEquals(goInstanceConfig.get(\"clusterName\"), \"kluster\");\n    Assert.assertEquals(goInstanceConfig.get(\"nameSpace\"), \"default\");\n    Assert.assertEquals(goInstanceConfig.get(\"receiverQueueSize\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"tenant\"), \"public\");\n    Assert.assertEquals(goInstanceConfig.get(\"ram\"), 32);\n    Assert.assertEquals(goInstanceConfig.get(\"logTopic\"), \"go-func-log\");\n    Assert.assertEquals(goInstanceConfig.get(\"processingGuarantees\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"autoAck\"), true);\n    Assert.assertEquals(goInstanceConfig.get(\"regexPatternSubscription\"), false);\n    Assert.assertEquals(goInstanceConfig.get(\"pulsarServiceURL\"), \"pulsar://localhost:6650\");\n    Assert.assertEquals(goInstanceConfig.get(\"runtime\"), 3);\n    Assert.assertEquals(goInstanceConfig.get(\"cpu\"), 2.0);\n    Assert.assertEquals(goInstanceConfig.get(\"funcID\"), \"func-7734\");\n    Assert.assertEquals(goInstanceConfig.get(\"funcVersion\"), \"1.0.0\");\n    Assert.assertEquals(goInstanceConfig.get(\"disk\"), 1024);\n    Assert.assertEquals(goInstanceConfig.get(\"instanceID\"), 3000);\n    Assert.assertEquals(goInstanceConfig.get(\"cleanupSubscription\"), true);\n    Assert.assertEquals(goInstanceConfig.get(\"port\"), 1337);\n    Assert.assertEquals(goInstanceConfig.get(\"subscriptionType\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"timeoutMs\"), 500);\n    Assert.assertEquals(goInstanceConfig.get(\"subscriptionName\"), \"go-func-sub\");\n    Assert.assertEquals(goInstanceConfig.get(\"name\"), \"go-func\");\n    Assert.assertEquals(goInstanceConfig.get(\"expectedHealthCheckInterval\"), 0);\n    Assert.assertEquals(goInstanceConfig.get(\"deadLetterTopic\"), \"go-func-deadletter\");\n    Assert.assertEquals(goInstanceConfig.get(\"userConfig\"), userConfig.toString());\n    Assert.assertEquals(goInstanceConfig.get(\"metricsPort\"), 60000);\n}\n"
    ]
  },
  "5": {
    "commit_src": "980dfc81a5165147615232692e7b5a71b61c71a7",
    "commit_tgt": "bafc8277940a827bc7a9f7c7d22f07dfe1b3ef47",
    "changed_tests": [
      "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/BookiesApiTest.java"
    ],
    "refer_PR": "apache_pulsar-20949",
    "test_src": ".org.apache.pulsar.broker.admin.BookiesApiTest#testBasic",
    "test_tgt": [
      ".org.apache.pulsar.broker.admin.BookiesApiTest#testBasic"
    ],
    "test_src_code": "    @Test\n    public void testBasic() throws Exception {\n        // no map\n        BookiesRackConfiguration conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n        assertTrue(conf.isEmpty());\n\n        String bookie0 = \"127.0.0.1:3181\";\n        String bookie1 = \"127.0.0.2:3181\";\n\n        // get bookie doesn't exist\n        try {\n            admin.bookies().getBookieRackInfo(bookie0);\n            fail(\"should not reach here\");\n        } catch (PulsarAdminException pae) {\n            assertEquals(404, pae.getStatusCode());\n        }\n\n        // update the bookie info\n        BookieInfo newInfo0 = BookieInfo.builder()\n                .rack(\"/rack1\")\n                .hostname(\"127.0.0.1\")\n                .build();\n        BookieInfo newInfo1 = BookieInfo.builder()\n                .rack(\"/rack1\")\n                .hostname(\"127.0.0.2\")\n                .build();\n        admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo0);\n        BookieInfo readInfo0 = admin.bookies().getBookieRackInfo(bookie0);\n        assertEquals(newInfo0, readInfo0);\n        conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n        // number of groups\n        assertEquals(1, conf.size());\n        assertEquals(Optional.of(newInfo0), conf.getBookie(bookie0));\n\n        admin.bookies().updateBookieRackInfo(bookie1, \"default\", newInfo1);\n        BookieInfo readInfo1 = admin.bookies().getBookieRackInfo(bookie1);\n        assertEquals(newInfo1, readInfo1);\n        conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n        // number of groups\n        assertEquals(1, conf.size());\n        assertEquals(Optional.of(newInfo0), conf.getBookie(bookie0));\n        assertEquals(Optional.of(newInfo1), conf.getBookie(bookie1));\n\n        admin.bookies().deleteBookieRackInfo(bookie0);\n        try {\n            admin.bookies().getBookieRackInfo(bookie0);\n            fail(\"should not reach here\");\n        } catch (PulsarAdminException pae) {\n            assertEquals(404, pae.getStatusCode());\n        }\n        assertEquals(newInfo1, admin.bookies().getBookieRackInfo(bookie1));\n\n        admin.bookies().deleteBookieRackInfo(bookie1);\n        try {\n            admin.bookies().getBookieRackInfo(bookie1);\n            fail(\"should not reach here\");\n        } catch (PulsarAdminException pae) {\n            assertEquals(404, pae.getStatusCode());\n        }\n\n        conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n        assertTrue(conf.isEmpty());\n\n        BookiesClusterInfo bookies = admin.bookies().getBookies();\n        log.info(\"bookies info {}\", bookies);\n        assertEquals(bookies.getBookies().size(),\n                pulsar.getBookKeeperClient()\n                .getMetadataClientDriver()\n                .getRegistrationClient()\n                .getAllBookies()\n                .get()\n                .getValue()\n                .size());\n\n        // test invalid rack name\n        // use rack aware placement policy\n        String errorMsg = \"Bookie 'rack' parameter is invalid, When `RackawareEnsemblePlacementPolicy` is enabled, \"\n            + \"the rack name is not allowed to contain slash (`/`) except for the beginning and end of the rack name \"\n            + \"string. When `RegionawareEnsemblePlacementPolicy` is enabled, the rack name can only contain \"\n            + \"one slash (`/`) except for the beginning and end of the rack name string.\";\n\n        BookieInfo newInfo3 = BookieInfo.builder()\n            .rack(\"/rack/a\")\n            .hostname(\"127.0.0.2\")\n            .build();\n        try {\n            admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo3);\n            fail();\n        } catch (PulsarAdminException e) {\n            assertEquals(412, e.getStatusCode());\n            assertEquals(errorMsg, e.getMessage());\n        }\n\n        BookieInfo newInfo4 = BookieInfo.builder()\n            .rack(\"/rack\")\n            .hostname(\"127.0.0.2\")\n            .build();\n        try {\n            admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo4);\n        } catch (PulsarAdminException e) {\n            fail();\n        }\n\n        // enable region aware placement policy\n        ServiceConfiguration configuration = new ServiceConfiguration();\n        configuration.setBookkeeperClientRegionawarePolicyEnabled(true);\n        doReturn(configuration).when(pulsar).getConfiguration();\n        BookieInfo newInfo5 = BookieInfo.builder()\n            .rack(\"/region/rack/a\")\n            .hostname(\"127.0.0.2\")\n            .build();\n        try {\n            admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo5);\n            fail();\n        } catch (PulsarAdminException e) {\n            assertEquals(412, e.getStatusCode());\n            assertEquals(errorMsg, e.getMessage());\n        }\n\n        BookieInfo newInfo6 = BookieInfo.builder()\n            .rack(\"/region/rack/\")\n            .hostname(\"127.0.0.2\")\n            .build();\n        try {\n            admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo6);\n        } catch (PulsarAdminException e) {\n            fail();\n        }\n    }\n",
    "test_tgt_code": "    @Test\n    public void testBasic() throws Exception {\n        // no map\n        BookiesRackConfiguration conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n        assertTrue(conf.isEmpty());\n\n        String bookie0 = \"127.0.0.1:3181\";\n        String bookie1 = \"127.0.0.2:3181\";\n\n        // get bookie doesn't exist\n        try {\n            admin.bookies().getBookieRackInfo(bookie0);\n            fail(\"should not reach here\");\n        } catch (PulsarAdminException pae) {\n            assertEquals(404, pae.getStatusCode());\n            assertEquals(pae.getHttpError(), \"Bookie rack placement configuration not found: \" + bookie0);\n        }\n\n        // delete bookie doesn't exist\n        try {\n            admin.bookies().deleteBookieRackInfo(bookie0);\n            fail(\"should not reach here\");\n        } catch (PulsarAdminException pae) {\n            assertEquals(404, pae.getStatusCode());\n            assertEquals(pae.getHttpError(), \"Bookie rack placement configuration not found: \" + bookie0);\n        }\n\n        // update the bookie info\n        BookieInfo newInfo0 = BookieInfo.builder()\n                .rack(\"/rack1\")\n                .hostname(\"127.0.0.1\")\n                .build();\n        BookieInfo newInfo1 = BookieInfo.builder()\n                .rack(\"/rack1\")\n                .hostname(\"127.0.0.2\")\n                .build();\n        admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo0);\n        BookieInfo readInfo0 = admin.bookies().getBookieRackInfo(bookie0);\n        assertEquals(newInfo0, readInfo0);\n        conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n        // number of groups\n        assertEquals(1, conf.size());\n        assertEquals(Optional.of(newInfo0), conf.getBookie(bookie0));\n\n        admin.bookies().updateBookieRackInfo(bookie1, \"default\", newInfo1);\n        BookieInfo readInfo1 = admin.bookies().getBookieRackInfo(bookie1);\n        assertEquals(newInfo1, readInfo1);\n        conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n        // number of groups\n        assertEquals(1, conf.size());\n        assertEquals(Optional.of(newInfo0), conf.getBookie(bookie0));\n        assertEquals(Optional.of(newInfo1), conf.getBookie(bookie1));\n\n        admin.bookies().deleteBookieRackInfo(bookie0);\n        try {\n            admin.bookies().getBookieRackInfo(bookie0);\n            fail(\"should not reach here\");\n        } catch (PulsarAdminException pae) {\n            assertEquals(404, pae.getStatusCode());\n        }\n        assertEquals(newInfo1, admin.bookies().getBookieRackInfo(bookie1));\n\n        admin.bookies().deleteBookieRackInfo(bookie1);\n        try {\n            admin.bookies().getBookieRackInfo(bookie1);\n            fail(\"should not reach here\");\n        } catch (PulsarAdminException pae) {\n            assertEquals(404, pae.getStatusCode());\n        }\n\n        conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n        assertTrue(conf.isEmpty());\n\n        BookiesClusterInfo bookies = admin.bookies().getBookies();\n        log.info(\"bookies info {}\", bookies);\n        assertEquals(bookies.getBookies().size(),\n                pulsar.getBookKeeperClient()\n                .getMetadataClientDriver()\n                .getRegistrationClient()\n                .getAllBookies()\n                .get()\n                .getValue()\n                .size());\n\n        // test invalid rack name\n        // use rack aware placement policy\n        String errorMsg = \"Bookie 'rack' parameter is invalid, When `RackawareEnsemblePlacementPolicy` is enabled, \"\n            + \"the rack name is not allowed to contain slash (`/`) except for the beginning and end of the rack name \"\n            + \"string. When `RegionawareEnsemblePlacementPolicy` is enabled, the rack name can only contain \"\n            + \"one slash (`/`) except for the beginning and end of the rack name string.\";\n\n        BookieInfo newInfo3 = BookieInfo.builder()\n            .rack(\"/rack/a\")\n            .hostname(\"127.0.0.2\")\n            .build();\n        try {\n            admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo3);\n            fail();\n        } catch (PulsarAdminException e) {\n            assertEquals(412, e.getStatusCode());\n            assertEquals(errorMsg, e.getMessage());\n        }\n\n        BookieInfo newInfo4 = BookieInfo.builder()\n            .rack(\"/rack\")\n            .hostname(\"127.0.0.2\")\n            .build();\n        try {\n            admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo4);\n        } catch (PulsarAdminException e) {\n            fail();\n        }\n\n        // enable region aware placement policy\n        ServiceConfiguration configuration = new ServiceConfiguration();\n        configuration.setBookkeeperClientRegionawarePolicyEnabled(true);\n        doReturn(configuration).when(pulsar).getConfiguration();\n        BookieInfo newInfo5 = BookieInfo.builder()\n            .rack(\"/region/rack/a\")\n            .hostname(\"127.0.0.2\")\n            .build();\n        try {\n            admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo5);\n            fail();\n        } catch (PulsarAdminException e) {\n            assertEquals(412, e.getStatusCode());\n            assertEquals(errorMsg, e.getMessage());\n        }\n\n        BookieInfo newInfo6 = BookieInfo.builder()\n            .rack(\"/region/rack/\")\n            .hostname(\"127.0.0.2\")\n            .build();\n        try {\n            admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo6);\n        } catch (PulsarAdminException e) {\n            fail();\n        }\n    }\n",
    "focal_path_src": [
      "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v2/Bookies.java#getBookieRackInfo",
      "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v2/Bookies.java#deleteBookieRackInfo"
    ],
    "focal_path_tgt": [
      "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v2/Bookies.java#getBookieRackInfo",
      "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v2/Bookies.java#deleteBookieRackInfo"
    ],
    "focal_src": [
      "    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\")})\n    public void getBookieRackInfo(@Suspended final AsyncResponse asyncResponse,\n                                  @PathParam(\"bookie\") String bookieAddress) throws Exception {\n        validateSuperUserAccess();\n\n        getPulsarResources().getBookieResources().get()\n                .thenAccept(b -> {\n                    Optional<BookieInfo> bi = b.orElseGet(() -> new BookiesRackConfiguration())\n                            .getBookie(bookieAddress);\n                    if (bi.isPresent()) {\n                        asyncResponse.resume(bi.get());\n                    } else {\n                        asyncResponse.resume(new RestException(Status.NOT_FOUND,\n                                \"Bookie address not found: \" + bookieAddress));\n                    }\n                }).exceptionally(ex -> {\n            asyncResponse.resume(ex);\n            return null;\n        });\n    }\n",
      "    @DELETE\n    @Path(\"/racks-info/{bookie}\")\n    @ApiOperation(value = \"Removed the rack placement information for a specific bookie in the cluster\")\n    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\")})\n    public void deleteBookieRackInfo(@Suspended final AsyncResponse asyncResponse,\n                                     @PathParam(\"bookie\") String bookieAddress) throws Exception {\n        validateSuperUserAccess();\n\n        getPulsarResources().getBookieResources()\n                .update(optionalBookiesRackConfiguration -> {\n                    BookiesRackConfiguration brc = optionalBookiesRackConfiguration\n                            .orElseGet(() -> new BookiesRackConfiguration());\n\n                    if (!brc.removeBookie(bookieAddress)) {\n                        asyncResponse.resume(new RestException(Status.NOT_FOUND,\n                                \"Bookie address not found: \" + bookieAddress));\n                    }\n\n                    return brc;\n                }).thenAccept(__ -> {\n            log.info(\"Removed {} from rack mapping info\", bookieAddress);\n            asyncResponse.resume(Response.noContent().build());\n        }).exceptionally(ex -> {\n            asyncResponse.resume(ex);\n            return null;\n        });\n    }\n"
    ],
    "focal_tgt": [
      "    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\")})\n    public void getBookieRackInfo(@Suspended final AsyncResponse asyncResponse,\n                                  @PathParam(\"bookie\") String bookieAddress) throws Exception {\n        validateSuperUserAccess();\n\n        getPulsarResources().getBookieResources().get()\n                .thenAccept(b -> {\n                    Optional<BookieInfo> bi = b.orElseGet(() -> new BookiesRackConfiguration())\n                            .getBookie(bookieAddress);\n                    if (bi.isPresent()) {\n                        asyncResponse.resume(bi.get());\n                    } else {\n                        asyncResponse.resume(new RestException(Status.NOT_FOUND,\n                                \"Bookie rack placement configuration not found: \" + bookieAddress));\n                    }\n                }).exceptionally(ex -> {\n            asyncResponse.resume(ex);\n            return null;\n        });\n    }\n",
      "    @DELETE\n    @Path(\"/racks-info/{bookie}\")\n    @ApiOperation(value = \"Removed the rack placement information for a specific bookie in the cluster\")\n    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\")})\n    public void deleteBookieRackInfo(@Suspended final AsyncResponse asyncResponse,\n                                     @PathParam(\"bookie\") String bookieAddress) throws Exception {\n        validateSuperUserAccess();\n\n        getPulsarResources().getBookieResources()\n                .update(optionalBookiesRackConfiguration -> {\n                    BookiesRackConfiguration brc = optionalBookiesRackConfiguration\n                            .orElseGet(() -> new BookiesRackConfiguration());\n\n                    if (!brc.removeBookie(bookieAddress)) {\n                        asyncResponse.resume(new RestException(Status.NOT_FOUND,\n                                \"Bookie rack placement configuration not found: \" + bookieAddress));\n                    }\n\n                    return brc;\n                }).thenAccept(__ -> {\n            log.info(\"Removed {} from rack mapping info\", bookieAddress);\n            asyncResponse.resume(Response.noContent().build());\n        }).exceptionally(ex -> {\n            asyncResponse.resume(ex);\n            return null;\n        });\n    }\n"
    ],
    "test_id": 5,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testBasic() throws Exception {\n    // no map\n    BookiesRackConfiguration conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n    assertTrue(conf.isEmpty());\n\n    String bookie0 = \"127.0.0.1:3181\";\n    String bookie1 = \"127.0.0.2:3181\";\n\n    // get bookie doesn't exist\n    try {\n        admin.bookies().getBookieRackInfo(bookie0);\n        fail(\"should not reach here\");\n    } catch (PulsarAdminException pae) {\n        assertEquals(404, pae.getStatusCode());\n    }\n\n    // update the bookie info\n    BookieInfo newInfo0 = BookieInfo.builder()\n            .rack(\"/rack1\")\n            .hostname(\"127.0.0.1\")\n            .build();\n    BookieInfo newInfo1 = BookieInfo.builder()\n            .rack(\"/rack1\")\n            .hostname(\"127.0.0.2\")\n            .build();\n    admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo0);\n    BookieInfo readInfo0 = admin.bookies().getBookieRackInfo(bookie0);\n    assertEquals(newInfo0, readInfo0);\n    conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n    // number of groups\n    assertEquals(1, conf.size());\n    assertEquals(Optional.of(newInfo0), conf.getBookie(bookie0));\n\n    admin.bookies().updateBookieRackInfo(bookie1, \"default\", newInfo1);\n    BookieInfo readInfo1 = admin.bookies().getBookieRackInfo(bookie1);\n    assertEquals(newInfo1, readInfo1);\n    conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n    // number of groups\n    assertEquals(1, conf.size());\n    assertEquals(Optional.of(newInfo0), conf.getBookie(bookie0));\n    assertEquals(Optional.of(newInfo1), conf.getBookie(bookie1));\n\n    admin.bookies().deleteBookieRackInfo(bookie0);\n    try {\n        admin.bookies().getBookieRackInfo(bookie0);\n        fail(\"should not reach here\");\n    } catch (PulsarAdminException pae) {\n        assertEquals(404, pae.getStatusCode());\n    }\n    assertEquals(newInfo1, admin.bookies().getBookieRackInfo(bookie1));\n\n    admin.bookies().deleteBookieRackInfo(bookie1);\n    try {\n        admin.bookies().getBookieRackInfo(bookie1);\n        fail(\"should not reach here\");\n    } catch (PulsarAdminException pae) {\n        assertEquals(404, pae.getStatusCode());\n    }\n\n    conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n    assertTrue(conf.isEmpty());\n\n    BookiesClusterInfo bookies = admin.bookies().getBookies();\n    log.info(\"bookies info {}\", bookies);\n    assertEquals(bookies.getBookies().size(),\n            pulsar.getBookKeeperClient()\n            .getMetadataClientDriver()\n            .getRegistrationClient()\n            .getAllBookies()\n            .get()\n            .getValue()\n            .size());\n\n    // test invalid rack name\n    // use rack aware placement policy\n    String errorMsg = \"Bookie 'rack' parameter is invalid, When `RackawareEnsemblePlacementPolicy` is enabled, \"\n        + \"the rack name is not allowed to contain slash (`/`) except for the beginning and end of the rack name \"\n        + \"string. When `RegionawareEnsemblePlacementPolicy` is enabled, the rack name can only contain \"\n        + \"one slash (`/`) except for the beginning and end of the rack name string.\";\n\n    BookieInfo newInfo3 = BookieInfo.builder()\n        .rack(\"/rack/a\")\n        .hostname(\"127.0.0.2\")\n        .build();\n    try {\n        admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo3);\n        fail();\n    } catch (PulsarAdminException e) {\n        assertEquals(412, e.getStatusCode());\n        assertEquals(errorMsg, e.getMessage());\n    }\n\n    BookieInfo newInfo4 = BookieInfo.builder()\n        .rack(\"/rack\")\n        .hostname(\"127.0.0.2\")\n        .build();\n    try {\n        admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo4);\n    } catch (PulsarAdminException e) {\n        fail();\n    }\n\n    // enable region aware placement policy\n    ServiceConfiguration configuration = new ServiceConfiguration();\n    configuration.setBookkeeperClientRegionawarePolicyEnabled(true);\n    doReturn(configuration).when(pulsar).getConfiguration();\n    BookieInfo newInfo5 = BookieInfo.builder()\n        .rack(\"/region/rack/a\")\n        .hostname(\"127.0.0.2\")\n        .build();\n    try {\n        admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo5);\n        fail();\n    } catch (PulsarAdminException e) {\n        assertEquals(412, e.getStatusCode());\n        assertEquals(errorMsg, e.getMessage());\n    }\n\n    BookieInfo newInfo6 = BookieInfo.builder()\n        .rack(\"/region/rack/\")\n        .hostname(\"127.0.0.2\")\n        .build();\n    try {\n        admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo6);\n    } catch (PulsarAdminException e) {\n        fail();\n    }\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testBasic() throws Exception {\n    // no map\n    BookiesRackConfiguration conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n    assertTrue(conf.isEmpty());\n\n    String bookie0 = \"127.0.0.1:3181\";\n    String bookie1 = \"127.0.0.2:3181\";\n\n    // get bookie doesn't exist\n    try {\n        admin.bookies().getBookieRackInfo(bookie0);\n        fail(\"should not reach here\");\n    } catch (PulsarAdminException pae) {\n        assertEquals(404, pae.getStatusCode());\n    }\n\n    // update the bookie info\n    BookieInfo newInfo0 = BookieInfo.builder()\n            .rack(\"/rack1\")\n            .hostname(\"127.0.0.1\")\n            .build();\n    BookieInfo newInfo1 = BookieInfo.builder()\n            .rack(\"/rack1\")\n            .hostname(\"127.0.0.2\")\n            .build();\n    admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo0);\n    BookieInfo readInfo0 = admin.bookies().getBookieRackInfo(bookie0);\n    assertEquals(newInfo0, readInfo0);\n    conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n    // number of groups\n    assertEquals(1, conf.size());\n    assertEquals(Optional.of(newInfo0), conf.getBookie(bookie0));\n\n    admin.bookies().updateBookieRackInfo(bookie1, \"default\", newInfo1);\n    BookieInfo readInfo1 = admin.bookies().getBookieRackInfo(bookie1);\n    assertEquals(newInfo1, readInfo1);\n    conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n    // number of groups\n    assertEquals(1, conf.size());\n    assertEquals(Optional.of(newInfo0), conf.getBookie(bookie0));\n    assertEquals(Optional.of(newInfo1), conf.getBookie(bookie1));\n\n    admin.bookies().deleteBookieRackInfo(bookie0);\n    try {\n        admin.bookies().getBookieRackInfo(bookie0);\n        fail(\"should not reach here\");\n    } catch (PulsarAdminException pae) {\n        assertEquals(404, pae.getStatusCode());\n    }\n    assertEquals(newInfo1, admin.bookies().getBookieRackInfo(bookie1));\n\n    admin.bookies().deleteBookieRackInfo(bookie1);\n    try {\n        admin.bookies().getBookieRackInfo(bookie1);\n        fail(\"should not reach here\");\n    } catch (PulsarAdminException pae) {\n        assertEquals(404, pae.getStatusCode());\n    }\n\n    conf = (BookiesRackConfiguration) admin.bookies().getBookiesRackInfo();\n    assertTrue(conf.isEmpty());\n\n    BookiesClusterInfo bookies = admin.bookies().getBookies();\n    log.info(\"bookies info {}\", bookies);\n    assertEquals(bookies.getBookies().size(),\n            pulsar.getBookKeeperClient()\n            .getMetadataClientDriver()\n            .getRegistrationClient()\n            .getAllBookies()\n            .get()\n            .getValue()\n            .size());\n\n    // test invalid rack name\n    // use rack aware placement policy\n    String errorMsg = \"Bookie 'rack' parameter is invalid, When `RackawareEnsemblePlacementPolicy` is enabled, \"\n        + \"the rack name is not allowed to contain slash (`/`) except for the beginning and end of the rack name \"\n        + \"string. When `RegionawareEnsemblePlacementPolicy` is enabled, the rack name can only contain \"\n        + \"one slash (`/`) except for the beginning and end of the rack name string.\";\n\n    BookieInfo newInfo3 = BookieInfo.builder()\n        .rack(\"/rack/a\")\n        .hostname(\"127.0.0.2\")\n        .build();\n    try {\n        admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo3);\n        fail();\n    } catch (PulsarAdminException e) {\n        assertEquals(412, e.getStatusCode());\n        assertEquals(errorMsg, e.getMessage());\n    }\n\n    BookieInfo newInfo4 = BookieInfo.builder()\n        .rack(\"/rack\")\n        .hostname(\"127.0.0.2\")\n        .build();\n    try {\n        admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo4);\n    } catch (PulsarAdminException e) {\n        fail();\n    }\n\n    // enable region aware placement policy\n    ServiceConfiguration configuration = new ServiceConfiguration();\n    configuration.setBookkeeperClientRegionawarePolicyEnabled(true);\n    doReturn(configuration).when(pulsar).getConfiguration();\n    BookieInfo newInfo5 = BookieInfo.builder()\n        .rack(\"/region/rack/a\")\n        .hostname(\"127.0.0.2\")\n        .build();\n    try {\n        admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo5);\n        fail();\n    } catch (PulsarAdminException e) {\n        assertEquals(412, e.getStatusCode());\n        assertEquals(errorMsg, e.getMessage());\n    }\n\n    BookieInfo newInfo6 = BookieInfo.builder()\n        .rack(\"/region/rack/\")\n        .hostname(\"127.0.0.2\")\n        .build();\n    try {\n        admin.bookies().updateBookieRackInfo(bookie0, \"default\", newInfo6);\n    } catch (PulsarAdminException e) {\n        fail();\n    }\n}\n"
    ]
  },
  "6": {
    "commit_src": "f3f5fbc27391e13ab76b0f2265f51ac3a5c0a90c",
    "commit_tgt": "b5925ede2ef5652e36f252ab74a3463b8b3bfaf4",
    "changed_tests": [
      "pulsar-broker/src/test/java/org/apache/pulsar/broker/transaction/TransactionTest.java",
      "pulsar-broker/src/test/java/org/apache/pulsar/compaction/CompactedTopicUtilsTest.java"
    ],
    "refer_PR": "apache_pulsar-21465",
    "test_src": ".org.apache.pulsar.compaction.CompactedTopicUtilsTest#testReadCompactedEntriesWithEmptyEntries",
    "test_tgt": [
      ".org.apache.pulsar.compaction.CompactedTopicUtilsTest#testReadCompactedEntriesWithEmptyEntries"
    ],
    "test_src_code": "    @Test\n    public void testReadCompactedEntriesWithEmptyEntries() throws ExecutionException, InterruptedException {\n        PositionImpl lastCompactedPosition = PositionImpl.get(1, 100);\n        TopicCompactionService service = Mockito.mock(TopicCompactionService.class);\n        Mockito.doReturn(CompletableFuture.completedFuture(Collections.emptyList()))\n                .when(service).readCompactedEntries(Mockito.any(), Mockito.intThat(argument -> argument > 0));\n        Mockito.doReturn(CompletableFuture.completedFuture(lastCompactedPosition)).when(service)\n                .getLastCompactedPosition();\n\n\n        PositionImpl initPosition = PositionImpl.get(1, 90);\n        AtomicReference<PositionImpl> readPositionRef = new AtomicReference<>(initPosition.getNext());\n        ManagedCursorImpl cursor = Mockito.mock(ManagedCursorImpl.class);\n        Mockito.doReturn(readPositionRef.get()).when(cursor).getReadPosition();\n        Mockito.doReturn(1).when(cursor).applyMaxSizeCap(Mockito.anyInt(), Mockito.anyLong());\n        Mockito.doAnswer(invocation -> {\n            readPositionRef.set(invocation.getArgument(0));\n            return null;\n        }).when(cursor).seek(Mockito.any());\n\n        CompletableFuture<List<Entry>> completableFuture = new CompletableFuture<>();\n        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n        AsyncCallbacks.ReadEntriesCallback readEntriesCallback = new AsyncCallbacks.ReadEntriesCallback() {\n            @Override\n            public void readEntriesComplete(List<Entry> entries, Object ctx) {\n                completableFuture.complete(entries);\n            }\n\n            @Override\n            public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n                completableFuture.completeExceptionally(exception);\n                throwableRef.set(exception);\n            }\n        };\n\n        CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100, false,\n                readEntriesCallback, false, null);\n\n        List<Entry> entries = completableFuture.get();\n        Assert.assertTrue(entries.isEmpty());\n        Assert.assertNull(throwableRef.get());\n        Assert.assertEquals(readPositionRef.get(), lastCompactedPosition.getNext());\n    }\n",
    "test_tgt_code": "    @Test\n    public void testReadCompactedEntriesWithEmptyEntries() throws ExecutionException, InterruptedException {\n        PositionImpl lastCompactedPosition = PositionImpl.get(1, 100);\n        TopicCompactionService service = Mockito.mock(TopicCompactionService.class);\n        Mockito.doReturn(CompletableFuture.completedFuture(Collections.emptyList()))\n                .when(service).readCompactedEntries(Mockito.any(), Mockito.intThat(argument -> argument > 0));\n        Mockito.doReturn(CompletableFuture.completedFuture(lastCompactedPosition)).when(service)\n                .getLastCompactedPosition();\n\n\n        PositionImpl initPosition = PositionImpl.get(1, 90);\n        AtomicReference<PositionImpl> readPositionRef = new AtomicReference<>(initPosition.getNext());\n        ManagedCursorImpl cursor = Mockito.mock(ManagedCursorImpl.class);\n        Mockito.doReturn(readPositionRef.get()).when(cursor).getReadPosition();\n        Mockito.doReturn(1).when(cursor).applyMaxSizeCap(Mockito.anyInt(), Mockito.anyLong());\n        Mockito.doAnswer(invocation -> {\n            readPositionRef.set(invocation.getArgument(0));\n            return null;\n        }).when(cursor).seek(Mockito.any());\n\n        CompletableFuture<List<Entry>> completableFuture = new CompletableFuture<>();\n        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n        AsyncCallbacks.ReadEntriesCallback readEntriesCallback = new AsyncCallbacks.ReadEntriesCallback() {\n            @Override\n            public void readEntriesComplete(List<Entry> entries, Object ctx) {\n                completableFuture.complete(entries);\n            }\n\n            @Override\n            public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n                completableFuture.completeExceptionally(exception);\n                throwableRef.set(exception);\n            }\n        };\n\n        CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100,\n                PositionImpl.LATEST, false, readEntriesCallback, false, null);\n\n        List<Entry> entries = completableFuture.get();\n        Assert.assertTrue(entries.isEmpty());\n        Assert.assertNull(throwableRef.get());\n        Assert.assertEquals(readPositionRef.get(), lastCompactedPosition.getNext());\n    }\n",
    "focal_path_src": [
      "pulsar-broker/src/main/java/org/apache/pulsar/compaction/CompactedTopicUtils.java#asyncReadCompactedEntries"
    ],
    "focal_path_tgt": [
      "pulsar-broker/src/main/java/org/apache/pulsar/compaction/CompactedTopicUtils.java#asyncReadCompactedEntries"
    ],
    "focal_src": [
      "    @Beta\n    public static void asyncReadCompactedEntries(TopicCompactionService topicCompactionService,\n                                                 ManagedCursor cursor, int maxEntries,\n                                                 long bytesToRead, boolean readFromEarliest,\n                                                 AsyncCallbacks.ReadEntriesCallback callback,\n                                                 boolean wait, @Nullable Consumer consumer) {\n        Objects.requireNonNull(topicCompactionService);\n        Objects.requireNonNull(cursor);\n        checkArgument(maxEntries > 0);\n        Objects.requireNonNull(callback);\n\n        final PositionImpl readPosition;\n        if (readFromEarliest) {\n            readPosition = PositionImpl.EARLIEST;\n        } else {\n            readPosition = (PositionImpl) cursor.getReadPosition();\n        }\n\n        // TODO: redeliver epoch link https://github.com/apache/pulsar/issues/13690\n        PersistentDispatcherSingleActiveConsumer.ReadEntriesCtx readEntriesCtx =\n                PersistentDispatcherSingleActiveConsumer.ReadEntriesCtx.create(consumer, DEFAULT_CONSUMER_EPOCH);\n\n        CompletableFuture<Position> lastCompactedPositionFuture = topicCompactionService.getLastCompactedPosition();\n\n        lastCompactedPositionFuture.thenCompose(lastCompactedPosition -> {\n            if (lastCompactedPosition == null\n                    || readPosition.compareTo(\n                    lastCompactedPosition.getLedgerId(), lastCompactedPosition.getEntryId()) > 0) {\n                if (wait) {\n                    cursor.asyncReadEntriesOrWait(maxEntries, bytesToRead, callback, readEntriesCtx,\n                        PositionImpl.LATEST);\n                } else {\n                    cursor.asyncReadEntries(maxEntries, bytesToRead, callback, readEntriesCtx,\n                        PositionImpl.LATEST);\n                }\n                return CompletableFuture.completedFuture(null);\n            }\n\n            ManagedCursorImpl managedCursor = (ManagedCursorImpl) cursor;\n            int numberOfEntriesToRead = managedCursor.applyMaxSizeCap(maxEntries, bytesToRead);\n\n            return topicCompactionService.readCompactedEntries(readPosition, numberOfEntriesToRead)\n                    .thenAccept(entries -> {\n                        if (CollectionUtils.isEmpty(entries)) {\n                            Position seekToPosition = lastCompactedPosition.getNext();\n                            if (readPosition.compareTo(seekToPosition.getLedgerId(), seekToPosition.getEntryId()) > 0) {\n                                seekToPosition = readPosition;\n                            }\n                            cursor.seek(seekToPosition);\n                            callback.readEntriesComplete(Collections.emptyList(), readEntriesCtx);\n                            return;\n                        }\n\n                        long entriesSize = 0;\n                        for (Entry entry : entries) {\n                            entriesSize += entry.getLength();\n                        }\n                        managedCursor.updateReadStats(entries.size(), entriesSize);\n\n                        Entry lastEntry = entries.get(entries.size() - 1);\n                        cursor.seek(lastEntry.getPosition().getNext(), true);\n                        callback.readEntriesComplete(entries, readEntriesCtx);\n                    });\n        }).exceptionally((exception) -> {\n            exception = FutureUtil.unwrapCompletionException(exception);\n            ManagedLedgerException managedLedgerException;\n            if (exception instanceof ManagedLedgerException) {\n                managedLedgerException = (ManagedLedgerException) exception;\n            } else {\n                managedLedgerException = new ManagedLedgerException(exception);\n            }\n            callback.readEntriesFailed(managedLedgerException, readEntriesCtx);\n            return null;\n        });\n    }\n"
    ],
    "focal_tgt": [
      "    @Beta\n    public static void asyncReadCompactedEntries(TopicCompactionService topicCompactionService,\n                                                 ManagedCursor cursor, int maxEntries,\n                                                 long bytesToRead, PositionImpl maxReadPosition,\n                                                 boolean readFromEarliest, AsyncCallbacks.ReadEntriesCallback callback,\n                                                 boolean wait, @Nullable Consumer consumer) {\n        Objects.requireNonNull(topicCompactionService);\n        Objects.requireNonNull(cursor);\n        checkArgument(maxEntries > 0);\n        Objects.requireNonNull(callback);\n\n        final PositionImpl readPosition;\n        if (readFromEarliest) {\n            readPosition = PositionImpl.EARLIEST;\n        } else {\n            readPosition = (PositionImpl) cursor.getReadPosition();\n        }\n\n        // TODO: redeliver epoch link https://github.com/apache/pulsar/issues/13690\n        PersistentDispatcherSingleActiveConsumer.ReadEntriesCtx readEntriesCtx =\n                PersistentDispatcherSingleActiveConsumer.ReadEntriesCtx.create(consumer, DEFAULT_CONSUMER_EPOCH);\n\n        CompletableFuture<Position> lastCompactedPositionFuture = topicCompactionService.getLastCompactedPosition();\n\n        lastCompactedPositionFuture.thenCompose(lastCompactedPosition -> {\n            if (lastCompactedPosition == null\n                    || readPosition.compareTo(\n                    lastCompactedPosition.getLedgerId(), lastCompactedPosition.getEntryId()) > 0) {\n                if (wait) {\n                    cursor.asyncReadEntriesOrWait(maxEntries, bytesToRead, callback, readEntriesCtx, maxReadPosition);\n                } else {\n                    cursor.asyncReadEntries(maxEntries, bytesToRead, callback, readEntriesCtx, maxReadPosition);\n                }\n                return CompletableFuture.completedFuture(null);\n            }\n\n            ManagedCursorImpl managedCursor = (ManagedCursorImpl) cursor;\n            int numberOfEntriesToRead = managedCursor.applyMaxSizeCap(maxEntries, bytesToRead);\n\n            return topicCompactionService.readCompactedEntries(readPosition, numberOfEntriesToRead)\n                    .thenAccept(entries -> {\n                        if (CollectionUtils.isEmpty(entries)) {\n                            Position seekToPosition = lastCompactedPosition.getNext();\n                            if (readPosition.compareTo(seekToPosition.getLedgerId(), seekToPosition.getEntryId()) > 0) {\n                                seekToPosition = readPosition;\n                            }\n                            cursor.seek(seekToPosition);\n                            callback.readEntriesComplete(Collections.emptyList(), readEntriesCtx);\n                            return;\n                        }\n\n                        long entriesSize = 0;\n                        for (Entry entry : entries) {\n                            entriesSize += entry.getLength();\n                        }\n                        managedCursor.updateReadStats(entries.size(), entriesSize);\n\n                        Entry lastEntry = entries.get(entries.size() - 1);\n                        cursor.seek(lastEntry.getPosition().getNext(), true);\n                        callback.readEntriesComplete(entries, readEntriesCtx);\n                    });\n        }).exceptionally((exception) -> {\n            exception = FutureUtil.unwrapCompletionException(exception);\n            ManagedLedgerException managedLedgerException;\n            if (exception instanceof ManagedLedgerException) {\n                managedLedgerException = (ManagedLedgerException) exception;\n            } else {\n                managedLedgerException = new ManagedLedgerException(exception);\n            }\n            callback.readEntriesFailed(managedLedgerException, readEntriesCtx);\n            return null;\n        });\n    }\n"
    ],
    "test_id": 6,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testReadCompactedEntriesWithEmptyEntries() throws ExecutionException, InterruptedException {\n    PositionImpl lastCompactedPosition = PositionImpl.get(1, 100);\n    TopicCompactionService service = Mockito.mock(TopicCompactionService.class);\n    Mockito.doReturn(CompletableFuture.completedFuture(Collections.emptyList()))\n            .when(service).readCompactedEntries(Mockito.any(), Mockito.intThat(argument -> argument > 0));\n    Mockito.doReturn(CompletableFuture.completedFuture(lastCompactedPosition)).when(service)\n            .getLastCompactedPosition();\n\n\n    PositionImpl initPosition = PositionImpl.get(1, 90);\n    AtomicReference<PositionImpl> readPositionRef = new AtomicReference<>(initPosition.getNext());\n    ManagedCursorImpl cursor = Mockito.mock(ManagedCursorImpl.class);\n    Mockito.doReturn(readPositionRef.get()).when(cursor).getReadPosition();\n    Mockito.doReturn(1).when(cursor).applyMaxSizeCap(Mockito.anyInt(), Mockito.anyLong());\n    Mockito.doAnswer(invocation -> {\n        readPositionRef.set(invocation.getArgument(0));\n        return null;\n    }).when(cursor).seek(Mockito.any());\n\n    CompletableFuture<List<Entry>> completableFuture = new CompletableFuture<>();\n    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n    AsyncCallbacks.ReadEntriesCallback readEntriesCallback = new AsyncCallbacks.ReadEntriesCallback() {\n        @Override\n        public void readEntriesComplete(List<Entry> entries, Object ctx) {\n            completableFuture.complete(entries);\n        }\n\n        @Override\n        public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n            completableFuture.completeExceptionally(exception);\n            throwableRef.set(exception);\n        }\n    };\n\n    CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100, PositionImpl.LATEST, false,\n            readEntriesCallback, false, null);\n\n    List<Entry> entries = completableFuture.get();\n    Assert.assertTrue(entries.isEmpty());\n    Assert.assertNull(throwableRef.get());\n    Assert.assertEquals(readPositionRef.get(), lastCompactedPosition.getNext());\n}\n",
      "@Test\npublic void testReadCompactedEntriesWithEmptyEntries() throws ExecutionException, InterruptedException {\n    PositionImpl lastCompactedPosition = PositionImpl.get(1, 100);\n    TopicCompactionService service = Mockito.mock(TopicCompactionService.class);\n    Mockito.doReturn(CompletableFuture.completedFuture(Collections.emptyList()))\n            .when(service).readCompactedEntries(Mockito.any(), Mockito.intThat(argument -> argument > 0));\n    Mockito.doReturn(CompletableFuture.completedFuture(lastCompactedPosition)).when(service)\n            .getLastCompactedPosition();\n\n\n    PositionImpl initPosition = PositionImpl.get(1, 90);\n    AtomicReference<PositionImpl> readPositionRef = new AtomicReference<>(initPosition.getNext());\n    ManagedCursorImpl cursor = Mockito.mock(ManagedCursorImpl.class);\n    Mockito.doReturn(readPositionRef.get()).when(cursor).getReadPosition();\n    Mockito.doReturn(1).when(cursor).applyMaxSizeCap(Mockito.anyInt(), Mockito.anyLong());\n    Mockito.doAnswer(invocation -> {\n        readPositionRef.set(invocation.getArgument(0));\n        return null;\n    }).when(cursor).seek(Mockito.any());\n\n    CompletableFuture<List<Entry>> completableFuture = new CompletableFuture<>();\n    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n    AsyncCallbacks.ReadEntriesCallback readEntriesCallback = new AsyncCallbacks.ReadEntriesCallback() {\n        @Override\n        public void readEntriesComplete(List<Entry> entries, Object ctx) {\n            completableFuture.complete(entries);\n        }\n\n        @Override\n        public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n            completableFuture.completeExceptionally(exception);\n            throwableRef.set(exception);\n        }\n    };\n\n    CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100, PositionImpl.LATEST, false,\n            readEntriesCallback, false, null);\n\n    List<Entry> entries = completableFuture.get();\n    Assert.assertTrue(entries.isEmpty());\n    Assert.assertNull(throwableRef.get());\n    Assert.assertEquals(readPositionRef.get(), lastCompactedPosition.getNext());\n}\n",
      "@Test\npublic void testReadCompactedEntriesWithEmptyEntries() throws ExecutionException, InterruptedException {\n    PositionImpl lastCompactedPosition = PositionImpl.get(1, 100);\n    TopicCompactionService service = Mockito.mock(TopicCompactionService.class);\n    Mockito.doReturn(CompletableFuture.completedFuture(Collections.emptyList()))\n            .when(service).readCompactedEntries(Mockito.any(), Mockito.intThat(argument -> argument > 0));\n    Mockito.doReturn(CompletableFuture.completedFuture(lastCompactedPosition)).when(service)\n            .getLastCompactedPosition();\n\n    PositionImpl initPosition = PositionImpl.get(1, 90);\n    AtomicReference<PositionImpl> readPositionRef = new AtomicReference<>(initPosition.getNext());\n    ManagedCursorImpl cursor = Mockito.mock(ManagedCursorImpl.class);\n    Mockito.doReturn(readPositionRef.get()).when(cursor).getReadPosition();\n    Mockito.doReturn(1).when(cursor).applyMaxSizeCap(Mockito.anyInt(), Mockito.anyLong());\n    Mockito.doAnswer(invocation -> {\n        readPositionRef.set(invocation.getArgument(0));\n        return null;\n    }).when(cursor).seek(Mockito.any());\n\n    CompletableFuture<List<Entry>> completableFuture = new CompletableFuture<>();\n    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n    AsyncCallbacks.ReadEntriesCallback readEntriesCallback = new AsyncCallbacks.ReadEntriesCallback() {\n        @Override\n        public void readEntriesComplete(List<Entry> entries, Object ctx) {\n            completableFuture.complete(entries);\n        }\n\n        @Override\n        public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n            completableFuture.completeExceptionally(exception);\n            throwableRef.set(exception);\n        }\n    };\n\n    PositionImpl maxReadPosition = PositionImpl.get(1, 110);\n    CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100, maxReadPosition, false,\n            readEntriesCallback, false, null);\n\n    List<Entry> entries = completableFuture.get();\n    Assert.assertTrue(entries.isEmpty());\n    Assert.assertNull(throwableRef.get());\n    Assert.assertEquals(readPositionRef.get(), maxReadPosition);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testReadCompactedEntriesWithEmptyEntries() throws ExecutionException, InterruptedException {\n    PositionImpl lastCompactedPosition = PositionImpl.get(1, 100);\n    TopicCompactionService service = Mockito.mock(TopicCompactionService.class);\n    Mockito.doReturn(CompletableFuture.completedFuture(Collections.emptyList()))\n            .when(service).readCompactedEntries(Mockito.any(), Mockito.intThat(argument -> argument > 0));\n    Mockito.doReturn(CompletableFuture.completedFuture(lastCompactedPosition)).when(service)\n            .getLastCompactedPosition();\n\n\n    PositionImpl initPosition = PositionImpl.get(1, 90);\n    AtomicReference<PositionImpl> readPositionRef = new AtomicReference<>(initPosition.getNext());\n    ManagedCursorImpl cursor = Mockito.mock(ManagedCursorImpl.class);\n    Mockito.doReturn(readPositionRef.get()).when(cursor).getReadPosition();\n    Mockito.doReturn(1).when(cursor).applyMaxSizeCap(Mockito.anyInt(), Mockito.anyLong());\n    Mockito.doAnswer(invocation -> {\n        readPositionRef.set(invocation.getArgument(0));\n        return null;\n    }).when(cursor).seek(Mockito.any());\n\n    CompletableFuture<List<Entry>> completableFuture = new CompletableFuture<>();\n    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n    AsyncCallbacks.ReadEntriesCallback readEntriesCallback = new AsyncCallbacks.ReadEntriesCallback() {\n        @Override\n        public void readEntriesComplete(List<Entry> entries, Object ctx) {\n            completableFuture.complete(entries);\n        }\n\n        @Override\n        public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n            completableFuture.completeExceptionally(exception);\n            throwableRef.set(exception);\n        }\n    };\n\n    CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100, PositionImpl.LATEST, false,\n            readEntriesCallback, false, null);\n\n    List<Entry> entries = completableFuture.get();\n    Assert.assertTrue(entries.isEmpty());\n    Assert.assertNull(throwableRef.get());\n    Assert.assertEquals(readPositionRef.get(), lastCompactedPosition.getNext());\n    // Test case for when lastCompactedPosition is null\n    Mockito.doReturn(CompletableFuture.completedFuture(null)).when(service)\n            .getLastCompactedPosition();\n    CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100, PositionImpl.LATEST, false,\n            readEntriesCallback, false, null);\n    Assert.assertNull(throwableRef.get());\n    Assert.assertEquals(readPositionRef.get(), PositionImpl.EARLIEST);\n}\n",
      "@Test\npublic void testReadCompactedEntriesWithEmptyEntries() throws ExecutionException, InterruptedException {\n    PositionImpl lastCompactedPosition = PositionImpl.get(1, 100);\n    TopicCompactionService service = Mockito.mock(TopicCompactionService.class);\n    Mockito.doReturn(CompletableFuture.completedFuture(Collections.emptyList()))\n            .when(service).readCompactedEntries(Mockito.any(), Mockito.intThat(argument -> argument > 0));\n    Mockito.doReturn(CompletableFuture.completedFuture(lastCompactedPosition)).when(service)\n            .getLastCompactedPosition();\n\n\n    PositionImpl initPosition = PositionImpl.get(1, 90);\n    AtomicReference<PositionImpl> readPositionRef = new AtomicReference<>(initPosition.getNext());\n    ManagedCursorImpl cursor = Mockito.mock(ManagedCursorImpl.class);\n    Mockito.doReturn(readPositionRef.get()).when(cursor).getReadPosition();\n    Mockito.doReturn(1).when(cursor).applyMaxSizeCap(Mockito.anyInt(), Mockito.anyLong());\n    Mockito.doAnswer(invocation -> {\n        readPositionRef.set(invocation.getArgument(0));\n        return null;\n    }).when(cursor).seek(Mockito.any());\n\n    CompletableFuture<List<Entry>> completableFuture = new CompletableFuture<>();\n    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n    AsyncCallbacks.ReadEntriesCallback readEntriesCallback = new AsyncCallbacks.ReadEntriesCallback() {\n        @Override\n        public void readEntriesComplete(List<Entry> entries, Object ctx) {\n            completableFuture.complete(entries);\n        }\n\n        @Override\n        public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n            completableFuture.completeExceptionally(exception);\n            throwableRef.set(exception);\n        }\n    };\n\n    CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100, PositionImpl.LATEST, false,\n            readEntriesCallback, false, null);\n\n    List<Entry> entries = completableFuture.get();\n    Assert.assertTrue(entries.isEmpty());\n    Assert.assertNull(throwableRef.get());\n    Assert.assertEquals(readPositionRef.get(), lastCompactedPosition.getNext());\n    // Test case for when lastCompactedPosition is null\n    Mockito.doReturn(CompletableFuture.completedFuture(null)).when(service)\n            .getLastCompactedPosition();\n    CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100, PositionImpl.LATEST, false,\n            readEntriesCallback, false, null);\n    Assert.assertNull(throwableRef.get());\n    Assert.assertEquals(readPositionRef.get(), PositionImpl.EARLIEST);\n}\n",
      "@Test\npublic void testReadCompactedEntriesWithEmptyEntries() throws ExecutionException, InterruptedException {\n    PositionImpl lastCompactedPosition = PositionImpl.get(1, 100);\n    TopicCompactionService service = Mockito.mock(TopicCompactionService.class);\n    Mockito.doReturn(CompletableFuture.completedFuture(Collections.emptyList()))\n            .when(service).readCompactedEntries(Mockito.any(), Mockito.intThat(argument -> argument > 0));\n    Mockito.doReturn(CompletableFuture.completedFuture(lastCompactedPosition)).when(service)\n            .getLastCompactedPosition();\n\n    PositionImpl initPosition = PositionImpl.get(1, 90);\n    AtomicReference<PositionImpl> readPositionRef = new AtomicReference<>(initPosition.getNext());\n    ManagedCursorImpl cursor = Mockito.mock(ManagedCursorImpl.class);\n    Mockito.doReturn(readPositionRef.get()).when(cursor).getReadPosition();\n    Mockito.doReturn(1).when(cursor).applyMaxSizeCap(Mockito.anyInt(), Mockito.anyLong());\n    Mockito.doAnswer(invocation -> {\n        readPositionRef.set(invocation.getArgument(0));\n        return null;\n    }).when(cursor).seek(Mockito.any());\n\n    CompletableFuture<List<Entry>> completableFuture = new CompletableFuture<>();\n    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n    AsyncCallbacks.ReadEntriesCallback readEntriesCallback = new AsyncCallbacks.ReadEntriesCallback() {\n        @Override\n        public void readEntriesComplete(List<Entry> entries, Object ctx) {\n            completableFuture.complete(entries);\n        }\n\n        @Override\n        public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n            completableFuture.completeExceptionally(exception);\n            throwableRef.set(exception);\n        }\n    };\n\n    PositionImpl maxReadPosition = PositionImpl.get(1, 110);\n    CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100, maxReadPosition, false,\n            readEntriesCallback, false, null);\n\n    List<Entry> entries = completableFuture.get();\n    Assert.assertTrue(entries.isEmpty());\n    Assert.assertNull(throwableRef.get());\n    Assert.assertEquals(readPositionRef.get(), maxReadPosition);\n    // Test case for when last compacted position is null\n    Mockito.doReturn(CompletableFuture.completedFuture(null)).when(service)\n            .getLastCompactedPosition();\n    CompactedTopicUtils.asyncReadCompactedEntries(service, cursor, 1, 100, maxReadPosition, false,\n            readEntriesCallback, false, null);\n    Assert.assertNull(throwableRef.get());\n    Assert.assertEquals(readPositionRef.get(), initPosition.getNext());\n}\n"
    ]
  },
  "7": {
    "commit_src": "2e31e71098d63dfe111b225d8f8219ea05d1951f",
    "commit_tgt": "495b141c7bebc0356297546e9db88c9e087f5039",
    "changed_tests": [
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkConfigTest.java",
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkTest.java",
      "pulsar-io/solr/src/test/java/org/apache/pulsar/io/solr/SolrSinkConfigTest.java"
    ],
    "refer_PR": "apache_pulsar-21675",
    "test_src": ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#loadFromMapTest",
    "test_tgt": [
      ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#loadFromMapTest",
      ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#loadFromMapCredentialsFromSecretTest"
    ],
    "test_src_code": "    @Test\n    public final void loadFromMapTest() throws IOException {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"redisHosts\", \"localhost:6379\");\n        map.put(\"redisPassword\", \"fake@123\");\n        map.put(\"redisDatabase\", \"1\");\n        map.put(\"clientMode\", \"Standalone\");\n        map.put(\"operationTimeout\", \"2000\");\n        map.put(\"batchSize\", \"100\");\n        map.put(\"batchTimeMs\", \"1000\");\n        map.put(\"connectTimeout\", \"3000\");\n\n        RedisSinkConfig config = RedisSinkConfig.load(map);\n        assertNotNull(config);\n        assertEquals(config.getRedisHosts(), \"localhost:6379\");\n        assertEquals(config.getRedisPassword(), \"fake@123\");\n        assertEquals(config.getRedisDatabase(), Integer.parseInt(\"1\"));\n        assertEquals(config.getClientMode(), \"Standalone\");\n        assertEquals(config.getOperationTimeout(), Long.parseLong(\"2000\"));\n        assertEquals(config.getBatchSize(), Integer.parseInt(\"100\"));\n        assertEquals(config.getBatchTimeMs(), Long.parseLong(\"1000\"));\n        assertEquals(config.getConnectTimeout(), Long.parseLong(\"3000\"));\n    }\n",
    "test_tgt_code": "    @Test\n    public final void loadFromMapTest() throws IOException {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"redisHosts\", \"localhost:6379\");\n        map.put(\"redisPassword\", \"fake@123\");\n        map.put(\"redisDatabase\", \"1\");\n        map.put(\"clientMode\", \"Standalone\");\n        map.put(\"operationTimeout\", \"2000\");\n        map.put(\"batchSize\", \"100\");\n        map.put(\"batchTimeMs\", \"1000\");\n        map.put(\"connectTimeout\", \"3000\");\n\n        SinkContext sinkContext = Mockito.mock(SinkContext.class);\n        RedisSinkConfig config = RedisSinkConfig.load(map, sinkContext);\n        assertNotNull(config);\n        assertEquals(config.getRedisHosts(), \"localhost:6379\");\n        assertEquals(config.getRedisPassword(), \"fake@123\");\n        assertEquals(config.getRedisDatabase(), Integer.parseInt(\"1\"));\n        assertEquals(config.getClientMode(), \"Standalone\");\n        assertEquals(config.getOperationTimeout(), Long.parseLong(\"2000\"));\n        assertEquals(config.getBatchSize(), Integer.parseInt(\"100\"));\n        assertEquals(config.getBatchTimeMs(), Long.parseLong(\"1000\"));\n        assertEquals(config.getConnectTimeout(), Long.parseLong(\"3000\"));\n    }\n",
    "focal_path_src": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSinkConfig.java#load"
    ],
    "focal_path_tgt": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSinkConfig.java#load"
    ],
    "focal_src": [
      "    public static RedisSinkConfig load(Map<String, Object> map) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readValue(mapper.writeValueAsString(map), RedisSinkConfig.class);\n    }\n"
    ],
    "focal_tgt": [
      "    public static RedisSinkConfig load(Map<String, Object> map, SinkContext sinkContext) throws IOException {\n        return IOConfigUtils.loadWithSecrets(map, RedisSinkConfig.class, sinkContext);\n    }\n"
    ],
    "test_id": 7,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic final void loadFromMapTest() throws IOException {\n    Map<String, Object> map = new HashMap<String, Object>();\n    map.put(\"redisHosts\", \"localhost:6379\");\n    map.put(\"redisPassword\", \"fake@123\");\n    map.put(\"redisDatabase\", \"1\");\n    map.put(\"clientMode\", \"Standalone\");\n    map.put(\"operationTimeout\", \"2000\");\n    map.put(\"batchSize\", \"100\");\n    map.put(\"batchTimeMs\", \"1000\");\n    map.put(\"connectTimeout\", \"3000\");\n\n    RedisSinkConfig config = RedisSinkConfig.load(map);\n    assertNotNull(config);\n    assertEquals(config.getRedisHosts(), \"localhost:6379\");\n    assertEquals(config.getRedisPassword(), \"fake@123\");\n    assertEquals(config.getRedisDatabase(), Integer.parseInt(\"1\"));\n    assertEquals(config.getClientMode(), \"Standalone\");\n    assertEquals(config.getOperationTimeout(), Long.parseLong(\"2000\"));\n    assertEquals(config.getBatchSize(), Integer.parseInt(\"100\"));\n    assertEquals(config.getBatchTimeMs(), Long.parseLong(\"1000\"));\n    assertEquals(config.getConnectTimeout(), Long.parseLong(\"3000\"));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic final void loadFromMapTest() throws IOException {\n    Map<String, Object> map = new HashMap<String, Object>();\n    map.put(\"redisHosts\", \"localhost:6379\");\n    map.put(\"redisPassword\", \"fake@123\");\n    map.put(\"redisDatabase\", \"1\");\n    map.put(\"clientMode\", \"Standalone\");\n    map.put(\"operationTimeout\", \"2000\");\n    map.put(\"batchSize\", \"100\");\n    map.put(\"batchTimeMs\", \"1000\");\n    map.put(\"connectTimeout\", \"3000\");\n\n    RedisSinkConfig config = RedisSinkConfig.load(map);\n    assertNotNull(config);\n    assertEquals(config.getRedisHosts(), \"localhost:6379\");\n    assertEquals(config.getRedisPassword(), \"fake@123\");\n    assertEquals(config.getRedisDatabase(), Integer.parseInt(\"1\"));\n    assertEquals(config.getClientMode(), \"Standalone\");\n    assertEquals(config.getOperationTimeout(), Long.parseLong(\"2000\"));\n    assertEquals(config.getBatchSize(), Integer.parseInt(\"100\"));\n    assertEquals(config.getBatchTimeMs(), Long.parseLong(\"1000\"));\n    assertEquals(config.getConnectTimeout(), Long.parseLong(\"3000\"));\n}\n"
    ]
  },
  "8": {
    "commit_src": "2e31e71098d63dfe111b225d8f8219ea05d1951f",
    "commit_tgt": "495b141c7bebc0356297546e9db88c9e087f5039",
    "changed_tests": [
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkConfigTest.java",
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkTest.java",
      "pulsar-io/solr/src/test/java/org/apache/pulsar/io/solr/SolrSinkConfigTest.java"
    ],
    "refer_PR": "apache_pulsar-21675",
    "test_src": ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#validValidateTest",
    "test_tgt": [
      ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#loadFromMapCredentialsFromSecretTest",
      ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#validValidateTest"
    ],
    "test_src_code": "    @Test\n    public final void validValidateTest() throws IOException {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"redisHosts\", \"localhost:6379\");\n        map.put(\"redisPassword\", \"fake@123\");\n        map.put(\"redisDatabase\", \"1\");\n        map.put(\"clientMode\", \"Standalone\");\n        map.put(\"operationTimeout\", \"2000\");\n        map.put(\"batchSize\", \"100\");\n        map.put(\"batchTimeMs\", \"1000\");\n        map.put(\"connectTimeout\", \"3000\");\n\n        RedisSinkConfig config = RedisSinkConfig.load(map);\n        config.validate();\n    }\n",
    "test_tgt_code": "    @Test\n    public final void validValidateTest() throws IOException {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"redisHosts\", \"localhost:6379\");\n        map.put(\"redisPassword\", \"fake@123\");\n        map.put(\"redisDatabase\", \"1\");\n        map.put(\"clientMode\", \"Standalone\");\n        map.put(\"operationTimeout\", \"2000\");\n        map.put(\"batchSize\", \"100\");\n        map.put(\"batchTimeMs\", \"1000\");\n        map.put(\"connectTimeout\", \"3000\");\n\n        SinkContext sinkContext = Mockito.mock(SinkContext.class);\n        RedisSinkConfig config = RedisSinkConfig.load(map, sinkContext);\n        config.validate();\n    }\n",
    "focal_path_src": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSinkConfig.java#load"
    ],
    "focal_path_tgt": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSinkConfig.java#load"
    ],
    "focal_src": [
      "    public static RedisSinkConfig load(Map<String, Object> map) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readValue(mapper.writeValueAsString(map), RedisSinkConfig.class);\n    }\n"
    ],
    "focal_tgt": [
      "    public static RedisSinkConfig load(Map<String, Object> map, SinkContext sinkContext) throws IOException {\n        return IOConfigUtils.loadWithSecrets(map, RedisSinkConfig.class, sinkContext);\n    }\n"
    ],
    "test_id": 8,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic final void validValidateTest() throws IOException {\n    Map<String, Object> map = new HashMap<String, Object>();\n    map.put(\"redisHosts\", \"localhost:6379\");\n    map.put(\"redisPassword\", \"fake@123\");\n    map.put(\"redisDatabase\", \"1\");\n    map.put(\"clientMode\", \"Standalone\");\n    map.put(\"operationTimeout\", \"2000\");\n    map.put(\"batchSize\", \"100\");\n    map.put(\"batchTimeMs\", \"1000\");\n    map.put(\"connectTimeout\", \"3000\");\n\n    RedisSinkConfig config = RedisSinkConfig.load(map);\n    config.validate();\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic final void validValidateTest() throws IOException {\n    Map<String, Object> map = new HashMap<String, Object>();\n    map.put(\"redisHosts\", \"localhost:6379\");\n    map.put(\"redisPassword\", \"fake@123\");\n    map.put(\"redisDatabase\", \"1\");\n    map.put(\"clientMode\", \"Standalone\");\n    map.put(\"operationTimeout\", \"2000\");\n    map.put(\"batchSize\", \"100\");\n    map.put(\"batchTimeMs\", \"1000\");\n    map.put(\"connectTimeout\", \"3000\");\n\n    RedisSinkConfig config = RedisSinkConfig.load(map);\n    config.validate();\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "FileNotFoundError(2, 'No such file or directory')"
  },
  "9": {
    "commit_src": "2e31e71098d63dfe111b225d8f8219ea05d1951f",
    "commit_tgt": "495b141c7bebc0356297546e9db88c9e087f5039",
    "changed_tests": [
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkConfigTest.java",
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkTest.java",
      "pulsar-io/solr/src/test/java/org/apache/pulsar/io/solr/SolrSinkConfigTest.java"
    ],
    "refer_PR": "apache_pulsar-21675",
    "test_src": ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#missingValidValidateTableNameTest",
    "test_tgt": [
      ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#loadFromMapCredentialsFromSecretTest",
      ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#missingValidValidateTableNameTest"
    ],
    "test_src_code": "    public final void missingValidValidateTableNameTest() throws IOException {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"redisPassword\", \"fake@123\");\n        map.put(\"redisDatabase\", \"1\");\n        map.put(\"clientMode\", \"Standalone\");\n        map.put(\"operationTimeout\", \"2000\");\n        map.put(\"batchSize\", \"100\");\n        map.put(\"batchTimeMs\", \"1000\");\n        map.put(\"connectTimeout\", \"3000\");\n\n        RedisSinkConfig config = RedisSinkConfig.load(map);\n        config.validate();\n    }\n",
    "test_tgt_code": "    public final void missingValidValidateTableNameTest() throws IOException {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"redisPassword\", \"fake@123\");\n        map.put(\"redisDatabase\", \"1\");\n        map.put(\"clientMode\", \"Standalone\");\n        map.put(\"operationTimeout\", \"2000\");\n        map.put(\"batchSize\", \"100\");\n        map.put(\"batchTimeMs\", \"1000\");\n        map.put(\"connectTimeout\", \"3000\");\n\n        SinkContext sinkContext = Mockito.mock(SinkContext.class);\n        RedisSinkConfig config = RedisSinkConfig.load(map, sinkContext);\n        config.validate();\n    }\n",
    "focal_path_src": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSinkConfig.java#load"
    ],
    "focal_path_tgt": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSinkConfig.java#load"
    ],
    "focal_src": [
      "    public static RedisSinkConfig load(Map<String, Object> map) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readValue(mapper.writeValueAsString(map), RedisSinkConfig.class);\n    }\n"
    ],
    "focal_tgt": [
      "    public static RedisSinkConfig load(Map<String, Object> map, SinkContext sinkContext) throws IOException {\n        return IOConfigUtils.loadWithSecrets(map, RedisSinkConfig.class, sinkContext);\n    }\n"
    ],
    "test_id": 9,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\npublic final void missingValidValidateTableNameTest() throws IOException {\n    Map<String, Object> map = new HashMap<String, Object>();\n    map.put(\"redisPassword\", \"fake@123\");\n    map.put(\"redisDatabase\", \"1\");\n    map.put(\"clientMode\", \"Standalone\");\n    map.put(\"operationTimeout\", \"2000\");\n    map.put(\"batchSize\", \"100\");\n    map.put(\"batchTimeMs\", \"1000\");\n    map.put(\"connectTimeout\", \"3000\");\n\n    RedisSinkConfig config = RedisSinkConfig.load(map);\n    config.validate();\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\npublic final void missingValidValidateTableNameTest() throws IOException {\n    Map<String, Object> map = new HashMap<String, Object>();\n    map.put(\"redisPassword\", \"fake@123\");\n    map.put(\"redisDatabase\", \"1\");\n    map.put(\"clientMode\", \"Standalone\");\n    map.put(\"operationTimeout\", \"2000\");\n    map.put(\"batchSize\", \"100\");\n    map.put(\"batchTimeMs\", \"1000\");\n    map.put(\"connectTimeout\", \"3000\");\n\n    RedisSinkConfig config = RedisSinkConfig.load(map);\n    config.validate();\n}\n"
    ]
  },
  "10": {
    "commit_src": "2e31e71098d63dfe111b225d8f8219ea05d1951f",
    "commit_tgt": "495b141c7bebc0356297546e9db88c9e087f5039",
    "changed_tests": [
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkConfigTest.java",
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkTest.java",
      "pulsar-io/solr/src/test/java/org/apache/pulsar/io/solr/SolrSinkConfigTest.java"
    ],
    "refer_PR": "apache_pulsar-21675",
    "test_src": ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#invalidBatchTimeMsTest",
    "test_tgt": [
      ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#loadFromMapCredentialsFromSecretTest",
      ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#invalidBatchTimeMsTest"
    ],
    "test_src_code": "    public final void invalidBatchTimeMsTest() throws IOException {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"redisHosts\", \"localhost:6379\");\n        map.put(\"redisPassword\", \"fake@123\");\n        map.put(\"redisDatabase\", \"1\");\n        map.put(\"clientMode\", \"Standalone\");\n        map.put(\"operationTimeout\", \"2000\");\n        map.put(\"batchSize\", \"100\");\n        map.put(\"batchTimeMs\", \"-100\");\n        map.put(\"connectTimeout\", \"3000\");\n\n        RedisSinkConfig config = RedisSinkConfig.load(map);\n        config.validate();\n    }\n",
    "test_tgt_code": "    public final void invalidBatchTimeMsTest() throws IOException {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"redisHosts\", \"localhost:6379\");\n        map.put(\"redisPassword\", \"fake@123\");\n        map.put(\"redisDatabase\", \"1\");\n        map.put(\"clientMode\", \"Standalone\");\n        map.put(\"operationTimeout\", \"2000\");\n        map.put(\"batchSize\", \"100\");\n        map.put(\"batchTimeMs\", \"-100\");\n        map.put(\"connectTimeout\", \"3000\");\n\n        SinkContext sinkContext = Mockito.mock(SinkContext.class);\n        RedisSinkConfig config = RedisSinkConfig.load(map, sinkContext);\n        config.validate();\n    }\n",
    "focal_path_src": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSinkConfig.java#load"
    ],
    "focal_path_tgt": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSinkConfig.java#load"
    ],
    "focal_src": [
      "    public static RedisSinkConfig load(Map<String, Object> map) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readValue(mapper.writeValueAsString(map), RedisSinkConfig.class);\n    }\n"
    ],
    "focal_tgt": [
      "    public static RedisSinkConfig load(Map<String, Object> map, SinkContext sinkContext) throws IOException {\n        return IOConfigUtils.loadWithSecrets(map, RedisSinkConfig.class, sinkContext);\n    }\n"
    ],
    "test_id": 10,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\npublic final void invalidBatchTimeMsTest() throws IOException {\n    Map<String, Object> map = new HashMap<String, Object>();\n    map.put(\"redisHosts\", \"localhost:6379\");\n    map.put(\"redisPassword\", \"fake@123\");\n    map.put(\"redisDatabase\", \"1\");\n    map.put(\"clientMode\", \"Standalone\");\n    map.put(\"operationTimeout\", \"2000\");\n    map.put(\"batchSize\", \"100\");\n    map.put(\"batchTimeMs\", \"-100\");\n    map.put(\"connectTimeout\", \"3000\");\n\n    RedisSinkConfig config = RedisSinkConfig.load(map);\n    config.validate();\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\npublic final void invalidBatchTimeMsTest() throws IOException {\n    Map<String, Object> map = new HashMap<String, Object>();\n    map.put(\"redisHosts\", \"localhost:6379\");\n    map.put(\"redisPassword\", \"fake@123\");\n    map.put(\"redisDatabase\", \"1\");\n    map.put(\"clientMode\", \"Standalone\");\n    map.put(\"operationTimeout\", \"2000\");\n    map.put(\"batchSize\", \"100\");\n    map.put(\"batchTimeMs\", \"-100\");\n    map.put(\"connectTimeout\", \"3000\");\n\n    RedisSinkConfig config = RedisSinkConfig.load(map);\n    config.validate();\n}\n"
    ]
  },
  "11": {
    "commit_src": "2e31e71098d63dfe111b225d8f8219ea05d1951f",
    "commit_tgt": "495b141c7bebc0356297546e9db88c9e087f5039",
    "changed_tests": [
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkConfigTest.java",
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkTest.java",
      "pulsar-io/solr/src/test/java/org/apache/pulsar/io/solr/SolrSinkConfigTest.java"
    ],
    "refer_PR": "apache_pulsar-21675",
    "test_src": ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#invalidClientModeTest",
    "test_tgt": [
      ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#loadFromMapCredentialsFromSecretTest",
      ".org.apache.pulsar.io.redis.sink.RedisSinkConfigTest#invalidClientModeTest"
    ],
    "test_src_code": "    public final void invalidClientModeTest() throws IOException {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"redisHosts\", \"localhost:6379\");\n        map.put(\"redisPassword\", \"fake@123\");\n        map.put(\"redisDatabase\", \"1\");\n        map.put(\"clientMode\", \"NotSupport\");\n        map.put(\"operationTimeout\", \"2000\");\n        map.put(\"batchSize\", \"100\");\n        map.put(\"batchTimeMs\", \"1000\");\n        map.put(\"connectTimeout\", \"3000\");\n\n        RedisSinkConfig config = RedisSinkConfig.load(map);\n        config.validate();\n\n        RedisAbstractConfig.ClientMode.valueOf(config.getClientMode().toUpperCase());\n    }\n",
    "test_tgt_code": "    public final void invalidClientModeTest() throws IOException {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"redisHosts\", \"localhost:6379\");\n        map.put(\"redisPassword\", \"fake@123\");\n        map.put(\"redisDatabase\", \"1\");\n        map.put(\"clientMode\", \"NotSupport\");\n        map.put(\"operationTimeout\", \"2000\");\n        map.put(\"batchSize\", \"100\");\n        map.put(\"batchTimeMs\", \"1000\");\n        map.put(\"connectTimeout\", \"3000\");\n\n        SinkContext sinkContext = Mockito.mock(SinkContext.class);\n        RedisSinkConfig config = RedisSinkConfig.load(map, sinkContext);\n        config.validate();\n\n        RedisAbstractConfig.ClientMode.valueOf(config.getClientMode().toUpperCase());\n    }\n",
    "focal_path_src": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSinkConfig.java#load"
    ],
    "focal_path_tgt": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSinkConfig.java#load"
    ],
    "focal_src": [
      "    public static RedisSinkConfig load(Map<String, Object> map) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readValue(mapper.writeValueAsString(map), RedisSinkConfig.class);\n    }\n"
    ],
    "focal_tgt": [
      "    public static RedisSinkConfig load(Map<String, Object> map, SinkContext sinkContext) throws IOException {\n        return IOConfigUtils.loadWithSecrets(map, RedisSinkConfig.class, sinkContext);\n    }\n"
    ],
    "test_id": 11,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\npublic final void invalidClientModeTest() throws IOException {\n    Map<String, Object> map = new HashMap<String, Object>();\n    map.put(\"redisHosts\", \"localhost:6379\");\n    map.put(\"redisPassword\", \"fake@123\");\n    map.put(\"redisDatabase\", \"1\");\n    map.put(\"clientMode\", \"NotSupport\");\n    map.put(\"operationTimeout\", \"2000\");\n    map.put(\"batchSize\", \"100\");\n    map.put(\"batchTimeMs\", \"1000\");\n    map.put(\"connectTimeout\", \"3000\");\n\n    RedisSinkConfig config = RedisSinkConfig.load(map);\n    config.validate();\n\n    RedisAbstractConfig.ClientMode.valueOf(config.getClientMode().toUpperCase());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\npublic final void invalidClientModeTest() throws IOException {\n    Map<String, Object> map = new HashMap<String, Object>();\n    map.put(\"redisHosts\", \"localhost:6379\");\n    map.put(\"redisPassword\", \"fake@123\");\n    map.put(\"redisDatabase\", \"1\");\n    map.put(\"clientMode\", \"NotSupport\");\n    map.put(\"operationTimeout\", \"2000\");\n    map.put(\"batchSize\", \"100\");\n    map.put(\"batchTimeMs\", \"1000\");\n    map.put(\"connectTimeout\", \"3000\");\n\n    RedisSinkConfig config = RedisSinkConfig.load(map);\n    config.validate();\n\n    RedisAbstractConfig.ClientMode.valueOf(config.getClientMode().toUpperCase());\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "FileNotFoundError(2, 'No such file or directory')"
  },
  "12": {
    "commit_src": "2e31e71098d63dfe111b225d8f8219ea05d1951f",
    "commit_tgt": "495b141c7bebc0356297546e9db88c9e087f5039",
    "changed_tests": [
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkConfigTest.java",
      "pulsar-io/redis/src/test/java/org/apache/pulsar/io/redis/sink/RedisSinkTest.java",
      "pulsar-io/solr/src/test/java/org/apache/pulsar/io/solr/SolrSinkConfigTest.java"
    ],
    "refer_PR": "apache_pulsar-21675",
    "test_src": ".org.apache.pulsar.io.redis.sink.RedisSinkTest#TestOpenAndWriteSink",
    "test_tgt": [
      ".org.apache.pulsar.io.redis.sink.RedisSinkTest#TestOpenAndWriteSink"
    ],
    "test_src_code": "    @Test\n    public void TestOpenAndWriteSink() throws Exception {\n        Map<String, Object> configs = new HashMap<>();\n        configs.put(\"redisHosts\", \"localhost:6379\");\n        configs.put(\"redisPassword\", \"\");\n        configs.put(\"redisDatabase\", \"1\");\n        configs.put(\"clientMode\", \"Standalone\");\n        configs.put(\"operationTimeout\", \"3000\");\n        configs.put(\"batchSize\", \"10\");\n\n        RedisSink sink = new RedisSink();\n\n        // prepare a foo Record\n        Record<byte[]> record = build(\"fakeTopic\", \"fakeKey\", \"fakeValue\");\n\n        // open should success\n        sink.open(configs, null);\n\n        // write should success.\n        sink.write(record);\n        log.info(\"executed write\");\n\n        // sleep to wait backend flush complete\n        Thread.sleep(1000);\n\n    }\n",
    "test_tgt_code": "    @Test\n    public void TestOpenAndWriteSink() throws Exception {\n        Map<String, Object> configs = new HashMap<>();\n        configs.put(\"redisHosts\", \"localhost:6379\");\n        configs.put(\"redisPassword\", \"\");\n        configs.put(\"redisDatabase\", \"1\");\n        configs.put(\"clientMode\", \"Standalone\");\n        configs.put(\"operationTimeout\", \"3000\");\n        configs.put(\"batchSize\", \"10\");\n\n        RedisSink sink = new RedisSink();\n\n        // prepare a foo Record\n        Record<byte[]> record = build(\"fakeTopic\", \"fakeKey\", \"fakeValue\");\n\n        // open should success\n        SinkContext sinkContext = Mockito.mock(SinkContext.class);\n        sink.open(configs, sinkContext);\n\n        // write should success.\n        sink.write(record);\n        log.info(\"executed write\");\n\n        // sleep to wait backend flush complete\n        Thread.sleep(1000);\n\n    }\n",
    "focal_path_src": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSink.java#open"
    ],
    "focal_path_tgt": [
      "pulsar-io/redis/src/main/java/org/apache/pulsar/io/redis/sink/RedisSink.java#open"
    ],
    "focal_src": [
      "    @Override\n    public void open(Map<String, Object> config, SinkContext sinkContext) throws Exception {\n        log.info(\"Open Redis Sink\");\n\n        redisSinkConfig = RedisSinkConfig.load(config);\n        redisSinkConfig.validate();\n\n        redisSession = RedisSession.create(redisSinkConfig);\n\n        operationTimeoutMs = redisSinkConfig.getOperationTimeout();\n\n        batchTimeMs = redisSinkConfig.getBatchTimeMs();\n        batchSize = redisSinkConfig.getBatchSize();\n        incomingList = Lists.newArrayList();\n        flushExecutor = Executors.newScheduledThreadPool(1);\n        flushExecutor.scheduleAtFixedRate(this::flush, batchTimeMs, batchTimeMs, TimeUnit.MILLISECONDS);\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public void open(Map<String, Object> config, SinkContext sinkContext) throws Exception {\n        log.info(\"Open Redis Sink\");\n\n        redisSinkConfig = RedisSinkConfig.load(config, sinkContext);\n        redisSinkConfig.validate();\n\n        redisSession = RedisSession.create(redisSinkConfig);\n\n        operationTimeoutMs = redisSinkConfig.getOperationTimeout();\n\n        batchTimeMs = redisSinkConfig.getBatchTimeMs();\n        batchSize = redisSinkConfig.getBatchSize();\n        incomingList = Lists.newArrayList();\n        flushExecutor = Executors.newScheduledThreadPool(1);\n        flushExecutor.scheduleAtFixedRate(this::flush, batchTimeMs, batchTimeMs, TimeUnit.MILLISECONDS);\n    }\n"
    ],
    "test_id": 12,
    "identify_result_deepseek-coder": false
  },
  "13": {
    "commit_src": "beed0cfc52e566f3a5293f7ea37fdcc6e334b0f0",
    "commit_tgt": "7e73967f9daf368562fa0318d4ecb62272d72174",
    "changed_tests": [
      "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/ConsistentHashingStickyKeyConsumerSelectorTest.java",
      "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/persistent/PersistentStickyKeyDispatcherMultipleConsumersTest.java"
    ],
    "refer_PR": "apache_pulsar-22053",
    "test_src": ".org.apache.pulsar.broker.service.ConsistentHashingStickyKeyConsumerSelectorTest#testGetConsumerKeyHashRanges",
    "test_tgt": [
      ".org.apache.pulsar.broker.service.ConsistentHashingStickyKeyConsumerSelectorTest#testGetConsumerKeyHashRanges",
      ".org.apache.pulsar.broker.service.ConsistentHashingStickyKeyConsumerSelectorTest#shouldNotCollideWithConsumerNameEndsWithNumber",
      ".org.apache.pulsar.broker.service.ConsistentHashingStickyKeyConsumerSelectorTest#shouldRemoveConsumersFromConsumerKeyHashRanges"
    ],
    "test_src_code": "    @Test\n    public void testGetConsumerKeyHashRanges() throws BrokerServiceException.ConsumerAssignException {\n        ConsistentHashingStickyKeyConsumerSelector selector = new ConsistentHashingStickyKeyConsumerSelector(3);\n        List<String> consumerName = Arrays.asList(\"consumer1\", \"consumer2\", \"consumer3\");\n        List<Consumer> consumers = new ArrayList<>();\n        for (String s : consumerName) {\n            Consumer consumer = mock(Consumer.class);\n            when(consumer.consumerName()).thenReturn(s);\n            selector.addConsumer(consumer);\n            consumers.add(consumer);\n        }\n        Map<Consumer, List<Range>> expectedResult = new HashMap<>();\n        expectedResult.put(consumers.get(0), Arrays.asList(\n                Range.of(0, 330121749),\n                Range.of(330121750, 618146114),\n                Range.of(1797637922, 1976098885)));\n        expectedResult.put(consumers.get(1), Arrays.asList(\n                Range.of(938427576, 1094135919),\n                Range.of(1138613629, 1342907082),\n                Range.of(1342907083, 1797637921)));\n        expectedResult.put(consumers.get(2), Arrays.asList(\n                Range.of(618146115, 772640562),\n                Range.of(772640563, 938427575),\n                Range.of(1094135920, 1138613628)));\n        for (Map.Entry<Consumer, List<Range>> entry : selector.getConsumerKeyHashRanges().entrySet()) {\n            System.out.println(entry.getValue());\n            Assert.assertEquals(entry.getValue(), expectedResult.get(entry.getKey()));\n            expectedResult.remove(entry.getKey());\n        }\n        Assert.assertEquals(expectedResult.size(), 0);\n    }\n",
    "test_tgt_code": "    @Test\n    public void testGetConsumerKeyHashRanges() throws BrokerServiceException.ConsumerAssignException {\n        ConsistentHashingStickyKeyConsumerSelector selector = new ConsistentHashingStickyKeyConsumerSelector(3);\n        List<String> consumerName = Arrays.asList(\"consumer1\", \"consumer2\", \"consumer3\");\n        List<Consumer> consumers = new ArrayList<>();\n        for (String s : consumerName) {\n            Consumer consumer = mock(Consumer.class);\n            when(consumer.consumerName()).thenReturn(s);\n            selector.addConsumer(consumer);\n            consumers.add(consumer);\n        }\n        Map<Consumer, List<Range>> expectedResult = new HashMap<>();\n        expectedResult.put(consumers.get(0), Arrays.asList(\n                Range.of(119056335, 242013991),\n                Range.of(722195657, 1656011842),\n                Range.of(1707482098, 1914695766)));\n        expectedResult.put(consumers.get(1), Arrays.asList(\n                Range.of(0, 90164503),\n                Range.of(90164504, 119056334),\n                Range.of(382436668, 722195656)));\n        expectedResult.put(consumers.get(2), Arrays.asList(\n                Range.of(242013992, 242377547),\n                Range.of(242377548, 382436667),\n                Range.of(1656011843, 1707482097)));\n        for (Map.Entry<Consumer, List<Range>> entry : selector.getConsumerKeyHashRanges().entrySet()) {\n            System.out.println(entry.getValue());\n            Assert.assertEquals(entry.getValue(), expectedResult.get(entry.getKey()));\n            expectedResult.remove(entry.getKey());\n        }\n        Assert.assertEquals(expectedResult.size(), 0);\n    }\n",
    "focal_path_src": [
      "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ConsistentHashingStickyKeyConsumerSelector.java#addConsumer"
    ],
    "focal_path_tgt": [
      "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ConsistentHashingStickyKeyConsumerSelector.java#addConsumer"
    ],
    "focal_src": [
      "    @Override\n    public CompletableFuture<Void> addConsumer(Consumer consumer) {\n        rwLock.writeLock().lock();\n        try {\n            // Insert multiple points on the hash ring for every consumer\n            // The points are deterministically added based on the hash of the consumer name\n            for (int i = 0; i < numberOfPoints; i++) {\n                String key = consumer.consumerName() + i;\n                int hash = Murmur3_32Hash.getInstance().makeHash(key.getBytes());\n                hashRing.compute(hash, (k, v) -> {\n                    if (v == null) {\n                        return Lists.newArrayList(consumer);\n                    } else {\n                        if (!v.contains(consumer)) {\n                            v.add(consumer);\n                            v.sort(Comparator.comparing(Consumer::consumerName, String::compareTo));\n                        }\n                        return v;\n                    }\n                });\n            }\n            return CompletableFuture.completedFuture(null);\n        } finally {\n            rwLock.writeLock().unlock();\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public CompletableFuture<Void> addConsumer(Consumer consumer) {\n        rwLock.writeLock().lock();\n        try {\n            // Insert multiple points on the hash ring for every consumer\n            // The points are deterministically added based on the hash of the consumer name\n            for (int i = 0; i < numberOfPoints; i++) {\n                int hash = calculateHashForConsumerAndIndex(consumer, i);\n                hashRing.compute(hash, (k, v) -> {\n                    if (v == null) {\n                        return Lists.newArrayList(consumer);\n                    } else {\n                        if (!v.contains(consumer)) {\n                            v.add(consumer);\n                            v.sort(Comparator.comparing(Consumer::consumerName, String::compareTo));\n                        }\n                        return v;\n                    }\n                });\n            }\n            return CompletableFuture.completedFuture(null);\n        } finally {\n            rwLock.writeLock().unlock();\n        }\n    }\n"
    ],
    "test_id": 13,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetConsumerKeyHashRanges() throws BrokerServiceException.ConsumerAssignException {\n    ConsistentHashingStickyKeyConsumerSelector selector = new ConsistentHashingStickyKeyConsumerSelector(3);\n    List<String> consumerName = Arrays.asList(\"consumer1\", \"consumer2\", \"consumer3\");\n    List<Consumer> consumers = new ArrayList<>();\n    for (String s : consumerName) {\n        Consumer consumer = mock(Consumer.class);\n        when(consumer.consumerName()).thenReturn(s);\n        selector.addConsumer(consumer);\n        consumers.add(consumer);\n    }\n    Map<Consumer, List<Range>> expectedResult = new HashMap<>();\n    expectedResult.put(consumers.get(0), Arrays.asList(\n            Range.of(0, 330121749),\n            Range.of(330121750, 618146114),\n            Range.of(1797637922, 1976098885)));\n    expectedResult.put(consumers.get(1), Arrays.asList(\n            Range.of(938427576, 1094135919),\n            Range.of(1138613629, 1342907082),\n            Range.of(1342907083, 1797637921)));\n    expectedResult.put(consumers.get(2), Arrays.asList(\n            Range.of(618146115, 772640562),\n            Range.of(772640563, 938427575),\n            Range.of(1094135920, 1138613628)));\n    for (Map.Entry<Consumer, List<Range>> entry : selector.getConsumerKeyHashRanges().entrySet()) {\n        System.out.println(entry.getValue());\n        Assert.assertEquals(entry.getValue(), expectedResult.get(entry.getKey()));\n        expectedResult.remove(entry.getKey());\n    }\n    Assert.assertEquals(expectedResult.size(), 0);\n}\n",
      "@Test\npublic void testGetConsumerKeyHashRanges() throws BrokerServiceException.ConsumerAssignException {\n    ConsistentHashingStickyKeyConsumerSelector selector = new ConsistentHashingStickyKeyConsumerSelector(3);\n    List<String> consumerName = Arrays.asList(\"consumer1\", \"consumer2\", \"consumer3\");\n    List<Consumer> consumers = new ArrayList<>();\n    for (String s : consumerName) {\n        Consumer consumer = mock(Consumer.class);\n        when(consumer.consumerName()).thenReturn(s);\n        selector.addConsumer(consumer);\n        consumers.add(consumer);\n    }\n    Map<Consumer, List<Range>> expectedResult = new HashMap<>();\n    expectedResult.put(consumers.get(0), Arrays.asList(\n            Range.of(0, 330121749),\n            Range.of(330121750, 618146114),\n            Range.of(1797637922, 1976098885)));\n    expectedResult.put(consumers.get(1), Arrays.asList(\n            Range.of(938427576, 1094135919),\n            Range.of(1138613629, 1342907082),\n            Range.of(1342907083, 1797637921)));\n    expectedResult.put(consumers.get(2), Arrays.asList(\n            Range.of(618146115, 772640562),\n            Range.of(772640563, 938427575),\n            Range.of(1094135920, 1138613628)));\n    for (Map.Entry<Consumer, List<Range>> entry : selector.getConsumerKeyHashRanges().entrySet()) {\n        Assert.assertEquals(entry.getValue(), expectedResult.get(entry.getKey()));\n        expectedResult.remove(entry.getKey());\n    }\n    Assert.assertEquals(expectedResult.size(), 0);\n}\n",
      "@Test\npublic void testGetConsumerKeyHashRanges() throws BrokerServiceException.ConsumerAssignException {\n    ConsistentHashingStickyKeyConsumerSelector selector = new ConsistentHashingStickyKeyConsumerSelector(3);\n    List<String> consumerName = Arrays.asList(\"consumer1\", \"consumer2\", \"consumer3\");\n    List<Consumer> consumers = new ArrayList<>();\n    for (String s : consumerName) {\n        Consumer consumer = mock(Consumer.class);\n        when(consumer.consumerName()).thenReturn(s);\n        selector.addConsumer(consumer);\n        consumers.add(consumer);\n    }\n    Map<Consumer, List<Range>> expectedResult = new HashMap<>();\n    expectedResult.put(consumers.get(0), Arrays.asList(\n            Range.of(0, 330121749),\n            Range.of(330121750, 618146114),\n            Range.of(1797637922, 1976098885)));\n    expectedResult.put(consumers.get(1), Arrays.asList(\n            Range.of(938427576, 1094135919),\n            Range.of(1138613629, 1342907082),\n            Range.of(1342907083, 1797637921)));\n    expectedResult.put(consumers.get(2), Arrays.asList(\n            Range.of(618146115, 772640562),\n            Range.of(772640563, 938427575),\n            Range.of(1094135920, 1138613628)));\n    for (Map.Entry<Consumer, List<Range>> entry : selector.getConsumerKeyHashRanges().entrySet()) {\n        Assert.assertEquals(entry.getValue(), expectedResult.get(entry.getKey()));\n        expectedResult.remove(entry.getKey());\n    }\n    Assert.assertEquals(expectedResult.size(), 0);\n}\n",
      "@Test\npublic void testGetConsumerKeyHashRanges() throws BrokerServiceException.ConsumerAssignException {\n    ConsistentHashingStickyKeyConsumerSelector selector = new ConsistentHashingStickyKeyConsumerSelector(3);\n    List<String> consumerName = Arrays.asList(\"consumer1\", \"consumer2\", \"consumer3\");\n    List<Consumer> consumers = new ArrayList<>();\n    for (String s : consumerName) {\n        Consumer consumer = mock(Consumer.class);\n        when(consumer.consumerName()).thenReturn(s);\n        selector.addConsumer(consumer);\n        consumers.add(consumer);\n    }\n    Map<Consumer, List<Range>> expectedResult = new HashMap<>();\n    expectedResult.put(consumers.get(0), Arrays.asList(\n            Range.of(0, 330121749),\n            Range.of(330121750, 618146114),\n            Range.of(1797637922, 1976098885)));\n    expectedResult.put(consumers.get(1), Arrays.asList(\n            Range.of(938427576, 1094135919),\n            Range.of(1138613629, 1342907082),\n            Range.of(1342907083, 1797637921)));\n    expectedResult.put(consumers.get(2), Arrays.asList(\n            Range.of(618146115, 772640562),\n            Range.of(772640563, 938427575),\n            Range.of(1094135920, 1138613628)));\n    for (Map.Entry<Consumer, List<Range>> entry : selector.getConsumerKeyHashRanges().entrySet()) {\n        Assert.assertEquals(entry.getValue(), expectedResult.get(entry.getKey()));\n        expectedResult.remove(entry.getKey());\n    }\n    Assert.assertEquals(expectedResult.size(), 0);\n}\n",
      "@Test\npublic void testGetConsumerKeyHashRanges() throws BrokerServiceException.ConsumerAssignException {\n    ConsistentHashingStickyKeyConsumerSelector selector = new ConsistentHashingStickyKeyConsumerSelector(3);\n    List<String> consumerName = Arrays.asList(\"consumer1\", \"consumer2\", \"consumer3\");\n    List<Consumer> consumers = new ArrayList<>();\n    for (String s : consumerName) {\n        Consumer consumer = mock(Consumer.class);\n        when(consumer.consumerName()).thenReturn(s);\n        selector.addConsumer(consumer);\n        consumers.add(consumer);\n    }\n    Map<Consumer, List<Range>> expectedResult = new HashMap<>();\n    expectedResult.put(consumers.get(0), Arrays.asList(\n            Range.of(0, 330121749),\n            Range.of(330121750, 618146114),\n            Range.of(1797637922, 1976098885)));\n    expectedResult.put(consumers.get(1), Arrays.asList(\n            Range.of(938427576, 1094135919),\n            Range.of(1138613629, 1342907082),\n            Range.of(1342907083, 1797637921)));\n    expectedResult.put(consumers.get(2), Arrays.asList(\n            Range.of(618146115, 772640562),\n            Range.of(772640563, 938427575),\n            Range.of(1094135920, 1138613628)));\n    for (Map.Entry<Consumer, List<Range>> entry : selector.getConsumerKeyHashRanges().entrySet()) {\n        System.out.println(entry.getValue());\n        Assert.assertEquals(entry.getValue(), expectedResult.get(entry.getKey()));\n        expectedResult.remove(entry.getKey());\n    }\n    Assert.assertEquals(expectedResult.size(), 0);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testGetConsumerKeyHashRanges() throws BrokerServiceException.ConsumerAssignException {\n    ConsistentHashingStickyKeyConsumerSelector selector = new ConsistentHashingStickyKeyConsumerSelector(3);\n    List<String> consumerName = Arrays.asList(\"consumer1\", \"consumer2\", \"consumer3\");\n    List<Consumer> consumers = new ArrayList<>();\n    for (String s : consumerName) {\n        Consumer consumer = mock(Consumer.class);\n        when(consumer.consumerName()).thenReturn(s);\n        selector.addConsumer(consumer);\n        consumers.add(consumer);\n    }\n    Map<Consumer, List<Range>> expectedResult = new HashMap<>();\n    expectedResult.put(consumers.get(0), Arrays.asList(\n            Range.of(0, 330121749),\n            Range.of(330121750, 618146114),\n            Range.of(1797637922, 1976098885)));\n    expectedResult.put(consumers.get(1), Arrays.asList(\n            Range.of(938427576, 1094135919),\n            Range.of(1138613629, 1342907082),\n            Range.of(1342907083, 1797637921)));\n    expectedResult.put(consumers.get(2), Arrays.asList(\n            Range.of(618146115, 772640562),\n            Range.of(772640563, 938427575),\n            Range.of(1094135920, 1138613628)));\n    for (Map.Entry<Consumer, List<Range>> entry : selector.getConsumerKeyHashRanges().entrySet()) {\n        System.out.println(entry.getValue());\n        Assert.assertEquals(entry.getValue(), expectedResult.get(entry.getKey()));\n        expectedResult.remove(entry.getKey());\n    }\n    Assert.assertEquals(expectedResult.size(), 0);\n    // Testing the case when the hash ring is empty\n    ConsistentHashingStickyKeyConsumerSelector emptySelector = new ConsistentHashingStickyKeyConsumerSelector(3);\n    Assert.assertEquals(emptySelector.getConsumerKeyHashRanges().size(), 0);\n}\n",
      "@Test\npublic void testGetConsumerKeyHashRanges() throws BrokerServiceException.ConsumerAssignException {\n    ConsistentHashingStickyKeyConsumerSelector selector = new ConsistentHashingStickyKeyConsumerSelector(3);\n    List<String> consumerName = Arrays.asList(\"consumer1\", \"consumer2\", \"consumer3\");\n    List<Consumer> consumers = new ArrayList<>();\n    for (String s : consumerName) {\n        Consumer consumer = mock(Consumer.class);\n        when(consumer.consumerName()).thenReturn(s);\n        selector.addConsumer(consumer);\n        consumers.add(consumer);\n    }\n    Map<Consumer, List<Range>> expectedResult = new HashMap<>();\n    expectedResult.put(consumers.get(0), Arrays.asList(\n            Range.of(0, 330121749),\n            Range.of(330121750, 618146114),\n            Range.of(1797637922, 1976098885)));\n    expectedResult.put(consumers.get(1), Arrays.asList(\n            Range.of(938427576, 1094135919),\n            Range.of(1138613629, 1342907082),\n            Range.of(1342907083, 1797637921)));\n    expectedResult.put(consumers.get(2), Arrays.asList(\n            Range.of(618146115, 772640562),\n            Range.of(772640563, 938427575),\n            Range.of(1094135920, 1138613628)));\n    for (Map.Entry<Consumer, List<Range>> entry : selector.getConsumerKeyHashRanges().entrySet()) {\n        System.out.println(entry.getValue());\n        Assert.assertEquals(entry.getValue(), expectedResult.get(entry.getKey()));\n        expectedResult.remove(entry.getKey());\n    }\n    Assert.assertEquals(expectedResult.size(), 0);\n    // Testing the case when the hash ring is empty\n    ConsistentHashingStickyKeyConsumerSelector emptySelector = new ConsistentHashingStickyKeyConsumerSelector(3);\n    Assert.assertEquals(emptySelector.getConsumerKeyHashRanges().size(), 0);\n}\n"
    ]
  }
}