{
  "1": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_TopicNotExist",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_TopicNotExist",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "test_src_code": "    @Test\n    public void testProcessRequest_TopicNotExist() throws RemotingCommandException {\n        brokerController.getTopicConfigManager().getTopicConfigTable().remove(topic);\n        final RemotingCommand request = createPopMsgCommand();\n        RemotingCommand response = popMessageProcessor.processRequest(handlerContext, request);\n        assertThat(response).isNotNull();\n        assertThat(response.getCode()).isEqualTo(ResponseCode.TOPIC_NOT_EXIST);\n        assertThat(response.getRemark()).contains(\"topic[\" + topic + \"] not exist\");\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest"
    ],
    "focal_src": [
      "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n"
    ],
    "focal_tgt": [
      "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n"
    ],
    "test_id": 1,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testProcessRequest_TopicNotExist() throws RemotingCommandException {\n    brokerController.getTopicConfigManager().getTopicConfigTable().remove(topic);\n    final RemotingCommand request = createPopMsgCommand();\n    RemotingCommand response = popMessageProcessor.processRequest(handlerContext, request);\n    assertThat(response).isNotNull();\n    assertThat(response.getCode()).isEqualTo(ResponseCode.TOPIC_NOT_EXIST);\n    assertThat(response.getRemark()).contains(\"topic[\" + topic + \"] not exist\");\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testProcessRequest_TopicNotExist() throws RemotingCommandException {\n    brokerController.getTopicConfigManager().getTopicConfigTable().remove(topic);\n    final RemotingCommand request = createPopMsgCommand();\n    RemotingCommand response = popMessageProcessor.processRequest(handlerContext, request);\n    assertThat(response).isNotNull();\n    assertThat(response.getCode()).isEqualTo(ResponseCode.TOPIC_NOT_EXIST);\n    assertThat(response.getRemark()).contains(\"topic[\" + topic + \"] not exist\");\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "Exception('No enough memory for inference')"
  },
  "2": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_Found",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_Found",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "test_src_code": "    @Test\n    public void testProcessRequest_Found() throws RemotingCommandException, InterruptedException {\n        GetMessageResult getMessageResult = createGetMessageResult(1);\n        when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n        final RemotingCommand request = createPopMsgCommand();\n        popMessageProcessor.processRequest(handlerContext, request);\n        RemotingCommand response = embeddedChannel.readOutbound();\n        assertThat(response).isNotNull();\n        assertThat(response.getCode()).isEqualTo(ResponseCode.SUCCESS);\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest"
    ],
    "focal_src": [
      "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n"
    ],
    "focal_tgt": [
      "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n"
    ],
    "test_id": 2,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testProcessRequest_Found() throws RemotingCommandException, InterruptedException {\n    GetMessageResult getMessageResult = createGetMessageResult(1);\n    when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n    final RemotingCommand request = createPopMsgCommand();\n    popMessageProcessor.processRequest(handlerContext, request);\n    RemotingCommand response = embeddedChannel.readOutbound();\n    assertThat(response).isNotNull();\n    assertThat(response.getCode()).isEqualTo(ResponseCode.SUCCESS);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testProcessRequest_Found() throws RemotingCommandException, InterruptedException {\n    GetMessageResult getMessageResult = createGetMessageResult(1);\n    when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n    final RemotingCommand request = createPopMsgCommand();\n    popMessageProcessor.processRequest(handlerContext, request);\n    RemotingCommand response = embeddedChannel.readOutbound();\n    assertThat(response).isNotNull();\n    assertThat(response.getCode()).isEqualTo(ResponseCode.SUCCESS);\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "Exception('No enough memory for inference')"
  },
  "3": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_MsgWasRemoving",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_MsgWasRemoving",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "test_src_code": "    @Test\n    public void testProcessRequest_MsgWasRemoving() throws RemotingCommandException {\n        GetMessageResult getMessageResult = createGetMessageResult(1);\n        getMessageResult.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n        when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n        final RemotingCommand request = createPopMsgCommand();\n        popMessageProcessor.processRequest(handlerContext, request);\n        RemotingCommand response = embeddedChannel.readOutbound();\n        assertThat(response).isNotNull();\n        assertThat(response.getCode()).isEqualTo(ResponseCode.SUCCESS);\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest"
    ],
    "focal_src": [
      "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n"
    ],
    "focal_tgt": [
      "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n"
    ],
    "test_id": 3,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testProcessRequest_MsgWasRemoving() throws RemotingCommandException {\n    GetMessageResult getMessageResult = createGetMessageResult(1);\n    getMessageResult.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n    when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n    final RemotingCommand request = createPopMsgCommand();\n    popMessageProcessor.processRequest(handlerContext, request);\n    RemotingCommand response = embeddedChannel.readOutbound();\n    assertThat(response).isNotNull();\n    assertThat(response.getCode()).isEqualTo(ResponseCode.SUCCESS);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testProcessRequest_MsgWasRemoving() throws RemotingCommandException {\n    GetMessageResult getMessageResult = createGetMessageResult(1);\n    getMessageResult.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n    when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n    final RemotingCommand request = createPopMsgCommand();\n    popMessageProcessor.processRequest(handlerContext, request);\n    RemotingCommand response = embeddedChannel.readOutbound();\n    assertThat(response).isNotNull();\n    assertThat(response.getCode()).isEqualTo(ResponseCode.SUCCESS);\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "Exception('No enough memory for inference')"
  },
  "4": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_NoMsgInQueue",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_NoMsgInQueue",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "test_src_code": "    @Test\n    public void testProcessRequest_NoMsgInQueue() throws RemotingCommandException {\n        GetMessageResult getMessageResult = createGetMessageResult(0);\n        getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n        when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n        final RemotingCommand request = createPopMsgCommand();\n        RemotingCommand response = popMessageProcessor.processRequest(handlerContext, request);\n        assertThat(response).isNull();\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest"
    ],
    "focal_src": [
      "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n"
    ],
    "focal_tgt": [
      "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n"
    ],
    "test_id": 4,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testProcessRequest_NoMsgInQueue() throws RemotingCommandException {\n    GetMessageResult getMessageResult = createGetMessageResult(0);\n    getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n    when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n    final RemotingCommand request = createPopMsgCommand();\n    RemotingCommand response = popMessageProcessor.processRequest(handlerContext, request);\n    assertThat(response).isNull();\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testProcessRequest_NoMsgInQueue() throws RemotingCommandException {\n    GetMessageResult getMessageResult = createGetMessageResult(0);\n    getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n    when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n    final RemotingCommand request = createPopMsgCommand();\n    RemotingCommand response = popMessageProcessor.processRequest(handlerContext, request);\n    assertThat(response).isNull();\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "Exception('No enough memory for inference')"
  },
  "5": {
    "commit_src": "52c4c0cdf61f4b11d06fa70002499c3d79aedc3e",
    "commit_tgt": "94db42ade7b4001860f5c7eefd026629bf5859fd",
    "changed_tests": [
      "store/src/test/java/org/apache/rocketmq/store/timer/TimerMessageStoreTest.java"
    ],
    "refer_PR": "apache_rocketmq-6293",
    "test_src": ".org.apache.rocketmq.store.timer.TimerMessageStoreTest#testDeleteTimerMessage",
    "test_tgt": [
      ".org.apache.rocketmq.store.timer.TimerMessageStoreTest#testDeleteTimerMessage"
    ],
    "test_src_code": "    @Test\n    public void testDeleteTimerMessage() throws Exception {\n        String topic = \"TimerTest_testDeleteTimerMessage\";\n\n        TimerMessageStore timerMessageStore = createTimerMessageStore(null);\n        timerMessageStore.load();\n        timerMessageStore.start(true);\n\n        long curr = System.currentTimeMillis() / precisionMs * precisionMs;\n        long delayMs = curr + 1000;\n        String uniqKey = null;\n        for (int i = 0; i < 5; i++) {\n            MessageExtBrokerInner inner = buildMessage(delayMs, topic, false);\n            transformTimerMessage(timerMessageStore,inner);\n            if (null == uniqKey) {\n                uniqKey = MessageClientIDSetter.getUniqID(inner);\n            }\n            assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(inner).getPutMessageStatus());\n        }\n\n        MessageExtBrokerInner delMsg = buildMessage(delayMs, topic, false);\n        transformTimerMessage(timerMessageStore,delMsg);\n        MessageAccessor.putProperty(delMsg, TimerMessageStore.TIMER_DELETE_UNIQKEY, uniqKey);\n        delMsg.setPropertiesString(MessageDecoder.messageProperties2String(delMsg.getProperties()));\n        assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(delMsg).getPutMessageStatus());\n\n        // The first one should have been deleted.\n        ByteBuffer msgBuff = getOneMessage(topic, 0, 0, 3000);\n        assertNotNull(msgBuff);\n        MessageExt msgExt = MessageDecoder.decode(msgBuff);\n        assertNotNull(msgExt);\n        assertNotEquals(uniqKey, MessageClientIDSetter.getUniqID(msgExt));\n\n        // The last one should be null.\n        assertNull(getOneMessage(topic, 0, 4, 500));\n    }\n",
    "focal_path_src": [
      "store/src/main/java/org/apache/rocketmq/store/timer/TimerMessageStore.java#start"
    ],
    "focal_path_tgt": [
      "store/src/main/java/org/apache/rocketmq/store/timer/TimerMessageStore.java#start"
    ],
    "focal_src": [
      "    public void start() {\n        this.shouldStartTime = storeConfig.getDisappearTimeAfterStart() + System.currentTimeMillis();\n        maybeMoveWriteTime();\n        enqueueGetService.start();\n        enqueuePutService.start();\n        dequeueWarmService.start();\n        dequeueGetService.start();\n        for (int i = 0; i < dequeueGetMessageServices.length; i++) {\n            dequeueGetMessageServices[i].start();\n        }\n        for (int i = 0; i < dequeuePutMessageServices.length; i++) {\n            dequeuePutMessageServices[i].start();\n        }\n        timerFlushService.start();\n\n        scheduler.scheduleAtFixedRate(new Runnable() {\n            @Override public void run() {\n                if (TimerMessageStore.this.messageStore instanceof DefaultMessageStore &&\n                    ((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().isInBrokerContainer()) {\n//                    InnerLoggerFactory.BROKER_IDENTITY.set(((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().getLoggerIdentifier());\n                }\n                try {\n                    long minPy = messageStore.getMinPhyOffset();\n                    int checkOffset = timerLog.getOffsetForLastUnit();\n                    timerLog.getMappedFileQueue().deleteExpiredFileByOffsetForTimerLog(minPy, checkOffset, TimerLog.UNIT_SIZE);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in cleaning timerlog\", e);\n                }\n            }\n        }, 30, 30, TimeUnit.SECONDS);\n\n        scheduler.scheduleAtFixedRate(new Runnable() {\n            @Override public void run() {\n                if (TimerMessageStore.this.messageStore instanceof DefaultMessageStore &&\n                    ((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().isInBrokerContainer()) {\n//                    InnerLoggerFactory.BROKER_IDENTITY.set(((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().getLoggerIdentifier());\n                }\n                try {\n                    if (storeConfig.isTimerEnableCheckMetrics()) {\n                        String when = storeConfig.getTimerCheckMetricsWhen();\n                        if (!UtilAll.isItTimeToDo(when)) {\n                            return;\n                        }\n                        long curr = System.currentTimeMillis();\n                        if (curr - lastTimeOfCheckMetrics > 70 * 60 * 1000) {\n                            lastTimeOfCheckMetrics = curr;\n                            checkAndReviseMetrics();\n                            LOGGER.info(\"[CheckAndReviseMetrics]Timer do check timer metrics cost {} ms\", System.currentTimeMillis() - curr);\n                        }\n                    }\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in cleaning timerlog\", e);\n                }\n            }\n        }, 45, 45, TimeUnit.MINUTES);\n\n        state = RUNNING;\n        LOGGER.info(\"Timer start ok currReadTimerMs:[{}] queueOffset:[{}]\", new Timestamp(currReadTimeMs), currQueueOffset);\n    }\n"
    ],
    "focal_tgt": [
      "    public void start() {\n        this.shouldStartTime = storeConfig.getDisappearTimeAfterStart() + System.currentTimeMillis();\n        maybeMoveWriteTime();\n        enqueueGetService.start();\n        enqueuePutService.start();\n        dequeueWarmService.start();\n        dequeueGetService.start();\n        for (int i = 0; i < dequeueGetMessageServices.length; i++) {\n            dequeueGetMessageServices[i].start();\n        }\n        for (int i = 0; i < dequeuePutMessageServices.length; i++) {\n            dequeuePutMessageServices[i].start();\n        }\n        timerFlushService.start();\n\n        scheduler.scheduleAtFixedRate(new Runnable() {\n            @Override public void run() {\n                if (TimerMessageStore.this.messageStore instanceof DefaultMessageStore &&\n                    ((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().isInBrokerContainer()) {\n//                    InnerLoggerFactory.BROKER_IDENTITY.set(((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().getLoggerIdentifier());\n                }\n                try {\n                    long minPy = messageStore.getMinPhyOffset();\n                    int checkOffset = timerLog.getOffsetForLastUnit();\n                    timerLog.getMappedFileQueue().deleteExpiredFileByOffsetForTimerLog(minPy, checkOffset, TimerLog.UNIT_SIZE);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in cleaning timerLog\", e);\n                }\n            }\n        }, 30, 30, TimeUnit.SECONDS);\n\n        scheduler.scheduleAtFixedRate(new Runnable() {\n            @Override public void run() {\n                if (TimerMessageStore.this.messageStore instanceof DefaultMessageStore &&\n                    ((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().isInBrokerContainer()) {\n//                    InnerLoggerFactory.BROKER_IDENTITY.set(((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().getLoggerIdentifier());\n                }\n                try {\n                    if (storeConfig.isTimerEnableCheckMetrics()) {\n                        String when = storeConfig.getTimerCheckMetricsWhen();\n                        if (!UtilAll.isItTimeToDo(when)) {\n                            return;\n                        }\n                        long curr = System.currentTimeMillis();\n                        if (curr - lastTimeOfCheckMetrics > 70 * 60 * 1000) {\n                            lastTimeOfCheckMetrics = curr;\n                            checkAndReviseMetrics();\n                            LOGGER.info(\"[CheckAndReviseMetrics]Timer do check timer metrics cost {} ms\", System.currentTimeMillis() - curr);\n                        }\n                    }\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in cleaning timerLog\", e);\n                }\n            }\n        }, 45, 45, TimeUnit.MINUTES);\n\n        state = RUNNING;\n        LOGGER.info(\"Timer start ok currReadTimerMs:[{}] queueOffset:[{}]\", new Timestamp(currReadTimeMs), currQueueOffset);\n    }\n"
    ],
    "test_id": 5,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testDeleteTimerMessage() throws Exception {\n    String topic = \"TimerTest_testDeleteTimerMessage\";\n\n    TimerMessageStore timerMessageStore = createTimerMessageStore(null);\n    timerMessageStore.load();\n    timerMessageStore.start(true);\n\n    long curr = System.currentTimeMillis() / precisionMs * precisionMs;\n    long delayMs = curr + 1000;\n    String uniqKey = null;\n    for (int i = 0; i < 5; i++) {\n        MessageExtBrokerInner inner = buildMessage(delayMs, topic, false);\n        transformTimerMessage(timerMessageStore,inner);\n        if (null == uniqKey) {\n            uniqKey = MessageClientIDSetter.getUniqID(inner);\n        }\n        assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(inner).getPutMessageStatus());\n    }\n\n    MessageExtBrokerInner delMsg = buildMessage(delayMs, topic, false);\n    transformTimerMessage(timerMessageStore,delMsg);\n    MessageAccessor.putProperty(delMsg, TimerMessageStore.TIMER_DELETE_UNIQKEY, uniqKey);\n    delMsg.setPropertiesString(MessageDecoder.messageProperties2String(delMsg.getProperties()));\n    assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(delMsg).getPutMessageStatus());\n\n    // The first one should have been deleted.\n    ByteBuffer msgBuff = getOneMessage(topic, 0, 0, 3000);\n    assertNotNull(msgBuff);\n    MessageExt msgExt = MessageDecoder.decode(msgBuff);\n    assertNotNull(msgExt);\n    assertNotEquals(uniqKey, MessageClientIDSetter.getUniqID(msgExt));\n\n    // The last one should be null.\n    assertNull(getOneMessage(topic, 0, 4, 500));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testDeleteTimerMessage() throws Exception {\n    String topic = \"TimerTest_testDeleteTimerMessage\";\n\n    TimerMessageStore timerMessageStore = createTimerMessageStore(null);\n    timerMessageStore.load();\n    timerMessageStore.start(true);\n\n    long curr = System.currentTimeMillis() / precisionMs * precisionMs;\n    long delayMs = curr + 1000;\n    String uniqKey = null;\n    for (int i = 0; i < 5; i++) {\n        MessageExtBrokerInner inner = buildMessage(delayMs, topic, false);\n        transformTimerMessage(timerMessageStore,inner);\n        if (null == uniqKey) {\n            uniqKey = MessageClientIDSetter.getUniqID(inner);\n        }\n        assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(inner).getPutMessageStatus());\n    }\n\n    MessageExtBrokerInner delMsg = buildMessage(delayMs, topic, false);\n    transformTimerMessage(timerMessageStore,delMsg);\n    MessageAccessor.putProperty(delMsg, TimerMessageStore.TIMER_DELETE_UNIQKEY, uniqKey);\n    delMsg.setPropertiesString(MessageDecoder.messageProperties2String(delMsg.getProperties()));\n    assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(delMsg).getPutMessageStatus());\n\n    // The first one should have been deleted.\n    ByteBuffer msgBuff = getOneMessage(topic, 0, 0, 3000);\n    assertNotNull(msgBuff);\n    MessageExt msgExt = MessageDecoder.decode(msgBuff);\n    assertNotNull(msgExt);\n    assertNotEquals(uniqKey, MessageClientIDSetter.getUniqID(msgExt));\n\n    // The last one should be null.\n    assertNull(getOneMessage(topic, 0, 4, 500));\n}\n"
    ]
  },
  "6": {
    "commit_src": "52c4c0cdf61f4b11d06fa70002499c3d79aedc3e",
    "commit_tgt": "94db42ade7b4001860f5c7eefd026629bf5859fd",
    "changed_tests": [
      "store/src/test/java/org/apache/rocketmq/store/timer/TimerMessageStoreTest.java"
    ],
    "refer_PR": "apache_rocketmq-6293",
    "test_src": ".org.apache.rocketmq.store.timer.TimerMessageStoreTest#testPutDeleteTimerMessage",
    "test_tgt": [
      ".org.apache.rocketmq.store.timer.TimerMessageStoreTest#testPutDeleteTimerMessage"
    ],
    "test_src_code": "    @Test\n    public void testPutDeleteTimerMessage() throws Exception {\n        String topic = \"TimerTest_testPutDeleteTimerMessage\";\n\n        final TimerMessageStore timerMessageStore = createTimerMessageStore(null);\n        timerMessageStore.load();\n        timerMessageStore.start(true);\n\n        long curr = System.currentTimeMillis() / precisionMs * precisionMs;\n        final long delayMs = curr + 1000;\n        for (int i = 0; i < 5; i++) {\n            MessageExtBrokerInner inner = buildMessage(delayMs, topic, false);\n            transformTimerMessage(timerMessageStore,inner);\n            assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(inner).getPutMessageStatus());\n        }\n\n        MessageExtBrokerInner delMsg = buildMessage(delayMs, topic, false);\n        transformTimerMessage(timerMessageStore,delMsg);\n        MessageAccessor.putProperty(delMsg, TimerMessageStore.TIMER_DELETE_UNIQKEY, \"XXX\");\n        delMsg.setPropertiesString(MessageDecoder.messageProperties2String(delMsg.getProperties()));\n        assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(delMsg).getPutMessageStatus());\n\n        // Wait until currReadTimeMs catches up current time and delayMs is over.\n        await().atMost(5000, TimeUnit.MILLISECONDS).until(new Callable<Boolean>() {\n            @Override\n            public Boolean call() {\n                long curr = System.currentTimeMillis() / precisionMs * precisionMs;\n                return curr >= delayMs\n                        && (timerMessageStore.getCurrReadTimeMs() == curr || timerMessageStore.getCurrReadTimeMs() == curr + precisionMs);\n            }\n        });\n\n        for (int i = 0; i < 5; i++) {\n            ByteBuffer msgBuff = getOneMessage(topic, 0, i, 1000);\n            assertNotNull(msgBuff);\n            // assertThat(System.currentTimeMillis()).isLessThan(delayMs + precisionMs);\n        }\n        assertNull(getOneMessage(topic, 0, 5, 1000));\n\n        // Test put expired delete msg.\n        MessageExtBrokerInner expiredInner = buildMessage(System.currentTimeMillis() - 100, topic, false);\n        MessageAccessor.putProperty(expiredInner, TimerMessageStore.TIMER_DELETE_UNIQKEY, \"XXX\");\n        PutMessageResult putMessageResult = transformTimerMessage(timerMessageStore,expiredInner);\n        assertEquals(PutMessageStatus.WHEEL_TIMER_MSG_ILLEGAL, putMessageResult.getPutMessageStatus());\n    }\n",
    "focal_path_src": [
      "store/src/main/java/org/apache/rocketmq/store/timer/TimerMessageStore.java#start"
    ],
    "focal_path_tgt": [
      "store/src/main/java/org/apache/rocketmq/store/timer/TimerMessageStore.java#start"
    ],
    "focal_src": [
      "    public void start() {\n        this.shouldStartTime = storeConfig.getDisappearTimeAfterStart() + System.currentTimeMillis();\n        maybeMoveWriteTime();\n        enqueueGetService.start();\n        enqueuePutService.start();\n        dequeueWarmService.start();\n        dequeueGetService.start();\n        for (int i = 0; i < dequeueGetMessageServices.length; i++) {\n            dequeueGetMessageServices[i].start();\n        }\n        for (int i = 0; i < dequeuePutMessageServices.length; i++) {\n            dequeuePutMessageServices[i].start();\n        }\n        timerFlushService.start();\n\n        scheduler.scheduleAtFixedRate(new Runnable() {\n            @Override public void run() {\n                if (TimerMessageStore.this.messageStore instanceof DefaultMessageStore &&\n                    ((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().isInBrokerContainer()) {\n//                    InnerLoggerFactory.BROKER_IDENTITY.set(((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().getLoggerIdentifier());\n                }\n                try {\n                    long minPy = messageStore.getMinPhyOffset();\n                    int checkOffset = timerLog.getOffsetForLastUnit();\n                    timerLog.getMappedFileQueue().deleteExpiredFileByOffsetForTimerLog(minPy, checkOffset, TimerLog.UNIT_SIZE);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in cleaning timerlog\", e);\n                }\n            }\n        }, 30, 30, TimeUnit.SECONDS);\n\n        scheduler.scheduleAtFixedRate(new Runnable() {\n            @Override public void run() {\n                if (TimerMessageStore.this.messageStore instanceof DefaultMessageStore &&\n                    ((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().isInBrokerContainer()) {\n//                    InnerLoggerFactory.BROKER_IDENTITY.set(((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().getLoggerIdentifier());\n                }\n                try {\n                    if (storeConfig.isTimerEnableCheckMetrics()) {\n                        String when = storeConfig.getTimerCheckMetricsWhen();\n                        if (!UtilAll.isItTimeToDo(when)) {\n                            return;\n                        }\n                        long curr = System.currentTimeMillis();\n                        if (curr - lastTimeOfCheckMetrics > 70 * 60 * 1000) {\n                            lastTimeOfCheckMetrics = curr;\n                            checkAndReviseMetrics();\n                            LOGGER.info(\"[CheckAndReviseMetrics]Timer do check timer metrics cost {} ms\", System.currentTimeMillis() - curr);\n                        }\n                    }\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in cleaning timerlog\", e);\n                }\n            }\n        }, 45, 45, TimeUnit.MINUTES);\n\n        state = RUNNING;\n        LOGGER.info(\"Timer start ok currReadTimerMs:[{}] queueOffset:[{}]\", new Timestamp(currReadTimeMs), currQueueOffset);\n    }\n"
    ],
    "focal_tgt": [
      "    public void start() {\n        this.shouldStartTime = storeConfig.getDisappearTimeAfterStart() + System.currentTimeMillis();\n        maybeMoveWriteTime();\n        enqueueGetService.start();\n        enqueuePutService.start();\n        dequeueWarmService.start();\n        dequeueGetService.start();\n        for (int i = 0; i < dequeueGetMessageServices.length; i++) {\n            dequeueGetMessageServices[i].start();\n        }\n        for (int i = 0; i < dequeuePutMessageServices.length; i++) {\n            dequeuePutMessageServices[i].start();\n        }\n        timerFlushService.start();\n\n        scheduler.scheduleAtFixedRate(new Runnable() {\n            @Override public void run() {\n                if (TimerMessageStore.this.messageStore instanceof DefaultMessageStore &&\n                    ((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().isInBrokerContainer()) {\n//                    InnerLoggerFactory.BROKER_IDENTITY.set(((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().getLoggerIdentifier());\n                }\n                try {\n                    long minPy = messageStore.getMinPhyOffset();\n                    int checkOffset = timerLog.getOffsetForLastUnit();\n                    timerLog.getMappedFileQueue().deleteExpiredFileByOffsetForTimerLog(minPy, checkOffset, TimerLog.UNIT_SIZE);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in cleaning timerLog\", e);\n                }\n            }\n        }, 30, 30, TimeUnit.SECONDS);\n\n        scheduler.scheduleAtFixedRate(new Runnable() {\n            @Override public void run() {\n                if (TimerMessageStore.this.messageStore instanceof DefaultMessageStore &&\n                    ((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().isInBrokerContainer()) {\n//                    InnerLoggerFactory.BROKER_IDENTITY.set(((DefaultMessageStore) TimerMessageStore.this.messageStore).getBrokerConfig().getLoggerIdentifier());\n                }\n                try {\n                    if (storeConfig.isTimerEnableCheckMetrics()) {\n                        String when = storeConfig.getTimerCheckMetricsWhen();\n                        if (!UtilAll.isItTimeToDo(when)) {\n                            return;\n                        }\n                        long curr = System.currentTimeMillis();\n                        if (curr - lastTimeOfCheckMetrics > 70 * 60 * 1000) {\n                            lastTimeOfCheckMetrics = curr;\n                            checkAndReviseMetrics();\n                            LOGGER.info(\"[CheckAndReviseMetrics]Timer do check timer metrics cost {} ms\", System.currentTimeMillis() - curr);\n                        }\n                    }\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in cleaning timerLog\", e);\n                }\n            }\n        }, 45, 45, TimeUnit.MINUTES);\n\n        state = RUNNING;\n        LOGGER.info(\"Timer start ok currReadTimerMs:[{}] queueOffset:[{}]\", new Timestamp(currReadTimeMs), currQueueOffset);\n    }\n"
    ],
    "test_id": 6,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testPutDeleteTimerMessage() throws Exception {\n    String topic = \"TimerTest_testPutDeleteTimerMessage\";\n\n    final TimerMessageStore timerMessageStore = createTimerMessageStore(null);\n    timerMessageStore.load();\n    timerMessageStore.start(true);\n\n    long curr = System.currentTimeMillis() / precisionMs * precisionMs;\n    final long delayMs = curr + 1000;\n    for (int i = 0; i < 5; i++) {\n        MessageExtBrokerInner inner = buildMessage(delayMs, topic, false);\n        transformTimerMessage(timerMessageStore,inner);\n        assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(inner).getPutMessageStatus());\n    }\n\n    MessageExtBrokerInner delMsg = buildMessage(delayMs, topic, false);\n    transformTimerMessage(timerMessageStore,delMsg);\n    MessageAccessor.putProperty(delMsg, TimerMessageStore.TIMER_DELETE_UNIQKEY, \"XXX\");\n    delMsg.setPropertiesString(MessageDecoder.messageProperties2String(delMsg.getProperties()));\n    assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(delMsg).getPutMessageStatus());\n\n    // Wait until currReadTimeMs catches up current time and delayMs is over.\n    await().atMost(5000, TimeUnit.MILLISECONDS).until(new Callable<Boolean>() {\n        @Override\n        public Boolean call() {\n            long curr = System.currentTimeMillis() / precisionMs * precisionMs;\n            return curr >= delayMs\n                    && (timerMessageStore.getCurrReadTimeMs() == curr || timerMessageStore.getCurrReadTimeMs() == curr + precisionMs);\n        }\n    });\n\n    for (int i = 0; i < 5; i++) {\n        ByteBuffer msgBuff = getOneMessage(topic, 0, i, 1000);\n        assertNotNull(msgBuff);\n        // assertThat(System.currentTimeMillis()).isLessThan(delayMs + precisionMs);\n    }\n    assertNull(getOneMessage(topic, 0, 5, 1000));\n\n    // Test put expired delete msg.\n    MessageExtBrokerInner expiredInner = buildMessage(System.currentTimeMillis() - 100, topic, false);\n    MessageAccessor.putProperty(expiredInner, TimerMessageStore.TIMER_DELETE_UNIQKEY, \"XXX\");\n    PutMessageResult putMessageResult = transformTimerMessage(timerMessageStore,expiredInner);\n    assertEquals(PutMessageStatus.WHEEL_TIMER_MSG_ILLEGAL, putMessageResult.getPutMessageStatus());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testPutDeleteTimerMessage() throws Exception {\n    String topic = \"TimerTest_testPutDeleteTimerMessage\";\n\n    final TimerMessageStore timerMessageStore = createTimerMessageStore(null);\n    timerMessageStore.load();\n    timerMessageStore.start(true);\n\n    long curr = System.currentTimeMillis() / precisionMs * precisionMs;\n    final long delayMs = curr + 1000;\n    for (int i = 0; i < 5; i++) {\n        MessageExtBrokerInner inner = buildMessage(delayMs, topic, false);\n        transformTimerMessage(timerMessageStore,inner);\n        assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(inner).getPutMessageStatus());\n    }\n\n    MessageExtBrokerInner delMsg = buildMessage(delayMs, topic, false);\n    transformTimerMessage(timerMessageStore,delMsg);\n    MessageAccessor.putProperty(delMsg, TimerMessageStore.TIMER_DELETE_UNIQKEY, \"XXX\");\n    delMsg.setPropertiesString(MessageDecoder.messageProperties2String(delMsg.getProperties()));\n    assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(delMsg).getPutMessageStatus());\n\n    // Wait until currReadTimeMs catches up current time and delayMs is over.\n    await().atMost(5000, TimeUnit.MILLISECONDS).until(new Callable<Boolean>() {\n        @Override\n        public Boolean call() {\n            long curr = System.currentTimeMillis() / precisionMs * precisionMs;\n            return curr >= delayMs\n                    && (timerMessageStore.getCurrReadTimeMs() == curr || timerMessageStore.getCurrReadTimeMs() == curr + precisionMs);\n        }\n    });\n\n    for (int i = 0; i < 5; i++) {\n        ByteBuffer msgBuff = getOneMessage(topic, 0, i, 1000);\n        assertNotNull(msgBuff);\n        // assertThat(System.currentTimeMillis()).isLessThan(delayMs + precisionMs);\n    }\n    assertNull(getOneMessage(topic, 0, 5, 1000));\n\n    // Test put expired delete msg.\n    MessageExtBrokerInner expiredInner = buildMessage(System.currentTimeMillis() - 100, topic, false);\n    MessageAccessor.putProperty(expiredInner, TimerMessageStore.TIMER_DELETE_UNIQKEY, \"XXX\");\n    PutMessageResult putMessageResult = transformTimerMessage(timerMessageStore,expiredInner);\n    assertEquals(PutMessageStatus.WHEEL_TIMER_MSG_ILLEGAL, putMessageResult.getPutMessageStatus());\n}\n"
    ]
  },
  "7": {
    "commit_src": "1eebed8e95ef81c96b121936430ca5b2eb13d7e2",
    "commit_tgt": "e0213fb1929687c3a00bc9d6cfab9d86f9f45081",
    "changed_tests": [
      "acl/src/test/java/org/apache/rocketmq/acl/common/AclUtilsTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessControlFlowTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessValidatorTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6322",
    "test_src": ".org.apache.rocketmq.acl.common.AclUtilsTest#writeDataObject2YamlFileTest",
    "test_tgt": [
      ".org.apache.rocketmq.acl.common.AclUtilsTest#writeDataObject2YamlFileTest"
    ],
    "test_src_code": "    @Test\n    public void writeDataObject2YamlFileTest() throws IOException {\n        String targetFileName = randomTmpFile();\n        File transport = new File(targetFileName);\n        Assert.assertTrue(transport.createNewFile());\n        transport.deleteOnExit();\n\n        Map<String, Object> aclYamlMap = new HashMap<>();\n\n        // For globalWhiteRemoteAddrs element in acl yaml config file\n        List<String> globalWhiteRemoteAddrs = new ArrayList<>();\n        globalWhiteRemoteAddrs.add(\"10.10.103.*\");\n        globalWhiteRemoteAddrs.add(\"192.168.0.*\");\n        aclYamlMap.put(\"globalWhiteRemoteAddrs\", globalWhiteRemoteAddrs);\n\n        // For accounts element in acl yaml config file\n        List<Map<String, Object>> accounts = new ArrayList<>();\n        Map<String, Object> accountsMap = new LinkedHashMap<String, Object>() {\n            {\n                put(\"accessKey\", \"RocketMQ\");\n                put(\"secretKey\", \"12345678\");\n                put(\"whiteRemoteAddress\", \"whiteRemoteAddress\");\n                put(\"admin\", \"true\");\n            }\n        };\n        accounts.add(accountsMap);\n        aclYamlMap.put(\"accounts\", accounts);\n        Assert.assertTrue(AclUtils.writeDataObject(targetFileName, aclYamlMap));\n    }\n",
    "focal_path_src": [
      "acl/src/main/java/org/apache/rocketmq/acl/common/AclUtils.java#writeDataObject"
    ],
    "focal_path_tgt": [
      "acl/src/main/java/org/apache/rocketmq/acl/common/AclUtils.java#writeDataObject"
    ],
    "focal_src": [
      "    public static boolean writeDataObject(String path, Map<String, Object> dataMap) {\n        Yaml yaml = new Yaml();\n        try (PrintWriter pw = new PrintWriter(path, \"UTF-8\")) {\n            String dumpAsMap = yaml.dumpAsMap(dataMap);\n            pw.print(dumpAsMap);\n            pw.flush();\n        } catch (Exception e) {\n            throw new AclException(e.getMessage(), e);\n        }\n        return true;\n    }\n"
    ],
    "focal_tgt": [
      "    public static boolean writeDataObject(String path, Object dataMap) {\n        Yaml yaml = new Yaml();\n        try (PrintWriter pw = new PrintWriter(path, \"UTF-8\")) {\n            String dumpAsMap = yaml.dumpAsMap(dataMap);\n            pw.print(dumpAsMap);\n            pw.flush();\n        } catch (Exception e) {\n            throw new AclException(e.getMessage(), e);\n        }\n        return true;\n    }\n"
    ],
    "test_id": 7,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void writeDataObject2YamlFileTest() throws IOException {\n    String targetFileName = randomTmpFile();\n    File transport = new File(targetFileName);\n    Assert.assertTrue(transport.createNewFile());\n    transport.deleteOnExit();\n\n    Map<String, Object> aclYamlMap = new HashMap<>();\n\n    // For globalWhiteRemoteAddrs element in acl yaml config file\n    List<String> globalWhiteRemoteAddrs = new ArrayList<>();\n    globalWhiteRemoteAddrs.add(\"10.10.103.*\");\n    globalWhiteRemoteAddrs.add(\"192.168.0.*\");\n    aclYamlMap.put(\"globalWhiteRemoteAddrs\", globalWhiteRemoteAddrs);\n\n    // For accounts element in acl yaml config file\n    List<Map<String, Object>> accounts = new ArrayList<>();\n    Map<String, Object> accountsMap = new LinkedHashMap<String, Object>() {\n        {\n            put(\"accessKey\", \"RocketMQ\");\n            put(\"secretKey\", \"12345678\");\n            put(\"whiteRemoteAddress\", \"whiteRemoteAddress\");\n            put(\"admin\", \"true\");\n        }\n    };\n    accounts.add(accountsMap);\n    aclYamlMap.put(\"accounts\", accounts);\n    Assert.assertTrue(AclUtils.writeDataObject(targetFileName, aclYamlMap));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void writeDataObject2YamlFileTest() throws IOException {\n    String targetFileName = randomTmpFile();\n    File transport = new File(targetFileName);\n    Assert.assertTrue(transport.createNewFile());\n    transport.deleteOnExit();\n\n    Map<String, Object> aclYamlMap = new HashMap<>();\n\n    // For globalWhiteRemoteAddrs element in acl yaml config file\n    List<String> globalWhiteRemoteAddrs = new ArrayList<>();\n    globalWhiteRemoteAddrs.add(\"10.10.103.*\");\n    globalWhiteRemoteAddrs.add(\"192.168.0.*\");\n    aclYamlMap.put(\"globalWhiteRemoteAddrs\", globalWhiteRemoteAddrs);\n\n    // For accounts element in acl yaml config file\n    List<Map<String, Object>> accounts = new ArrayList<>();\n    Map<String, Object> accountsMap = new LinkedHashMap<String, Object>() {\n        {\n            put(\"accessKey\", \"RocketMQ\");\n            put(\"secretKey\", \"12345678\");\n            put(\"whiteRemoteAddress\", \"whiteRemoteAddress\");\n            put(\"admin\", \"true\");\n        }\n    };\n    accounts.add(accountsMap);\n    aclYamlMap.put(\"accounts\", accounts);\n    Assert.assertTrue(AclUtils.writeDataObject(targetFileName, aclYamlMap));\n}\n"
    ]
  },
  "8": {
    "commit_src": "1eebed8e95ef81c96b121936430ca5b2eb13d7e2",
    "commit_tgt": "e0213fb1929687c3a00bc9d6cfab9d86f9f45081",
    "changed_tests": [
      "acl/src/test/java/org/apache/rocketmq/acl/common/AclUtilsTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessControlFlowTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessValidatorTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6322",
    "test_src": ".org.apache.rocketmq.acl.common.AclUtilsTest#updateExistedYamlFileTest",
    "test_tgt": [
      ".org.apache.rocketmq.acl.common.AclUtilsTest#updateExistedYamlFileTest"
    ],
    "test_src_code": "    @Test\n    public void updateExistedYamlFileTest() throws IOException {\n        String targetFileName = randomTmpFile();\n        File transport = new File(targetFileName);\n        Assert.assertTrue(transport.createNewFile());\n        transport.deleteOnExit();\n\n        Map<String, Object> aclYamlMap = new HashMap<>();\n\n        // For globalWhiteRemoteAddrs element in acl yaml config file\n        List<String> globalWhiteRemoteAddrs = new ArrayList<>();\n        globalWhiteRemoteAddrs.add(\"10.10.103.*\");\n        globalWhiteRemoteAddrs.add(\"192.168.0.*\");\n        aclYamlMap.put(\"globalWhiteRemoteAddrs\", globalWhiteRemoteAddrs);\n\n        // Write file to yaml file\n        AclUtils.writeDataObject(targetFileName, aclYamlMap);\n\n        Map<String, Object> updatedMap = AclUtils.getYamlDataObject(targetFileName, Map.class);\n        List<String> globalWhiteRemoteAddrList = (List<String>) updatedMap.get(\"globalWhiteRemoteAddrs\");\n        globalWhiteRemoteAddrList.clear();\n        globalWhiteRemoteAddrList.add(\"192.168.1.2\");\n\n        // Update file and flush to yaml file\n        AclUtils.writeDataObject(targetFileName, updatedMap);\n\n        Map<String, Object> readableMap = AclUtils.getYamlDataObject(targetFileName, Map.class);\n        List<String> updatedGlobalWhiteRemoteAddrs = (List<String>) readableMap.get(\"globalWhiteRemoteAddrs\");\n        Assert.assertEquals(\"192.168.1.2\", updatedGlobalWhiteRemoteAddrs.get(0));\n    }\n",
    "focal_path_src": [
      "acl/src/main/java/org/apache/rocketmq/acl/common/AclUtils.java#writeDataObject"
    ],
    "focal_path_tgt": [
      "acl/src/main/java/org/apache/rocketmq/acl/common/AclUtils.java#writeDataObject"
    ],
    "focal_src": [
      "    public static boolean writeDataObject(String path, Map<String, Object> dataMap) {\n        Yaml yaml = new Yaml();\n        try (PrintWriter pw = new PrintWriter(path, \"UTF-8\")) {\n            String dumpAsMap = yaml.dumpAsMap(dataMap);\n            pw.print(dumpAsMap);\n            pw.flush();\n        } catch (Exception e) {\n            throw new AclException(e.getMessage(), e);\n        }\n        return true;\n    }\n"
    ],
    "focal_tgt": [
      "    public static boolean writeDataObject(String path, Object dataMap) {\n        Yaml yaml = new Yaml();\n        try (PrintWriter pw = new PrintWriter(path, \"UTF-8\")) {\n            String dumpAsMap = yaml.dumpAsMap(dataMap);\n            pw.print(dumpAsMap);\n            pw.flush();\n        } catch (Exception e) {\n            throw new AclException(e.getMessage(), e);\n        }\n        return true;\n    }\n"
    ],
    "test_id": 8,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void updateExistedYamlFileTest() throws IOException {\n    String targetFileName = randomTmpFile();\n    File transport = new File(targetFileName);\n    Assert.assertTrue(transport.createNewFile());\n    transport.deleteOnExit();\n\n    Map<String, Object> aclYamlMap = new HashMap<>();\n\n    // For globalWhiteRemoteAddrs element in acl yaml config file\n    List<String> globalWhiteRemoteAddrs = new ArrayList<>();\n    globalWhiteRemoteAddrs.add(\"10.10.103.*\");\n    globalWhiteRemoteAddrs.add(\"192.168.0.*\");\n    aclYamlMap.put(\"globalWhiteRemoteAddrs\", globalWhiteRemoteAddrs);\n\n    // Write file to yaml file\n    AclUtils.writeDataObject(targetFileName, aclYamlMap);\n\n    Map<String, Object> updatedMap = AclUtils.getYamlDataObject(targetFileName, Map.class);\n    List<String> globalWhiteRemoteAddrList = (List<String>) updatedMap.get(\"globalWhiteRemoteAddrs\");\n    globalWhiteRemoteAddrList.clear();\n    globalWhiteRemoteAddrList.add(\"192.168.1.2\");\n\n    // Update file and flush to yaml file\n    AclUtils.writeDataObject(targetFileName, updatedMap);\n\n    Map<String, Object> readableMap = AclUtils.getYamlDataObject(targetFileName, Map.class);\n    List<String> updatedGlobalWhiteRemoteAddrs = (List<String>) readableMap.get(\"globalWhiteRemoteAddrs\");\n    Assert.assertEquals(\"192.168.1.2\", updatedGlobalWhiteRemoteAddrs.get(0));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void updateExistedYamlFileTest() throws IOException {\n    String targetFileName = randomTmpFile();\n    File transport = new File(targetFileName);\n    Assert.assertTrue(transport.createNewFile());\n    transport.deleteOnExit();\n\n    Map<String, Object> aclYamlMap = new HashMap<>();\n\n    // For globalWhiteRemoteAddrs element in acl yaml config file\n    List<String> globalWhiteRemoteAddrs = new ArrayList<>();\n    globalWhiteRemoteAddrs.add(\"10.10.103.*\");\n    globalWhiteRemoteAddrs.add(\"192.168.0.*\");\n    aclYamlMap.put(\"globalWhiteRemoteAddrs\", globalWhiteRemoteAddrs);\n\n    // Write file to yaml file\n    AclUtils.writeDataObject(targetFileName, aclYamlMap);\n\n    Map<String, Object> updatedMap = AclUtils.getYamlDataObject(targetFileName, Map.class);\n    List<String> globalWhiteRemoteAddrList = (List<String>) updatedMap.get(\"globalWhiteRemoteAddrs\");\n    globalWhiteRemoteAddrList.clear();\n    globalWhiteRemoteAddrList.add(\"192.168.1.2\");\n\n    // Update file and flush to yaml file\n    AclUtils.writeDataObject(targetFileName, updatedMap);\n\n    Map<String, Object> readableMap = AclUtils.getYamlDataObject(targetFileName, Map.class);\n    List<String> updatedGlobalWhiteRemoteAddrs = (List<String>) readableMap.get(\"globalWhiteRemoteAddrs\");\n    Assert.assertEquals(\"192.168.1.2\", updatedGlobalWhiteRemoteAddrs.get(0));\n}\n"
    ]
  },
  "9": {
    "commit_src": "1eebed8e95ef81c96b121936430ca5b2eb13d7e2",
    "commit_tgt": "e0213fb1929687c3a00bc9d6cfab9d86f9f45081",
    "changed_tests": [
      "acl/src/test/java/org/apache/rocketmq/acl/common/AclUtilsTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessControlFlowTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessValidatorTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6322",
    "test_src": ".org.apache.rocketmq.acl.plain.PlainPermissionManagerTest#updateAclConfigFileVersionTest",
    "test_tgt": [
      ".org.apache.rocketmq.acl.plain.PlainPermissionManagerTest#updateAclConfigFileVersionTest"
    ],
    "test_src_code": "    @Test\n    public void updateAclConfigFileVersionTest() {\n        String aclFileName = \"test_plain_acl\";\n        Map<String, Object> updateAclConfigMap = new HashMap<>();\n        List<Map<String, Object>> versionElement = new ArrayList<>();\n        Map<String, Object> accountsMap = new LinkedHashMap<>();\n        accountsMap.put(AclConstants.CONFIG_COUNTER, 1);\n        accountsMap.put(AclConstants.CONFIG_TIME_STAMP, System.currentTimeMillis());\n        versionElement.add(accountsMap);\n\n        updateAclConfigMap.put(AclConstants.CONFIG_DATA_VERSION, versionElement);\n        final Map<String, Object> map = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);\n        final List<Map<String, Object>> version = (List<Map<String, Object>>) map.get(\"dataVersion\");\n        Assertions.assertThat(map).isNotEmpty();\n        Assert.assertEquals(2L, version.get(0).get(\"counter\"));\n    }\n",
    "focal_path_src": [
      "acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java#updateAclConfigFileVersion"
    ],
    "focal_path_tgt": [
      "acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java#updateAclConfigFileVersion"
    ],
    "focal_src": [
      "    public Map<String, Object> updateAclConfigFileVersion(String aclFileName, Map<String, Object> updateAclConfigMap) {\n\n        Object dataVersions = updateAclConfigMap.get(AclConstants.CONFIG_DATA_VERSION);\n        DataVersion dataVersion = new DataVersion();\n        if (dataVersions != null) {\n            List<Map<String, Object>> dataVersionList = (List<Map<String, Object>>) dataVersions;\n            if (dataVersionList.size() > 0) {\n                dataVersion.setTimestamp((long) dataVersionList.get(0).get(\"timestamp\"));\n                dataVersion.setCounter(new AtomicLong(Long.parseLong(dataVersionList.get(0).get(\"counter\").toString())));\n            }\n        }\n        dataVersion.nextVersion();\n        List<Map<String, Object>> versionElement = new ArrayList<>();\n        Map<String, Object> accountsMap = new LinkedHashMap<>();\n        accountsMap.put(AclConstants.CONFIG_COUNTER, dataVersion.getCounter().longValue());\n        accountsMap.put(AclConstants.CONFIG_TIME_STAMP, dataVersion.getTimestamp());\n\n        versionElement.add(accountsMap);\n        updateAclConfigMap.put(AclConstants.CONFIG_DATA_VERSION, versionElement);\n\n        dataVersionMap.put(aclFileName, dataVersion);\n\n        return updateAclConfigMap;\n    }\n"
    ],
    "focal_tgt": [
      "    public PlainAccessData updateAclConfigFileVersion(String aclFileName, PlainAccessData updateAclConfigMap) {\n\n        List<PlainAccessData.DataVersion> dataVersions = updateAclConfigMap.getDataVersion();\n        DataVersion dataVersion = new DataVersion();\n        if (dataVersions != null) {\n            if (dataVersions.size() > 0) {\n                dataVersion.setTimestamp(dataVersions.get(0).getTimestamp());\n                dataVersion.setCounter(new AtomicLong(dataVersions.get(0).getCounter()));\n            }\n        }\n        dataVersion.nextVersion();\n        List<PlainAccessData.DataVersion> versionElement = new ArrayList<>();\n        PlainAccessData.DataVersion dataVersionNew = new PlainAccessData.DataVersion();\n        dataVersionNew.setTimestamp(dataVersion.getTimestamp());\n        dataVersionNew.setCounter(dataVersion.getCounter().get());\n        versionElement.add(dataVersionNew);\n        updateAclConfigMap.setDataVersion(versionElement);\n\n        dataVersionMap.put(aclFileName, dataVersion);\n\n        return updateAclConfigMap;\n    }\n"
    ],
    "test_id": 9,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void updateAclConfigFileVersionTest() {\n    String aclFileName = \"test_plain_acl\";\n    PlainAccessData updateAclConfigMap = new PlainAccessData();\n    List<PlainAccessData.DataVersion> versionElement = new ArrayList<>();\n    PlainAccessData.DataVersion dataVersion = new PlainAccessData.DataVersion();\n    dataVersion.setCounter(1L);\n    dataVersion.setTimestamp(System.currentTimeMillis());\n    versionElement.add(dataVersion);\n    updateAclConfigMap.setDataVersion(versionElement);\n\n    final PlainAccessData result = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);\n    final List<PlainAccessData.DataVersion> resultVersions = result.getDataVersion();\n    Assert.assertEquals(1, resultVersions.size());\n    Assert.assertEquals(2L, resultVersions.get(0).getCounter());\n}\n",
      "@Test\npublic void updateAclConfigFileVersionTest() {\n    String aclFileName = \"test_plain_acl\";\n    PlainAccessData updateAclConfigMap = new PlainAccessData();\n    List<PlainAccessData.DataVersion> versionElement = new ArrayList<>();\n    PlainAccessData.DataVersion dataVersion = new PlainAccessData.DataVersion();\n    dataVersion.setCounter(1L);\n    dataVersion.setTimestamp(System.currentTimeMillis());\n    versionElement.add(dataVersion);\n\n    updateAclConfigMap.setDataVersion(versionElement);\n    final PlainAccessData plainAccessData = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);\n    final List<PlainAccessData.DataVersion> dataVersions = plainAccessData.getDataVersion();\n    Assert.assertFalse(dataVersions.isEmpty());\n    Assert.assertEquals(2L, dataVersions.get(0).getCounter());\n}\n",
      "@Test\npublic void updateAclConfigFileVersionTest() {\n    String aclFileName = \"test_plain_acl\";\n    PlainAccessData updateAclConfigMap = new PlainAccessData();\n    List<PlainAccessData.DataVersion> versionElement = new ArrayList<>();\n    PlainAccessData.DataVersion dataVersion = new PlainAccessData.DataVersion();\n    dataVersion.setCounter(1L);\n    dataVersion.setTimestamp(System.currentTimeMillis());\n    versionElement.add(dataVersion);\n\n    updateAclConfigMap.setDataVersion(versionElement);\n    final PlainAccessData plainAccessData = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);\n    final List<PlainAccessData.DataVersion> dataVersions = plainAccessData.getDataVersion();\n    Assert.assertEquals(1, dataVersions.size());\n    Assert.assertEquals(2L, dataVersions.get(0).getCounter());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void updateAclConfigFileVersionTest() {\n    String aclFileName = \"test_plain_acl\";\n    PlainAccessData updateAclConfigMap = new PlainAccessData();\n    List<PlainAccessData.DataVersion> versionElement = new ArrayList<>();\n    PlainAccessData.DataVersion dataVersion = new PlainAccessData.DataVersion();\n    dataVersion.setCounter(1L);\n    dataVersion.setTimestamp(System.currentTimeMillis());\n    versionElement.add(dataVersion);\n    updateAclConfigMap.setDataVersion(versionElement);\n\n    final PlainAccessData result = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);\n    final List<PlainAccessData.DataVersion> resultVersions = result.getDataVersion();\n    Assert.assertEquals(1, resultVersions.size());\n    Assert.assertEquals(2L, resultVersions.get(0).getCounter());\n    // Test with null dataVersions\n    updateAclConfigMap.setDataVersion(null);\n    final PlainAccessData result2 = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);\n    final List<PlainAccessData.DataVersion> resultVersions2 = result2.getDataVersion();\n    Assert.assertEquals(0, resultVersions2.size());\n\n    // Test with empty dataVersions\n    updateAclConfigMap.setDataVersion(new ArrayList<>());\n    final PlainAccessData result3 = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);\n    final List<PlainAccessData.DataVersion> resultVersions3 = result3.getDataVersion();\n    Assert.assertEquals(0, resultVersions3.size());\n}\n"
    ]
  },
  "10": {
    "commit_src": "1eebed8e95ef81c96b121936430ca5b2eb13d7e2",
    "commit_tgt": "e0213fb1929687c3a00bc9d6cfab9d86f9f45081",
    "changed_tests": [
      "acl/src/test/java/org/apache/rocketmq/acl/common/AclUtilsTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessControlFlowTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessValidatorTest.java",
      "acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6322",
    "test_src": ".org.apache.rocketmq.acl.plain.PlainPermissionManagerTest#createAclAccessConfigMapTest",
    "test_tgt": [
      ".org.apache.rocketmq.acl.plain.PlainPermissionManagerTest#createAclAccessConfigMapTest"
    ],
    "test_src_code": "    @Test\n    public void createAclAccessConfigMapTest() {\n        Map<String, Object> existedAccountMap = new HashMap<>();\n        plainAccessConfig.setAccessKey(\"admin123\");\n        plainAccessConfig.setSecretKey(\"12345678\");\n        plainAccessConfig.setWhiteRemoteAddress(\"192.168.1.1\");\n        plainAccessConfig.setAdmin(false);\n        plainAccessConfig.setDefaultGroupPerm(AclConstants.SUB_PUB);\n        plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB));\n        plainAccessConfig.setGroupPerms(Lists.newArrayList(\"groupA=SUB\"));\n\n        final Map<String, Object> map = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n        Assertions.assertThat(map).isNotEmpty();\n        Assert.assertEquals(AclConstants.SUB_PUB, map.get(\"defaultGroupPerm\"));\n        final List groupPerms = (List) map.get(\"groupPerms\");\n        Assert.assertEquals(\"groupA=SUB\", groupPerms.get(0));\n        Assert.assertEquals(\"12345678\", map.get(\"secretKey\"));\n        Assert.assertEquals(\"admin123\", map.get(\"accessKey\"));\n        Assert.assertEquals(\"192.168.1.1\", map.get(\"whiteRemoteAddress\"));\n        final List topicPerms = (List) map.get(\"topicPerms\");\n        Assert.assertEquals(\"topic-acl=PUB\", topicPerms.get(0));\n        Assert.assertEquals(false, map.get(\"admin\"));\n    }\n",
    "focal_path_src": [
      "acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java#createAclAccessConfigMap"
    ],
    "focal_path_tgt": [
      "acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java#createAclAccessConfigMap"
    ],
    "focal_src": [
      "    public Map<String, Object> createAclAccessConfigMap(Map<String, Object> existedAccountMap,\n        PlainAccessConfig plainAccessConfig) {\n\n        Map<String, Object> newAccountsMap = null;\n        if (existedAccountMap == null) {\n            newAccountsMap = new LinkedHashMap<>();\n        } else {\n            newAccountsMap = existedAccountMap;\n        }\n\n        if (StringUtils.isEmpty(plainAccessConfig.getAccessKey()) ||\n            plainAccessConfig.getAccessKey().length() <= AclConstants.ACCESS_KEY_MIN_LENGTH) {\n            throw new AclException(String.format(\n                \"The accessKey=%s cannot be null and length should longer than 6\",\n                plainAccessConfig.getAccessKey()));\n        }\n        newAccountsMap.put(AclConstants.CONFIG_ACCESS_KEY, plainAccessConfig.getAccessKey());\n\n        if (!StringUtils.isEmpty(plainAccessConfig.getSecretKey())) {\n            if (plainAccessConfig.getSecretKey().length() <= AclConstants.SECRET_KEY_MIN_LENGTH) {\n                throw new AclException(String.format(\n                    \"The secretKey=%s value length should longer than 6\",\n                    plainAccessConfig.getSecretKey()));\n            }\n            newAccountsMap.put(AclConstants.CONFIG_SECRET_KEY, plainAccessConfig.getSecretKey());\n        }\n        if (plainAccessConfig.getWhiteRemoteAddress() != null) {\n            newAccountsMap.put(AclConstants.CONFIG_WHITE_ADDR, plainAccessConfig.getWhiteRemoteAddress());\n        }\n        if (!StringUtils.isEmpty(String.valueOf(plainAccessConfig.isAdmin()))) {\n            newAccountsMap.put(AclConstants.CONFIG_ADMIN_ROLE, plainAccessConfig.isAdmin());\n        }\n        if (!StringUtils.isEmpty(plainAccessConfig.getDefaultTopicPerm())) {\n            newAccountsMap.put(AclConstants.CONFIG_DEFAULT_TOPIC_PERM, plainAccessConfig.getDefaultTopicPerm());\n        }\n        if (!StringUtils.isEmpty(plainAccessConfig.getDefaultGroupPerm())) {\n            newAccountsMap.put(AclConstants.CONFIG_DEFAULT_GROUP_PERM, plainAccessConfig.getDefaultGroupPerm());\n        }\n        if (plainAccessConfig.getTopicPerms() != null) {\n            newAccountsMap.put(AclConstants.CONFIG_TOPIC_PERMS, plainAccessConfig.getTopicPerms());\n        }\n        if (plainAccessConfig.getGroupPerms() != null) {\n            newAccountsMap.put(AclConstants.CONFIG_GROUP_PERMS, plainAccessConfig.getGroupPerms());\n        }\n\n        return newAccountsMap;\n    }\n"
    ],
    "focal_tgt": [
      "    public PlainAccessConfig createAclAccessConfigMap(PlainAccessConfig existedAccountMap,\n        PlainAccessConfig plainAccessConfig) {\n\n        PlainAccessConfig newAccountsMap = null;\n        if (existedAccountMap == null) {\n            newAccountsMap = new PlainAccessConfig();\n        } else {\n            newAccountsMap = existedAccountMap;\n        }\n\n        if (StringUtils.isEmpty(plainAccessConfig.getAccessKey()) ||\n            plainAccessConfig.getAccessKey().length() <= AclConstants.ACCESS_KEY_MIN_LENGTH) {\n            throw new AclException(String.format(\n                \"The accessKey=%s cannot be null and length should longer than 6\",\n                plainAccessConfig.getAccessKey()));\n        }\n        newAccountsMap.setAccessKey(plainAccessConfig.getAccessKey());\n\n        if (!StringUtils.isEmpty(plainAccessConfig.getSecretKey())) {\n            if (plainAccessConfig.getSecretKey().length() <= AclConstants.SECRET_KEY_MIN_LENGTH) {\n                throw new AclException(String.format(\n                    \"The secretKey=%s value length should longer than 6\",\n                    plainAccessConfig.getSecretKey()));\n            }\n            newAccountsMap.setSecretKey(plainAccessConfig.getSecretKey());\n        }\n        if (plainAccessConfig.getWhiteRemoteAddress() != null) {\n            newAccountsMap.setWhiteRemoteAddress(plainAccessConfig.getWhiteRemoteAddress());\n        }\n        if (!StringUtils.isEmpty(String.valueOf(plainAccessConfig.isAdmin()))) {\n            newAccountsMap.setAdmin(plainAccessConfig.isAdmin());\n        }\n        if (!StringUtils.isEmpty(plainAccessConfig.getDefaultTopicPerm())) {\n            newAccountsMap.setDefaultTopicPerm(plainAccessConfig.getDefaultTopicPerm());\n        }\n        if (!StringUtils.isEmpty(plainAccessConfig.getDefaultGroupPerm())) {\n            newAccountsMap.setDefaultGroupPerm(plainAccessConfig.getDefaultGroupPerm());\n        }\n        if (plainAccessConfig.getTopicPerms() != null) {\n            newAccountsMap.setTopicPerms(plainAccessConfig.getTopicPerms());\n        }\n        if (plainAccessConfig.getGroupPerms() != null) {\n            newAccountsMap.setGroupPerms(plainAccessConfig.getGroupPerms());\n        }\n\n        return newAccountsMap;\n    }\n"
    ],
    "test_id": 10,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void createAclAccessConfigMapTest() {\n    PlainAccessConfig existedAccountMap = new PlainAccessConfig();\n    PlainAccessConfig plainAccessConfig = new PlainAccessConfig();\n    plainAccessConfig.setAccessKey(\"admin123\");\n    plainAccessConfig.setSecretKey(\"12345678\");\n    plainAccessConfig.setWhiteRemoteAddress(\"192.168.1.1\");\n    plainAccessConfig.setAdmin(false);\n    plainAccessConfig.setDefaultGroupPerm(AclConstants.SUB_PUB);\n    plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB));\n    plainAccessConfig.setGroupPerms(Lists.newArrayList(\"groupA=SUB\"));\n\n    PlainAccessConfig newAccountsMap = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n\n    Assert.assertEquals(AclConstants.SUB_PUB, newAccountsMap.getDefaultGroupPerm());\n    List<String> groupPerms = newAccountsMap.getGroupPerms();\n    Assert.assertEquals(\"groupA=SUB\", groupPerms.get(0));\n    Assert.assertEquals(\"12345678\", newAccountsMap.getSecretKey());\n    Assert.assertEquals(\"admin123\", newAccountsMap.getAccessKey());\n    Assert.assertEquals(\"192.168.1.1\", newAccountsMap.getWhiteRemoteAddress());\n    List<String> topicPerms = newAccountsMap.getTopicPerms();\n    Assert.assertEquals(\"topic-acl=PUB\", topicPerms.get(0));\n    Assert.assertEquals(false, newAccountsMap.isAdmin());\n}\n",
      "@Test\npublic void createAclAccessConfigMapTest() {\n    PlainAccessConfig existedAccountMap = new PlainAccessConfig();\n    existedAccountMap.setAccessKey(\"admin123\");\n    existedAccountMap.setSecretKey(\"12345678\");\n    existedAccountMap.setWhiteRemoteAddress(\"192.168.1.1\");\n    existedAccountMap.setAdmin(false);\n    existedAccountMap.setDefaultGroupPerm(AclConstants.SUB_PUB);\n    existedAccountMap.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB));\n    existedAccountMap.setGroupPerms(Lists.newArrayList(\"groupA=SUB\"));\n\n    PlainAccessConfig plainAccessConfig = new PlainAccessConfig();\n    plainAccessConfig.setAccessKey(\"newadmin123\");\n    plainAccessConfig.setSecretKey(\"new12345678\");\n    plainAccessConfig.setWhiteRemoteAddress(\"new192.168.1.1\");\n    plainAccessConfig.setAdmin(true);\n    plainAccessConfig.setDefaultGroupPerm(AclConstants.PUB_SUB);\n    plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.SUB));\n    plainAccessConfig.setGroupPerms(Lists.newArrayList(\"newgroupA=PUB\"));\n\n    final PlainAccessConfig newAccountsMap = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n\n    Assert.assertEquals(\"newadmin123\", newAccountsMap.getAccessKey());\n    Assert.assertEquals(\"new12345678\", newAccountsMap.getSecretKey());\n    Assert.assertEquals(\"new192.168.1.1\", newAccountsMap.getWhiteRemoteAddress());\n    Assert.assertEquals(true, newAccountsMap.isAdmin());\n    Assert.assertEquals(AclConstants.PUB_SUB, newAccountsMap.getDefaultGroupPerm());\n    final List<String> newTopicPerms = newAccountsMap.getTopicPerms();\n    Assert.assertEquals(DEFAULT_TOPIC + \"=\" + AclConstants.SUB, newTopicPerms.get(0));\n    final List<String> newGroupPerms = newAccountsMap.getGroupPerms();\n    Assert.assertEquals(\"newgroupA=PUB\", newGroupPerms.get(0));\n}\n",
      "@Test\npublic void createAclAccessConfigMapTest() {\n    PlainAccessConfig existedAccountMap = new PlainAccessConfig();\n    plainAccessConfig.setAccessKey(\"admin123\");\n    plainAccessConfig.setSecretKey(\"12345678\");\n    plainAccessConfig.setWhiteRemoteAddress(\"192.168.1.1\");\n    plainAccessConfig.setAdmin(false);\n    plainAccessConfig.setDefaultGroupPerm(AclConstants.SUB_PUB);\n    plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB));\n    plainAccessConfig.setGroupPerms(Lists.newArrayList(\"groupA=SUB\"));\n\n    final PlainAccessConfig config = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n\n    Assert.assertEquals(\"admin123\", config.getAccessKey());\n    Assert.assertEquals(\"12345678\", config.getSecretKey());\n    Assert.assertEquals(\"192.168.1.1\", config.getWhiteRemoteAddress());\n    Assert.assertEquals(false, config.isAdmin());\n    Assert.assertEquals(AclConstants.SUB_PUB, config.getDefaultGroupPerm());\n    Assert.assertEquals(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB), config.getTopicPerms());\n    Assert.assertEquals(Lists.newArrayList(\"groupA=SUB\"), config.getGroupPerms());\n}\n",
      "@Test\npublic void createAclAccessConfigMapTest() {\n    PlainAccessConfig existedAccountMap = new PlainAccessConfig();\n    existedAccountMap.setAccessKey(\"admin123\");\n    existedAccountMap.setSecretKey(\"12345678\");\n    existedAccountMap.setWhiteRemoteAddress(\"192.168.1.1\");\n    existedAccountMap.setAdmin(false);\n    existedAccountMap.setDefaultGroupPerm(AclConstants.SUB_PUB);\n    existedAccountMap.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB));\n    existedAccountMap.setGroupPerms(Lists.newArrayList(\"groupA=SUB\"));\n\n    PlainAccessConfig plainAccessConfig = new PlainAccessConfig();\n    plainAccessConfig.setAccessKey(\"newuser\");\n    plainAccessConfig.setSecretKey(\"87654321\");\n    plainAccessConfig.setWhiteRemoteAddress(\"10.10.10.10\");\n    plainAccessConfig.setAdmin(true);\n    plainAccessConfig.setDefaultGroupPerm(AclConstants.PUB_SUB);\n    plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.SUB));\n    plainAccessConfig.setGroupPerms(Lists.newArrayList(\"groupB=PUB\"));\n\n    final PlainAccessConfig result = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n    Assertions.assertThat(result).isNotNull();\n    Assert.assertEquals(AclConstants.PUB_SUB, result.getDefaultGroupPerm());\n    Assert.assertEquals(\"newuser\", result.getAccessKey());\n    Assert.assertEquals(\"87654321\", result.getSecretKey());\n    Assert.assertEquals(\"10.10.10.10\", result.getWhiteRemoteAddress());\n    Assert.assertEquals(true, result.isAdmin());\n    final List<String> groupPerms = result.getGroupPerms();\n    Assert.assertEquals(\"groupB=PUB\", groupPerms.get(0));\n    final List<String> topicPerms = result.getTopicPerms();\n    Assert.assertEquals(\"topic-acl=SUB\", topicPerms.get(0));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void createAclAccessConfigMapTest() {\n    PlainAccessConfig existedAccountMap = new PlainAccessConfig();\n    PlainAccessConfig plainAccessConfig = new PlainAccessConfig();\n    plainAccessConfig.setAccessKey(\"admin123\");\n    plainAccessConfig.setSecretKey(\"12345678\");\n    plainAccessConfig.setWhiteRemoteAddress(\"192.168.1.1\");\n    plainAccessConfig.setAdmin(false);\n    plainAccessConfig.setDefaultGroupPerm(AclConstants.SUB_PUB);\n    plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB));\n    plainAccessConfig.setGroupPerms(Lists.newArrayList(\"groupA=SUB\"));\n\n    PlainAccessConfig newAccountsMap = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n\n    Assert.assertEquals(AclConstants.SUB_PUB, newAccountsMap.getDefaultGroupPerm());\n    List<String> groupPerms = newAccountsMap.getGroupPerms();\n    Assert.assertEquals(\"groupA=SUB\", groupPerms.get(0));\n    Assert.assertEquals(\"12345678\", newAccountsMap.getSecretKey());\n    Assert.assertEquals(\"admin123\", newAccountsMap.getAccessKey());\n    Assert.assertEquals(\"192.168.1.1\", newAccountsMap.getWhiteRemoteAddress());\n    List<String> topicPerms = newAccountsMap.getTopicPerms();\n    Assert.assertEquals(\"topic-acl=PUB\", topicPerms.get(0));\n    Assert.assertEquals(false, newAccountsMap.isAdmin());\n    // Test with null existedAccountMap\n    existedAccountMap = null;\n    newAccountsMap = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n    Assert.assertNotNull(newAccountsMap);\n\n    // Test with empty accessKey\n    plainAccessConfig.setAccessKey(\"\");\n    try {\n        newAccountsMap = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n        Assert.fail(\"Expected AclException\");\n    } catch (AclException e) {\n        Assert.assertEquals(\"The accessKey= cannot be null and length should longer than 6\", e.getMessage());\n    }\n\n    // Test with accessKey length less than 6\n    plainAccessConfig.setAccessKey(\"12345\");\n    try {\n        newAccountsMap = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n        Assert.fail(\"Expected AclException\");\n    } catch (AclException e) {\n        Assert.assertEquals(\"The accessKey=12345 cannot be null and length should longer than 6\", e.getMessage());\n    }\n\n    // Test with null secretKey\n    plainAccessConfig.setAccessKey(\"admin123\");\n    plainAccessConfig.setSecretKey(null);\n    newAccountsMap = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n    Assert.assertNull(newAccountsMap.getSecretKey());\n\n    // Test with secretKey length less than 6\n    plainAccessConfig.setSecretKey(\"12345\");\n    try {\n        newAccountsMap = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n        Assert.fail(\"Expected AclException\");\n    } catch (AclException e) {\n        Assert.assertEquals(\"The secretKey=12345 value length should longer than 6\", e.getMessage());\n    }\n}\n",
      "@Test\npublic void createAclAccessConfigMapTest() {\n    PlainAccessConfig existedAccountMap = new PlainAccessConfig();\n    existedAccountMap.setAccessKey(\"admin123\");\n    existedAccountMap.setSecretKey(\"12345678\");\n    existedAccountMap.setWhiteRemoteAddress(\"192.168.1.1\");\n    existedAccountMap.setAdmin(false);\n    existedAccountMap.setDefaultGroupPerm(AclConstants.SUB_PUB);\n    existedAccountMap.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB));\n    existedAccountMap.setGroupPerms(Lists.newArrayList(\"groupA=SUB\"));\n\n    PlainAccessConfig plainAccessConfig = new PlainAccessConfig();\n    plainAccessConfig.setAccessKey(\"newadmin123\");\n    plainAccessConfig.setSecretKey(\"new12345678\");\n    plainAccessConfig.setWhiteRemoteAddress(\"new192.168.1.1\");\n    plainAccessConfig.setAdmin(true);\n    plainAccessConfig.setDefaultGroupPerm(AclConstants.PUB_SUB);\n    plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.SUB));\n    plainAccessConfig.setGroupPerms(Lists.newArrayList(\"newgroupA=PUB\"));\n\n    final PlainAccessConfig newAccountsMap = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n\n    Assert.assertEquals(\"newadmin123\", newAccountsMap.getAccessKey());\n    Assert.assertEquals(\"new12345678\", newAccountsMap.getSecretKey());\n    Assert.assertEquals(\"new192.168.1.1\", newAccountsMap.getWhiteRemoteAddress());\n    Assert.assertEquals(true, newAccountsMap.isAdmin());\n    Assert.assertEquals(AclConstants.PUB_SUB, newAccountsMap.getDefaultGroupPerm());\n    final List<String> newTopicPerms = newAccountsMap.getTopicPerms();\n    Assert.assertEquals(DEFAULT_TOPIC + \"=\" + AclConstants.SUB, newTopicPerms.get(0));\n    final List<String> newGroupPerms = newAccountsMap.getGroupPerms();\n    Assert.assertEquals(\"newgroupA=PUB\", newGroupPerms.get(0));\n    // Test with null existedAccountMap\n    PlainAccessConfig newAccountsMap2 = plainPermissionManager.createAclAccessConfigMap(null, plainAccessConfig);\n    Assert.assertNotNull(newAccountsMap2);\n    Assert.assertEquals(\"newadmin123\", newAccountsMap2.getAccessKey());\n\n    // Test with empty plainAccessConfig\n    PlainAccessConfig newAccountsMap3 = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, new PlainAccessConfig());\n    Assert.assertEquals(existedAccountMap.getAccessKey(), newAccountsMap3.getAccessKey());\n}\n",
      "@Test\npublic void createAclAccessConfigMapTest() {\n    PlainAccessConfig existedAccountMap = new PlainAccessConfig();\n    plainAccessConfig.setAccessKey(\"admin123\");\n    plainAccessConfig.setSecretKey(\"12345678\");\n    plainAccessConfig.setWhiteRemoteAddress(\"192.168.1.1\");\n    plainAccessConfig.setAdmin(false);\n    plainAccessConfig.setDefaultGroupPerm(AclConstants.SUB_PUB);\n    plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB));\n    plainAccessConfig.setGroupPerms(Lists.newArrayList(\"groupA=SUB\"));\n\n    final PlainAccessConfig config = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n\n    Assert.assertEquals(\"admin123\", config.getAccessKey());\n    Assert.assertEquals(\"12345678\", config.getSecretKey());\n    Assert.assertEquals(\"192.168.1.1\", config.getWhiteRemoteAddress());\n    Assert.assertEquals(false, config.isAdmin());\n    Assert.assertEquals(AclConstants.SUB_PUB, config.getDefaultGroupPerm());\n    Assert.assertEquals(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB), config.getTopicPerms());\n    Assert.assertEquals(Lists.newArrayList(\"groupA=SUB\"), config.getGroupPerms());\n    // Test with null existedAccountMap\n    existedAccountMap = null;\n    final PlainAccessConfig newConfig = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n    Assert.assertEquals(\"admin123\", newConfig.getAccessKey());\n    Assert.assertEquals(\"12345678\", newConfig.getSecretKey());\n    Assert.assertEquals(\"192.168.1.1\", newConfig.getWhiteRemoteAddress());\n    Assert.assertEquals(false, newConfig.isAdmin());\n    Assert.assertEquals(AclConstants.SUB_PUB, newConfig.getDefaultGroupPerm());\n    Assert.assertEquals(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB), newConfig.getTopicPerms());\n    Assert.assertEquals(Lists.newArrayList(\"groupA=SUB\"), newConfig.getGroupPerms());\n\n    // Test with empty plainAccessConfig\n    plainAccessConfig.setAccessKey(\"\");\n    plainAccessConfig.setSecretKey(\"\");\n    plainAccessConfig.setWhiteRemoteAddress(\"\");\n    plainAccessConfig.setAdmin(false);\n    plainAccessConfig.setDefaultGroupPerm(\"\");\n    plainAccessConfig.setTopicPerms(null);\n    plainAccessConfig.setGroupPerms(null);\n    try {\n        plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n        Assert.fail(\"Expected AclException\");\n    } catch (AclException e) {\n        Assert.assertEquals(\"The accessKey= cannot be null and length should longer than 6\", e.getMessage());\n    }\n}\n",
      "@Test\npublic void createAclAccessConfigMapTest() {\n    PlainAccessConfig existedAccountMap = new PlainAccessConfig();\n    existedAccountMap.setAccessKey(\"admin123\");\n    existedAccountMap.setSecretKey(\"12345678\");\n    existedAccountMap.setWhiteRemoteAddress(\"192.168.1.1\");\n    existedAccountMap.setAdmin(false);\n    existedAccountMap.setDefaultGroupPerm(AclConstants.SUB_PUB);\n    existedAccountMap.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.PUB));\n    existedAccountMap.setGroupPerms(Lists.newArrayList(\"groupA=SUB\"));\n\n    PlainAccessConfig plainAccessConfig = new PlainAccessConfig();\n    plainAccessConfig.setAccessKey(\"newuser\");\n    plainAccessConfig.setSecretKey(\"87654321\");\n    plainAccessConfig.setWhiteRemoteAddress(\"10.10.10.10\");\n    plainAccessConfig.setAdmin(true);\n    plainAccessConfig.setDefaultGroupPerm(AclConstants.PUB_SUB);\n    plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + \"=\" + AclConstants.SUB));\n    plainAccessConfig.setGroupPerms(Lists.newArrayList(\"groupB=PUB\"));\n\n    final PlainAccessConfig result = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);\n    Assertions.assertThat(result).isNotNull();\n    Assert.assertEquals(AclConstants.PUB_SUB, result.getDefaultGroupPerm());\n    Assert.assertEquals(\"newuser\", result.getAccessKey());\n    Assert.assertEquals(\"87654321\", result.getSecretKey());\n    Assert.assertEquals(\"10.10.10.10\", result.getWhiteRemoteAddress());\n    Assert.assertEquals(true, result.isAdmin());\n    final List<String> groupPerms = result.getGroupPerms();\n    Assert.assertEquals(\"groupB=PUB\", groupPerms.get(0));\n    final List<String> topicPerms = result.getTopicPerms();\n    Assert.assertEquals(\"topic-acl=SUB\", topicPerms.get(0));\n    // Test with null existedAccountMap\n    PlainAccessConfig result2 = plainPermissionManager.createAclAccessConfigMap(null, plainAccessConfig);\n    Assertions.assertThat(result2).isNotNull();\n    Assert.assertEquals(AclConstants.PUB_SUB, result2.getDefaultGroupPerm());\n    Assert.assertEquals(\"newuser\", result2.getAccessKey());\n    Assert.assertEquals(\"87654321\", result2.getSecretKey());\n    Assert.assertEquals(\"10.10.10.10\", result2.getWhiteRemoteAddress());\n    Assert.assertEquals(true, result2.isAdmin());\n    List<String> groupPerms2 = result2.getGroupPerms();\n    Assert.assertEquals(\"groupB=PUB\", groupPerms2.get(0));\n    List<String> topicPerms2 = result2.getTopicPerms();\n    Assert.assertEquals(\"topic-acl=SUB\", topicPerms2.get(0));\n\n    // Test with empty existedAccountMap\n    PlainAccessConfig result3 = plainPermissionManager.createAclAccessConfigMap(new PlainAccessConfig(), plainAccessConfig);\n    Assertions.assertThat(result3).isNotNull();\n    Assert.assertEquals(AclConstants.PUB_SUB, result3.getDefaultGroupPerm());\n    Assert.assertEquals(\"newuser\", result3.getAccessKey());\n    Assert.assertEquals(\"87654321\", result3.getSecretKey());\n    Assert.assertEquals(\"10.10.10.10\", result3.getWhiteRemoteAddress());\n    Assert.assertEquals(true, result3.isAdmin());\n    List<String> groupPerms3 = result3.getGroupPerms();\n    Assert.assertEquals(\"groupB=PUB\", groupPerms3.get(0));\n    List<String> topicPerms3 = result3.getTopicPerms();\n    Assert.assertEquals(\"topic-acl=SUB\", topicPerms3.get(0));\n\n    // Test with null plainAccessConfig\n    Assert.assertThrows(NullPointerException.class, () -> {\n        plainPermissionManager.createAclAccessConfigMap(existedAccountMap, null);\n    });\n\n    // Test with empty plainAccessConfig\n    Assert.assertThrows(NullPointerException.class, () -> {\n        plainPermissionManager.createAclAccessConfigMap(existedAccountMap, new PlainAccessConfig());\n    });\n}\n"
    ]
  },
  "11": {
    "commit_src": "b00c82caccea8d8a23614c1854885d0a187e159e",
    "commit_tgt": "dcf7ccdd9ba92c22a44cde4c1df36c4d1ef6a172",
    "changed_tests": [
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java"
    ],
    "refer_PR": "apache_rocketmq-6651",
    "test_src": ".org.apache.rocketmq.tieredstore.TieredMessageStoreTest#testGetMessageAsync",
    "test_tgt": [
      ".org.apache.rocketmq.tieredstore.TieredMessageStoreTest#testGetMessageAsync"
    ],
    "test_src_code": "    @Test\n    public void testGetMessageAsync() {\n        mockContainer();\n        GetMessageResult result1 = new GetMessageResult();\n        result1.setStatus(GetMessageStatus.FOUND);\n        GetMessageResult result2 = new GetMessageResult();\n        result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n\n        when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));\n        when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        // TieredStorageLevel.FORCE\n        Properties properties = new Properties();\n        properties.setProperty(\"tieredStorageLevel\", \"3\");\n        configuration.update(properties);\n        when(nextStore.checkInDiskByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);\n        Assert.assertSame(result2, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n    }\n",
    "focal_path_src": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/TieredMessageStore.java#getMessageAsync"
    ],
    "focal_path_tgt": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/TieredMessageStore.java#getMessageAsync"
    ],
    "focal_src": [
      "    @Override\n    public CompletableFuture<GetMessageResult> getMessageAsync(String group, String topic,\n        int queueId, long offset, int maxMsgNums, MessageFilter messageFilter) {\n        if (viaTieredStorage(topic, queueId, offset, maxMsgNums)) {\n            Stopwatch stopwatch = Stopwatch.createStarted();\n            return fetcher.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter)\n                .thenApply(result -> {\n                    Attributes latencyAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                        .put(TieredStoreMetricsConstant.LABEL_OPERATION, TieredStoreMetricsConstant.OPERATION_API_GET_MESSAGE)\n                        .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                        .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                        .build();\n                    TieredStoreMetricsManager.apiLatency.record(stopwatch.elapsed(TimeUnit.MILLISECONDS), latencyAttributes);\n\n                    if (result.getStatus() == GetMessageStatus.OFFSET_FOUND_NULL ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_ONE ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        if (next.checkInDiskByConsumeOffset(topic, queueId, offset)) {\n                            logger.debug(\"TieredMessageStore#getMessageAsync: not found message, try to get message from next store: topic: {}, queue: {}, queue offset: {}, tiered store result: {}, min offset: {}, max offset: {}\",\n                                topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                            TieredStoreMetricsManager.fallbackTotal.add(1, latencyAttributes);\n                            return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                        }\n                    }\n                    if (result.getStatus() != GetMessageStatus.FOUND &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_ONE &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        logger.warn(\"TieredMessageStore#getMessageAsync: not found message, and message is not in next store: topic: {}, queue: {}, queue offset: {}, result: {}, min offset: {}, max offset: {}\",\n                            topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                    }\n                    if (result.getStatus() == GetMessageStatus.FOUND) {\n                        Attributes messagesOutAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                            .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                            .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                            .build();\n                        TieredStoreMetricsManager.messagesOutTotal.add(result.getMessageCount(), messagesOutAttributes);\n                    }\n\n                    // fix min or max offset using next store\n                    long minOffsetInQueue = next.getMinOffsetInQueue(topic, queueId);\n                    if (minOffsetInQueue >= 0 && minOffsetInQueue < result.getMinOffset()) {\n                        result.setMinOffset(minOffsetInQueue);\n                    }\n                    long maxOffsetInQueue = next.getMaxOffsetInQueue(topic, queueId);\n                    if (maxOffsetInQueue >= 0 && maxOffsetInQueue > result.getMaxOffset()) {\n                        result.setMaxOffset(maxOffsetInQueue);\n                    }\n                    return result;\n                }).exceptionally(e -> {\n                    logger.error(\"TieredMessageStore#getMessageAsync: get message from tiered store failed: \", e);\n                    return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                });\n        }\n        return next.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter);\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public CompletableFuture<GetMessageResult> getMessageAsync(String group, String topic,\n        int queueId, long offset, int maxMsgNums, MessageFilter messageFilter) {\n        if (viaTieredStorage(topic, queueId, offset, maxMsgNums)) {\n            Stopwatch stopwatch = Stopwatch.createStarted();\n            return fetcher.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter)\n                .thenApply(result -> {\n                    Attributes latencyAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                        .put(TieredStoreMetricsConstant.LABEL_OPERATION, TieredStoreMetricsConstant.OPERATION_API_GET_MESSAGE)\n                        .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                        .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                        .build();\n                    TieredStoreMetricsManager.apiLatency.record(stopwatch.elapsed(TimeUnit.MILLISECONDS), latencyAttributes);\n\n                    if (result.getStatus() == GetMessageStatus.OFFSET_FOUND_NULL ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_ONE ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        if (next.checkInStoreByConsumeOffset(topic, queueId, offset)) {\n                            logger.debug(\"TieredMessageStore#getMessageAsync: not found message, try to get message from next store: topic: {}, queue: {}, queue offset: {}, tiered store result: {}, min offset: {}, max offset: {}\",\n                                topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                            TieredStoreMetricsManager.fallbackTotal.add(1, latencyAttributes);\n                            return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                        }\n                    }\n                    if (result.getStatus() != GetMessageStatus.FOUND &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_ONE &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        logger.warn(\"TieredMessageStore#getMessageAsync: not found message, and message is not in next store: topic: {}, queue: {}, queue offset: {}, result: {}, min offset: {}, max offset: {}\",\n                            topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                    }\n                    if (result.getStatus() == GetMessageStatus.FOUND) {\n                        Attributes messagesOutAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                            .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                            .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                            .build();\n                        TieredStoreMetricsManager.messagesOutTotal.add(result.getMessageCount(), messagesOutAttributes);\n                    }\n\n                    // fix min or max offset using next store\n                    long minOffsetInQueue = next.getMinOffsetInQueue(topic, queueId);\n                    if (minOffsetInQueue >= 0 && minOffsetInQueue < result.getMinOffset()) {\n                        result.setMinOffset(minOffsetInQueue);\n                    }\n                    long maxOffsetInQueue = next.getMaxOffsetInQueue(topic, queueId);\n                    if (maxOffsetInQueue >= 0 && maxOffsetInQueue > result.getMaxOffset()) {\n                        result.setMaxOffset(maxOffsetInQueue);\n                    }\n                    return result;\n                }).exceptionally(e -> {\n                    logger.error(\"TieredMessageStore#getMessageAsync: get message from tiered store failed: \", e);\n                    return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                });\n        }\n        return next.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter);\n    }\n"
    ],
    "test_id": 11,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetMessageAsync() {\n    mockContainer();\n    GetMessageResult result1 = new GetMessageResult();\n    result1.setStatus(GetMessageStatus.FOUND);\n    GetMessageResult result2 = new GetMessageResult();\n    result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n\n    when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));\n    when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    // TieredStorageLevel.FORCE\n    Properties properties = new Properties();\n    properties.setProperty(\"tieredStorageLevel\", \"3\");\n    configuration.update(properties);\n    when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);\n    Assert.assertSame(result2, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n}\n",
      "@Test\npublic void testGetMessageAsync() {\n    mockContainer();\n    GetMessageResult result1 = new GetMessageResult();\n    result1.setStatus(GetMessageStatus.FOUND);\n    GetMessageResult result2 = new GetMessageResult();\n    result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n\n    when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));\n    when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    // TieredStorageLevel.FORCE\n    Properties properties = new Properties();\n    properties.setProperty(\"tieredStorageLevel\", \"3\");\n    configuration.update(properties);\n    when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);\n    Assert.assertSame(result2, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testGetMessageAsync() {\n    mockContainer();\n    GetMessageResult result1 = new GetMessageResult();\n    result1.setStatus(GetMessageStatus.FOUND);\n    GetMessageResult result2 = new GetMessageResult();\n    result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n\n    when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));\n    when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    // TieredStorageLevel.FORCE\n    Properties properties = new Properties();\n    properties.setProperty(\"tieredStorageLevel\", \"3\");\n    configuration.update(properties);\n    when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);\n    Assert.assertSame(result2, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n    // Test with null result\n    when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(null));\n    Assert.assertNull(store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    // Test with exception\n    when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenThrow(new RuntimeException(\"Test exception\"));\n    Assert.assertNull(store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n}\n",
      "@Test\npublic void testGetMessageAsync() {\n    mockContainer();\n    GetMessageResult result1 = new GetMessageResult();\n    result1.setStatus(GetMessageStatus.FOUND);\n    GetMessageResult result2 = new GetMessageResult();\n    result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n\n    when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));\n    when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    // TieredStorageLevel.FORCE\n    Properties properties = new Properties();\n    properties.setProperty(\"tieredStorageLevel\", \"3\");\n    configuration.update(properties);\n    when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);\n    Assert.assertSame(result2, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n    // Test with null result\n    when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(null));\n    Assert.assertNull(store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    // Test with exception\n    when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenThrow(new RuntimeException(\"Test exception\"));\n    Assert.assertNull(store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n}\n"
    ]
  },
  "12": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenNoAck",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenNoAck"
    ],
    "test_src_code": "    @Test\n    public void testConsumeMessageThenNoAck() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        await().atLeast(Duration.ofSeconds(2)).atMost(Duration.ofSeconds(4)).until(notified::get);\n        assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "test_id": 12,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testConsumeMessageThenNoAck() {\n    consumerOrderInfoManager.update(\n        \"attemptId\",\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    await().atLeast(Duration.ofSeconds(2)).atMost(Duration.ofSeconds(4)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n",
      "@Test\npublic void testConsumeMessageThenNoAck() {\n    consumerOrderInfoManager.update(\n        \"attemptId\",\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    await().atLeast(Duration.ofSeconds(2)).atMost(Duration.ofSeconds(4)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testConsumeMessageThenNoAck() {\n    consumerOrderInfoManager.update(\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    await().atLeast(Duration.ofSeconds(2)).atMost(Duration.ofSeconds(4)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n"
    ]
  },
  "13": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenAck",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenAck"
    ],
    "test_src_code": "    @Test\n    public void testConsumeMessageThenAck() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        consumerOrderInfoManager.commitAndNext(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1,\n            popTime\n        );\n        await().atMost(Duration.ofSeconds(1)).until(notified::get);\n        assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "test_id": 13,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testConsumeMessageThenAck() {\n    // Update the order info\n    consumerOrderInfoManager.update(\n        \"attemptId\",\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n\n    // Commit and ack the message\n    consumerOrderInfoManager.commitAndNext(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1,\n        popTime\n    );\n\n    // Wait until the message is notified\n    await().atMost(Duration.ofSeconds(1)).until(notified::get);\n\n    // Assert that the timeout map is empty\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n",
      "@Test\npublic void testConsumeMessageThenAck() {\n    consumerOrderInfoManager.update(\n        \"ATTEMPT_ID\",\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    consumerOrderInfoManager.commitAndNext(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1,\n        popTime\n    );\n    await().atMost(Duration.ofSeconds(1)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testConsumeMessageThenAck() {\n    // Update the order info\n    consumerOrderInfoManager.update(\n        \"attemptId\",\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n\n    // Commit and ack the message\n    consumerOrderInfoManager.commitAndNext(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1,\n        popTime\n    );\n\n    // Wait until the message is notified\n    await().atMost(Duration.ofSeconds(1)).until(notified::get);\n\n    // Assert that the timeout map is empty\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    // Update the order info with a new attemptId\n    consumerOrderInfoManager.update(\n        \"newAttemptId\",\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(2L),\n        new StringBuilder()\n    );\n\n    // Commit and ack the message\n    consumerOrderInfoManager.commitAndNext(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        2,\n        popTime\n    );\n\n    // Wait until the message is notified\n    await().atMost(Duration.ofSeconds(1)).until(notified::get);\n\n    // Assert that the timeout map is empty\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n"
    ]
  },
  "14": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleLonger",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleLonger"
    ],
    "test_src_code": "    @Test\n    public void testConsumeTheChangeInvisibleLonger() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        consumerOrderInfoManager.updateNextVisibleTime(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1,\n            popTime,\n            popTime + 5000\n        );\n        await().atLeast(Duration.ofSeconds(4)).atMost(Duration.ofSeconds(6)).until(notified::get);\n        assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "test_id": 14,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testConsumeTheChangeInvisibleLonger() {\n    consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(1L), new StringBuilder());\n    consumerOrderInfoManager.updateNextVisibleTime(TOPIC, GROUP, QUEUE_ID_0, 1, popTime, popTime + 5000);\n    await().atLeast(Duration.ofSeconds(4)).atMost(Duration.ofSeconds(6)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n",
      "@Test\npublic void testConsumeTheChangeInvisibleLonger() {\n    consumerOrderInfoManager.update(\n        \"attemptId\",\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    consumerOrderInfoManager.updateNextVisibleTime(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1,\n        popTime,\n        popTime + 5000\n    );\n    await().atLeast(Duration.ofSeconds(4)).atMost(Duration.ofSeconds(6)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n",
      "@Test\npublic void testConsumeTheChangeInvisibleLonger() {\n    consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(1L), new StringBuilder());\n    consumerOrderInfoManager.updateNextVisibleTime(TOPIC, GROUP, QUEUE_ID_0, 1, popTime, popTime + 5000);\n    await().atLeast(Duration.ofSeconds(4)).atMost(Duration.ofSeconds(6)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testConsumeTheChangeInvisibleLonger() {\n    consumerOrderInfoManager.update(\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    consumerOrderInfoManager.updateNextVisibleTime(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1,\n        popTime,\n        popTime + 5000\n    );\n    await().atLeast(Duration.ofSeconds(4)).atMost(Duration.ofSeconds(6)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n"
    ]
  },
  "15": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleShorter",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleShorter"
    ],
    "test_src_code": "    @Test\n    public void testConsumeTheChangeInvisibleShorter() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        consumerOrderInfoManager.updateNextVisibleTime(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1,\n            popTime,\n            popTime + 1000\n        );\n        await().atLeast(Duration.ofMillis(500)).atMost(Duration.ofSeconds(2)).until(notified::get);\n        assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "test_id": 15,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testConsumeTheChangeInvisibleShorter() {\n    consumerOrderInfoManager.update(\n        \"ATTEMPT_ID\",\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    consumerOrderInfoManager.updateNextVisibleTime(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1,\n        popTime,\n        popTime + 1000\n    );\n    await().atLeast(Duration.ofMillis(500)).atMost(Duration.ofSeconds(2)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testConsumeTheChangeInvisibleShorter() {\n    consumerOrderInfoManager.update(\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    consumerOrderInfoManager.updateNextVisibleTime(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1,\n        popTime,\n        popTime + 1000\n    );\n    await().atLeast(Duration.ofMillis(500)).atMost(Duration.ofSeconds(2)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n"
    ]
  },
  "16": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testRecover",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testRecover"
    ],
    "test_src_code": "    @Test\n    public void testRecover() {\n        ConsumerOrderInfoManager savedConsumerOrderInfoManager = new ConsumerOrderInfoManager();\n        savedConsumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        String encodedData = savedConsumerOrderInfoManager.encode();\n\n        consumerOrderInfoManager.decode(encodedData);\n        await().atLeast(Duration.ofSeconds(2)).atMost(Duration.ofSeconds(4)).until(notified::get);\n        assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "test_id": 16,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testRecover() {\n    ConsumerOrderInfoManager savedConsumerOrderInfoManager = new ConsumerOrderInfoManager();\n    savedConsumerOrderInfoManager.update(\"ATTEMPT_ID\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(1L), new StringBuilder());\n    String encodedData = savedConsumerOrderInfoManager.encode();\n\n    consumerOrderInfoManager.decode(encodedData);\n    await().atLeast(Duration.ofSeconds(2)).atMost(Duration.ofSeconds(4)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n",
      "@Test\npublic void testRecover() {\n    ConsumerOrderInfoManager savedConsumerOrderInfoManager = new ConsumerOrderInfoManager();\n    savedConsumerOrderInfoManager.update(\n        \"attemptId\",\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    String encodedData = savedConsumerOrderInfoManager.encode();\n\n    consumerOrderInfoManager.decode(encodedData);\n    await().atLeast(Duration.ofSeconds(2)).atMost(Duration.ofSeconds(4)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testRecover() {\n    ConsumerOrderInfoManager savedConsumerOrderInfoManager = new ConsumerOrderInfoManager();\n    savedConsumerOrderInfoManager.update(\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    String encodedData = savedConsumerOrderInfoManager.encode();\n\n    consumerOrderInfoManager.decode(encodedData);\n    await().atLeast(Duration.ofSeconds(2)).atMost(Duration.ofSeconds(4)).until(notified::get);\n    assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n}\n"
    ]
  },
  "17": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testCommitAndNext",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testCommitAndNext",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testCommitAndNext() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        assertEncodeAndDecode();\n        assertEquals(-2, consumerOrderInfoManager.commitAndNext(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1L,\n            popTime - 10\n        ));\n        assertEncodeAndDecode();\n        assertTrue(consumerOrderInfoManager.checkBlock(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            TimeUnit.SECONDS.toMillis(3)\n        ));\n\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1L,\n            popTime\n        ));\n        assertEncodeAndDecode();\n        assertFalse(consumerOrderInfoManager.checkBlock(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            TimeUnit.SECONDS.toMillis(3)\n        ));\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#checkBlock"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#checkBlock"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
      "    public boolean checkBlock(String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(invisibleTime);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
      "    public boolean checkBlock(String attemptId, String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(attemptId, invisibleTime);\n    }\n"
    ],
    "test_id": 17,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testCommitAndNext() {\n    consumerOrderInfoManager.update(\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    assertEncodeAndDecode();\n    assertEquals(-2, consumerOrderInfoManager.commitAndNext(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1L,\n        popTime - 10\n    ));\n    assertEncodeAndDecode();\n    assertTrue(consumerOrderInfoManager.checkBlock(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        TimeUnit.SECONDS.toMillis(3)\n    ));\n\n    assertEquals(2, consumerOrderInfoManager.commitAndNext(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1L,\n        popTime\n    ));\n    assertEncodeAndDecode();\n    assertFalse(consumerOrderInfoManager.checkBlock(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        TimeUnit.SECONDS.toMillis(3)\n    ));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testCommitAndNext() {\n    consumerOrderInfoManager.update(\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        3000,\n        Lists.newArrayList(1L),\n        new StringBuilder()\n    );\n    assertEncodeAndDecode();\n    assertEquals(-2, consumerOrderInfoManager.commitAndNext(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1L,\n        popTime - 10\n    ));\n    assertEncodeAndDecode();\n    assertTrue(consumerOrderInfoManager.checkBlock(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        TimeUnit.SECONDS.toMillis(3)\n    ));\n\n    assertEquals(2, consumerOrderInfoManager.commitAndNext(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        1L,\n        popTime\n    ));\n    assertEncodeAndDecode();\n    assertFalse(consumerOrderInfoManager.checkBlock(\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        TimeUnit.SECONDS.toMillis(3)\n    ));\n}\n"
    ]
  },
  "18": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCount",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCount",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testConsumedCount() {\n        {\n            // consume three new messages\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(1L, 2L, 3L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(1, orderInfoMap.size());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        }\n\n        {\n            // reconsume same messages\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(1L, 2L, 3L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(4, orderInfoMap.size());\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            for (int i = 1; i <= 3; i++) {\n                assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, i)).intValue());\n            }\n        }\n\n        {\n            // reconsume last two message\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(2L, 3L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(3, orderInfoMap.size());\n            assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            for (int i = 2; i <= 3; i++) {\n                assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, i)).intValue());\n            }\n        }\n\n        {\n            // consume a new message and reconsume last message\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(3L, 4L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(2, orderInfoMap.size());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            assertEquals(3, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 3)).intValue());\n        }\n\n        {\n            // consume two new messages\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(5L, 6L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(1, orderInfoMap.size());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        }\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "test_id": 18,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testConsumedCount() {\n    {\n        // consume three new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(1L, 2L, 3L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(1, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    }\n\n    {\n        // reconsume same messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(1L, 2L, 3L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        for (int i = 1; i <= 3; i++) {\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, i)).intValue());\n        }\n    }\n\n    {\n        // reconsume last two message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(2L, 3L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(3, orderInfoMap.size());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        for (int i = 2; i <= 3; i++) {\n            assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, i)).intValue());\n        }\n    }\n\n    {\n        // consume a new message and reconsume last message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(3L, 4L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(2, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(3, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 3)).intValue());\n    }\n\n    {\n        // consume two new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(5L, 6L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(1, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    }\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testConsumedCount() {\n    {\n        // consume three new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(1L, 2L, 3L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(1, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    }\n\n    {\n        // reconsume same messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(1L, 2L, 3L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        for (int i = 1; i <= 3; i++) {\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, i)).intValue());\n        }\n    }\n\n    {\n        // reconsume last two message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(2L, 3L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(3, orderInfoMap.size());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        for (int i = 2; i <= 3; i++) {\n            assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, i)).intValue());\n        }\n    }\n\n    {\n        // consume a new message and reconsume last message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(3L, 4L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(2, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(3, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 3)).intValue());\n    }\n\n    {\n        // consume two new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(5L, 6L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(1, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    }\n    {\n        // consume two new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(7L, 8L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(1, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    }\n\n    {\n        // consume two new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(9L, 10L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(1, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    }\n}\n"
    ]
  },
  "19": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCountForMultiQueue",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCountForMultiQueue",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testConsumedCountForMultiQueue() {\n        {\n            // consume two new messages\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(0L),\n                orderInfoBuilder\n            );\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_1,\n                popTime,\n                3000,\n                Lists.newArrayList(0L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(2, orderInfoMap.size());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        }\n        {\n            // reconsume two message\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(0L),\n                orderInfoBuilder\n            );\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_1,\n                popTime,\n                3000,\n                Lists.newArrayList(0L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(4, orderInfoMap.size());\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n        }\n        {\n            // reconsume with a new message\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(0L, 1L),\n                orderInfoBuilder\n            );\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_1,\n                popTime,\n                3000,\n                Lists.newArrayList(0L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(4, orderInfoMap.size());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n            assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n            assertNull(orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 1L)));\n            assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n        }\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "test_id": 19,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testConsumedCountForMultiQueue() {\n    {\n        // consume two new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(2, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n    }\n    {\n        // reconsume two message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n    {\n        // reconsume with a new message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L, 1L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertNull(orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 1L)));\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n}\n",
      "@Test\npublic void testConsumedCountForMultiQueue() {\n    {\n        // consume two new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(2, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n    }\n    {\n        // reconsume two message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n    {\n        // reconsume with a new message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L, 1L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertNull(orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 1L)));\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n}\n",
      "@Test\npublic void testConsumedCountForMultiQueue() {\n    String attemptId = UUID.randomUUID().toString();\n    {\n        // consume two new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(2, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n    }\n    {\n        // reconsume two message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n    {\n        // reconsume with a new message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L, 1L), orderInfoBuilder);\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertNull(orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 1L)));\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testConsumedCountForMultiQueue() {\n    {\n        // consume two new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(2, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n    }\n    {\n        // reconsume two message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n    {\n        // reconsume with a new message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L, 1L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertNull(orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 1L)));\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n    // Test for null values\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, null, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, null, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(0, orderInfoMap.size());\n    }\n\n    // Test for empty values\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, \"\", GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, \"\", QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(0, orderInfoMap.size());\n    }\n\n    // Test for negative queueId\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, -1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(0, orderInfoMap.size());\n    }\n\n    // Test for zero invisibleTime\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 0, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(1, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    }\n}\n",
      "@Test\npublic void testConsumedCountForMultiQueue() {\n    {\n        // consume two new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(2, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n    }\n    {\n        // reconsume two message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n    {\n        // reconsume with a new message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L, 1L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertNull(orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 1L)));\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n    // Test for null values\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, null, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, null, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(0, orderInfoMap.size());\n    }\n\n    // Test for empty values\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, \"\", GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, \"\", QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(0, orderInfoMap.size());\n    }\n\n    // Test for negative queueId\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, -1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(0, orderInfoMap.size());\n    }\n\n    // Test for zero invisibleTime\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 0, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(1, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    }\n}\n",
      "@Test\npublic void testConsumedCountForMultiQueue() {\n    String attemptId = UUID.randomUUID().toString();\n    {\n        // consume two new messages\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(2, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n    }\n    {\n        // reconsume two message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n    {\n        // reconsume with a new message\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L, 1L), orderInfoBuilder);\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(4, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n        assertNull(orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 1L)));\n        assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n    }\n    // Test for null topic and group\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(attemptId, false, null, GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, null, QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(0, orderInfoMap.size());\n    }\n\n    // Test for empty topic and group\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(attemptId, false, \"\", GROUP, QUEUE_ID_0, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, \"\", QUEUE_ID_1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(0, orderInfoMap.size());\n    }\n\n    // Test for negative queueId\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, -1, popTime, 3000, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(0, orderInfoMap.size());\n    }\n\n    // Test for zero invisibleTime\n    {\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(attemptId, false, TOPIC, GROUP, QUEUE_ID_0, popTime, 0, Lists.newArrayList(0L), orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(1, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    }\n}\n"
    ]
  },
  "20": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testUpdateNextVisibleTime",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testUpdateNextVisibleTime",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testUpdateNextVisibleTime() {\n        long invisibleTime = 3000;\n\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(1L, 2L, 3L),\n            orderInfoBuilder\n        );\n\n        consumerOrderInfoManager.updateNextVisibleTime(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime, System.currentTimeMillis() + invisibleTime);\n        assertEncodeAndDecode();\n\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 1L, popTime));\n        assertEncodeAndDecode();\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 3L, popTime));\n        assertEncodeAndDecode();\n\n        await().atMost(Duration.ofSeconds(invisibleTime + 1)).until(() -> !consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n\n        orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            orderInfoBuilder\n        );\n\n        consumerOrderInfoManager.updateNextVisibleTime(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime, System.currentTimeMillis() + invisibleTime);\n        assertEncodeAndDecode();\n\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 3L, popTime));\n        assertEncodeAndDecode();\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 4L, popTime));\n        assertEncodeAndDecode();\n        assertTrue(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n\n        assertEquals(5L, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime));\n        assertEncodeAndDecode();\n        assertFalse(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#checkBlock"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#checkBlock"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
      "    public boolean checkBlock(String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(invisibleTime);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
      "    public boolean checkBlock(String attemptId, String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(attemptId, invisibleTime);\n    }\n"
    ],
    "test_id": 20,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testUpdateNextVisibleTime() {\n    long invisibleTime = 3000;\n\n    StringBuilder orderInfoBuilder = new StringBuilder();\n    consumerOrderInfoManager.update(\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        1,\n        Lists.newArrayList(1L, 2L, 3L),\n        orderInfoBuilder\n    );\n\n    consumerOrderInfoManager.updateNextVisibleTime(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime, System.currentTimeMillis() + invisibleTime);\n    assertEncodeAndDecode();\n\n    assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 1L, popTime));\n    assertEncodeAndDecode();\n    assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 3L, popTime));\n    assertEncodeAndDecode();\n\n    await().atMost(Duration.ofSeconds(invisibleTime + 1)).until(() -> !consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n\n    orderInfoBuilder = new StringBuilder();\n    consumerOrderInfoManager.update(\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        1,\n        Lists.newArrayList(2L, 3L, 4L),\n        orderInfoBuilder\n    );\n\n    consumerOrderInfoManager.updateNextVisibleTime(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime, System.currentTimeMillis() + invisibleTime);\n    assertEncodeAndDecode();\n\n    assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 3L, popTime));\n    assertEncodeAndDecode();\n    assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 4L, popTime));\n    assertEncodeAndDecode();\n    assertTrue(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n\n    assertEquals(5L, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime));\n    assertEncodeAndDecode();\n    assertFalse(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testUpdateNextVisibleTime() {\n    long invisibleTime = 3000;\n\n    StringBuilder orderInfoBuilder = new StringBuilder();\n    consumerOrderInfoManager.update(\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        1,\n        Lists.newArrayList(1L, 2L, 3L),\n        orderInfoBuilder\n    );\n\n    consumerOrderInfoManager.updateNextVisibleTime(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime, System.currentTimeMillis() + invisibleTime);\n    assertEncodeAndDecode();\n\n    assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 1L, popTime));\n    assertEncodeAndDecode();\n    assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 3L, popTime));\n    assertEncodeAndDecode();\n\n    await().atMost(Duration.ofSeconds(invisibleTime + 1)).until(() -> !consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n\n    orderInfoBuilder = new StringBuilder();\n    consumerOrderInfoManager.update(\n        false,\n        TOPIC,\n        GROUP,\n        QUEUE_ID_0,\n        popTime,\n        1,\n        Lists.newArrayList(2L, 3L, 4L),\n        orderInfoBuilder\n    );\n\n    consumerOrderInfoManager.updateNextVisibleTime(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime, System.currentTimeMillis() + invisibleTime);\n    assertEncodeAndDecode();\n\n    assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 3L, popTime));\n    assertEncodeAndDecode();\n    assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 4L, popTime));\n    assertEncodeAndDecode();\n    assertTrue(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n\n    assertEquals(5L, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime));\n    assertEncodeAndDecode();\n    assertFalse(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n}\n"
    ]
  },
  "21": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testAutoCleanAndEncode",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testAutoCleanAndEncode",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testAutoCleanAndEncode() {\n        BrokerConfig brokerConfig = new BrokerConfig();\n        BrokerController brokerController = mock(BrokerController.class);\n        TopicConfigManager topicConfigManager = mock(TopicConfigManager.class);\n        when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n        when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n\n        SubscriptionGroupManager subscriptionGroupManager = mock(SubscriptionGroupManager.class);\n        when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n        ConcurrentMap<String, SubscriptionGroupConfig> subscriptionGroupConfigConcurrentMap = new ConcurrentHashMap<>();\n        subscriptionGroupConfigConcurrentMap.put(GROUP, new SubscriptionGroupConfig());\n        when(subscriptionGroupManager.getSubscriptionGroupTable()).thenReturn(subscriptionGroupConfigConcurrentMap);\n\n        TopicConfig topicConfig = new TopicConfig(TOPIC);\n        when(topicConfigManager.selectTopicConfig(eq(TOPIC))).thenReturn(topicConfig);\n\n        ConsumerOrderInfoManager consumerOrderInfoManager = new ConsumerOrderInfoManager(brokerController);\n\n        {\n            consumerOrderInfoManager.update(false,\n                \"errTopic\",\n                \"errGroup\",\n                QUEUE_ID_0,\n                popTime,\n                1,\n                Lists.newArrayList(2L, 3L, 4L),\n                new StringBuilder());\n\n            consumerOrderInfoManager.autoClean();\n            assertEquals(0, consumerOrderInfoManager.getTable().size());\n        }\n        {\n            consumerOrderInfoManager.update(false,\n                TOPIC,\n                \"errGroup\",\n                QUEUE_ID_0,\n                popTime,\n                1,\n                Lists.newArrayList(2L, 3L, 4L),\n                new StringBuilder());\n\n            consumerOrderInfoManager.autoClean();\n            assertEquals(0, consumerOrderInfoManager.getTable().size());\n        }\n        {\n            topicConfig.setReadQueueNums(0);\n            consumerOrderInfoManager.update(false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                1,\n                Lists.newArrayList(2L, 3L, 4L),\n                new StringBuilder());\n\n            await().atMost(Duration.ofSeconds(1)).until(() -> {\n                consumerOrderInfoManager.autoClean();\n                return consumerOrderInfoManager.getTable().size() == 0;\n            });\n        }\n        {\n            topicConfig.setReadQueueNums(8);\n            consumerOrderInfoManager.update(false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                1,\n                Lists.newArrayList(2L, 3L, 4L),\n                new StringBuilder());\n\n            consumerOrderInfoManager.autoClean();\n            assertEquals(1, consumerOrderInfoManager.getTable().size());\n            for (ConcurrentHashMap<Integer, ConsumerOrderInfoManager.OrderInfo> orderInfoMap : consumerOrderInfoManager.getTable().values()) {\n                assertEquals(1, orderInfoMap.size());\n                assertNotNull(orderInfoMap.get(QUEUE_ID_0));\n                break;\n            }\n        }\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n"
    ],
    "test_id": 21,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testAutoCleanAndEncode() {\n    BrokerConfig brokerConfig = new BrokerConfig();\n    BrokerController brokerController = mock(BrokerController.class);\n    TopicConfigManager topicConfigManager = mock(TopicConfigManager.class);\n    when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n    when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n\n    SubscriptionGroupManager subscriptionGroupManager = mock(SubscriptionGroupManager.class);\n    when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n    ConcurrentMap<String, SubscriptionGroupConfig> subscriptionGroupConfigConcurrentMap = new ConcurrentHashMap<>();\n    subscriptionGroupConfigConcurrentMap.put(GROUP, new SubscriptionGroupConfig());\n    when(subscriptionGroupManager.getSubscriptionGroupTable()).thenReturn(subscriptionGroupConfigConcurrentMap);\n\n    TopicConfig topicConfig = new TopicConfig(TOPIC);\n    when(topicConfigManager.selectTopicConfig(eq(TOPIC))).thenReturn(topicConfig);\n\n    ConsumerOrderInfoManager consumerOrderInfoManager = new ConsumerOrderInfoManager(brokerController);\n\n    {\n        consumerOrderInfoManager.update(\"attemptId1\", false, \"errTopic\", \"errGroup\", QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        consumerOrderInfoManager.update(\"attemptId2\", false, TOPIC, \"errGroup\", QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        topicConfig.setReadQueueNums(0);\n        consumerOrderInfoManager.update(\"attemptId3\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            consumerOrderInfoManager.autoClean();\n            return consumerOrderInfoManager.getTable().size() == 0;\n        });\n    }\n    {\n        topicConfig.setReadQueueNums(8);\n        consumerOrderInfoManager.update(\"attemptId4\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n        consumerOrderInfoManager.autoClean();\n        assertEquals(1, consumerOrderInfoManager.getTable().size());\n        for (ConcurrentHashMap<Integer, ConsumerOrderInfoManager.OrderInfo> orderInfoMap : consumerOrderInfoManager.getTable().values()) {\n            assertEquals(1, orderInfoMap.size());\n            assertNotNull(orderInfoMap.get(QUEUE_ID_0));\n            break;\n        }\n    }\n}\n",
      "@Test\npublic void testAutoCleanAndEncode() {\n    BrokerConfig brokerConfig = new BrokerConfig();\n    BrokerController brokerController = mock(BrokerController.class);\n    TopicConfigManager topicConfigManager = mock(TopicConfigManager.class);\n    when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n    when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n\n    SubscriptionGroupManager subscriptionGroupManager = mock(SubscriptionGroupManager.class);\n    when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n    ConcurrentMap<String, SubscriptionGroupConfig> subscriptionGroupConfigConcurrentMap = new ConcurrentHashMap<>();\n    subscriptionGroupConfigConcurrentMap.put(GROUP, new SubscriptionGroupConfig());\n    when(subscriptionGroupManager.getSubscriptionGroupTable()).thenReturn(subscriptionGroupConfigConcurrentMap);\n\n    TopicConfig topicConfig = new TopicConfig(TOPIC);\n    when(topicConfigManager.selectTopicConfig(eq(TOPIC))).thenReturn(topicConfig);\n\n    ConsumerOrderInfoManager consumerOrderInfoManager = new ConsumerOrderInfoManager(brokerController);\n\n    {\n        consumerOrderInfoManager.update(\"attemptId\", false, \"errTopic\", \"errGroup\", QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, \"errGroup\", QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        topicConfig.setReadQueueNums(0);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            consumerOrderInfoManager.autoClean();\n            return consumerOrderInfoManager.getTable().size() == 0;\n        });\n    }\n    {\n        topicConfig.setReadQueueNums(8);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(1, consumerOrderInfoManager.getTable().size());\n        for (ConcurrentHashMap<Integer, ConsumerOrderInfoManager.OrderInfo> orderInfoMap : consumerOrderInfoManager.getTable().values()) {\n            assertEquals(1, orderInfoMap.size());\n            assertNotNull(orderInfoMap.get(QUEUE_ID_0));\n            break;\n        }\n    }\n}\n",
      "@Test\npublic void testAutoCleanAndEncode() {\n    BrokerConfig brokerConfig = new BrokerConfig();\n    BrokerController brokerController = mock(BrokerController.class);\n    TopicConfigManager topicConfigManager = mock(TopicConfigManager.class);\n    when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n    when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n\n    SubscriptionGroupManager subscriptionGroupManager = mock(SubscriptionGroupManager.class);\n    when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n    ConcurrentMap<String, SubscriptionGroupConfig> subscriptionGroupConfigConcurrentMap = new ConcurrentHashMap<>();\n    subscriptionGroupConfigConcurrentMap.put(GROUP, new SubscriptionGroupConfig());\n    when(subscriptionGroupManager.getSubscriptionGroupTable()).thenReturn(subscriptionGroupConfigConcurrentMap);\n\n    TopicConfig topicConfig = new TopicConfig(TOPIC);\n    when(topicConfigManager.selectTopicConfig(eq(TOPIC))).thenReturn(topicConfig);\n\n    ConsumerOrderInfoManager consumerOrderInfoManager = new ConsumerOrderInfoManager(brokerController);\n\n    {\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            \"errTopic\",\n            \"errGroup\",\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            TOPIC,\n            \"errGroup\",\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        topicConfig.setReadQueueNums(0);\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            consumerOrderInfoManager.autoClean();\n            return consumerOrderInfoManager.getTable().size() == 0;\n        });\n    }\n    {\n        topicConfig.setReadQueueNums(8);\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(1, consumerOrderInfoManager.getTable().size());\n        for (ConcurrentHashMap<Integer, ConsumerOrderInfoManager.OrderInfo> orderInfoMap : consumerOrderInfoManager.getTable().values()) {\n            assertEquals(1, orderInfoMap.size());\n            assertNotNull(orderInfoMap.get(QUEUE_ID_0));\n            break;\n        }\n    }\n}\n",
      "@Test\npublic void testAutoCleanAndEncode() {\n    BrokerConfig brokerConfig = new BrokerConfig();\n    BrokerController brokerController = mock(BrokerController.class);\n    TopicConfigManager topicConfigManager = mock(TopicConfigManager.class);\n    when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n    when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n\n    SubscriptionGroupManager subscriptionGroupManager = mock(SubscriptionGroupManager.class);\n    when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n    ConcurrentMap<String, SubscriptionGroupConfig> subscriptionGroupConfigConcurrentMap = new ConcurrentHashMap<>();\n    subscriptionGroupConfigConcurrentMap.put(GROUP, new SubscriptionGroupConfig());\n    when(subscriptionGroupManager.getSubscriptionGroupTable()).thenReturn(subscriptionGroupConfigConcurrentMap);\n\n    TopicConfig topicConfig = new TopicConfig(TOPIC);\n    when(topicConfigManager.selectTopicConfig(eq(TOPIC))).thenReturn(topicConfig);\n\n    ConsumerOrderInfoManager consumerOrderInfoManager = new ConsumerOrderInfoManager(brokerController);\n\n    {\n        consumerOrderInfoManager.update(\"attemptId\", false,\n            \"errTopic\",\n            \"errGroup\",\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        consumerOrderInfoManager.update(\"attemptId\", false,\n            TOPIC,\n            \"errGroup\",\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        topicConfig.setReadQueueNums(0);\n        consumerOrderInfoManager.update(\"attemptId\", false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            consumerOrderInfoManager.autoClean();\n            return consumerOrderInfoManager.getTable().size() == 0;\n        });\n    }\n    {\n        topicConfig.setReadQueueNums(8);\n        consumerOrderInfoManager.update(\"attemptId\", false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(1, consumerOrderInfoManager.getTable().size());\n        for (ConcurrentHashMap<Integer, ConsumerOrderInfoManager.OrderInfo> orderInfoMap : consumerOrderInfoManager.getTable().values()) {\n            assertEquals(1, orderInfoMap.size());\n            assertNotNull(orderInfoMap.get(QUEUE_ID_0));\n            break;\n        }\n    }\n}\n",
      "@Test\npublic void testAutoCleanAndEncode() {\n    BrokerConfig brokerConfig = new BrokerConfig();\n    BrokerController brokerController = mock(BrokerController.class);\n    TopicConfigManager topicConfigManager = mock(TopicConfigManager.class);\n    when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n    when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n\n    SubscriptionGroupManager subscriptionGroupManager = mock(SubscriptionGroupManager.class);\n    when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n    ConcurrentMap<String, SubscriptionGroupConfig> subscriptionGroupConfigConcurrentMap = new ConcurrentHashMap<>();\n    subscriptionGroupConfigConcurrentMap.put(GROUP, new SubscriptionGroupConfig());\n    when(subscriptionGroupManager.getSubscriptionGroupTable()).thenReturn(subscriptionGroupConfigConcurrentMap);\n\n    TopicConfig topicConfig = new TopicConfig(TOPIC);\n    when(topicConfigManager.selectTopicConfig(eq(TOPIC))).thenReturn(topicConfig);\n\n    ConsumerOrderInfoManager consumerOrderInfoManager = new ConsumerOrderInfoManager(brokerController);\n\n    {\n        consumerOrderInfoManager.update(\"attemptId\", false,\n            \"errTopic\",\n            \"errGroup\",\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        consumerOrderInfoManager.update(\"attemptId\", false,\n            TOPIC,\n            \"errGroup\",\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        topicConfig.setReadQueueNums(0);\n        consumerOrderInfoManager.update(\"attemptId\", false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            consumerOrderInfoManager.autoClean();\n            return consumerOrderInfoManager.getTable().size() == 0;\n        });\n    }\n    {\n        topicConfig.setReadQueueNums(8);\n        consumerOrderInfoManager.update(\"attemptId\", false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(1, consumerOrderInfoManager.getTable().size());\n        for (ConcurrentHashMap<Integer, ConsumerOrderInfoManager.OrderInfo> orderInfoMap : consumerOrderInfoManager.getTable().values()) {\n            assertEquals(1, orderInfoMap.size());\n            assertNotNull(orderInfoMap.get(QUEUE_ID_0));\n            break;\n        }\n    }\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testAutoCleanAndEncode() {\n    BrokerConfig brokerConfig = new BrokerConfig();\n    BrokerController brokerController = mock(BrokerController.class);\n    TopicConfigManager topicConfigManager = mock(TopicConfigManager.class);\n    when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n    when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n\n    SubscriptionGroupManager subscriptionGroupManager = mock(SubscriptionGroupManager.class);\n    when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n    ConcurrentMap<String, SubscriptionGroupConfig> subscriptionGroupConfigConcurrentMap = new ConcurrentHashMap<>();\n    subscriptionGroupConfigConcurrentMap.put(GROUP, new SubscriptionGroupConfig());\n    when(subscriptionGroupManager.getSubscriptionGroupTable()).thenReturn(subscriptionGroupConfigConcurrentMap);\n\n    TopicConfig topicConfig = new TopicConfig(TOPIC);\n    when(topicConfigManager.selectTopicConfig(eq(TOPIC))).thenReturn(topicConfig);\n\n    ConsumerOrderInfoManager consumerOrderInfoManager = new ConsumerOrderInfoManager(brokerController);\n\n    {\n        consumerOrderInfoManager.update(\"attemptId\", false, \"errTopic\", \"errGroup\", QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, \"errGroup\", QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        topicConfig.setReadQueueNums(0);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            consumerOrderInfoManager.autoClean();\n            return consumerOrderInfoManager.getTable().size() == 0;\n        });\n    }\n    {\n        topicConfig.setReadQueueNums(8);\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(1, consumerOrderInfoManager.getTable().size());\n        for (ConcurrentHashMap<Integer, ConsumerOrderInfoManager.OrderInfo> orderInfoMap : consumerOrderInfoManager.getTable().values()) {\n            assertEquals(1, orderInfoMap.size());\n            assertNotNull(orderInfoMap.get(QUEUE_ID_0));\n            break;\n        }\n    }\n    // Add more test cases to cover the uncovered lines and branches\n    {\n        // Test when the topic and group are the same\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n        assertEquals(1, consumerOrderInfoManager.getTable().size());\n        assertNotNull(consumerOrderInfoManager.getTable().get(consumerOrderInfoManager.buildKey(TOPIC, GROUP)));\n    }\n\n    {\n        // Test when the topic and group are different\n        consumerOrderInfoManager.update(\"attemptId\", false, \"diffTopic\", \"diffGroup\", QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n        assertEquals(2, consumerOrderInfoManager.getTable().size());\n        assertNotNull(consumerOrderInfoManager.getTable().get(consumerOrderInfoManager.buildKey(\"diffTopic\", \"diffGroup\")));\n    }\n\n    {\n        // Test when the queueId is the same\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n        assertEquals(1, consumerOrderInfoManager.getTable().get(consumerOrderInfoManager.buildKey(TOPIC, GROUP)).size());\n        assertNotNull(consumerOrderInfoManager.getTable().get(consumerOrderInfoManager.buildKey(TOPIC, GROUP)).get(QUEUE_ID_0));\n    }\n\n    {\n        // Test when the queueId is different\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n        assertEquals(2, consumerOrderInfoManager.getTable().get(consumerOrderInfoManager.buildKey(TOPIC, GROUP)).size());\n        assertNotNull(consumerOrderInfoManager.getTable().get(consumerOrderInfoManager.buildKey(TOPIC, GROUP)).get(QUEUE_ID_1));\n    }\n\n    {\n        // Test when the orderInfo is null\n        assertNull(consumerOrderInfoManager.getTable().get(consumerOrderInfoManager.buildKey(TOPIC, GROUP)).get(QUEUE_ID_0));\n    }\n\n    {\n        // Test when the orderInfo is not null\n        consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n        assertNotNull(consumerOrderInfoManager.getTable().get(consumerOrderInfoManager.buildKey(TOPIC, GROUP)).get(QUEUE_ID_0));\n    }\n}\n",
      "@Test\npublic void testAutoCleanAndEncode() {\n    BrokerConfig brokerConfig = new BrokerConfig();\n    BrokerController brokerController = mock(BrokerController.class);\n    TopicConfigManager topicConfigManager = mock(TopicConfigManager.class);\n    when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n    when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n\n    SubscriptionGroupManager subscriptionGroupManager = mock(SubscriptionGroupManager.class);\n    when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n    ConcurrentMap<String, SubscriptionGroupConfig> subscriptionGroupConfigConcurrentMap = new ConcurrentHashMap<>();\n    subscriptionGroupConfigConcurrentMap.put(GROUP, new SubscriptionGroupConfig());\n    when(subscriptionGroupManager.getSubscriptionGroupTable()).thenReturn(subscriptionGroupConfigConcurrentMap);\n\n    TopicConfig topicConfig = new TopicConfig(TOPIC);\n    when(topicConfigManager.selectTopicConfig(eq(TOPIC))).thenReturn(topicConfig);\n\n    ConsumerOrderInfoManager consumerOrderInfoManager = new ConsumerOrderInfoManager(brokerController);\n\n    {\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            \"errTopic\",\n            \"errGroup\",\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            TOPIC,\n            \"errGroup\",\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n    {\n        topicConfig.setReadQueueNums(0);\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            consumerOrderInfoManager.autoClean();\n            return consumerOrderInfoManager.getTable().size() == 0;\n        });\n    }\n    {\n        topicConfig.setReadQueueNums(8);\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(1, consumerOrderInfoManager.getTable().size());\n        for (ConcurrentHashMap<Integer, ConsumerOrderInfoManager.OrderInfo> orderInfoMap : consumerOrderInfoManager.getTable().values()) {\n            assertEquals(1, orderInfoMap.size());\n            assertNotNull(orderInfoMap.get(QUEUE_ID_0));\n            break;\n        }\n    }\n    // Add more test cases to cover the uncovered lines and branches\n    {\n        // Test case for the case where the key is null\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            null,\n            \"errGroup\",\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n\n    {\n        // Test case for the case where the key is empty\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            \"\",\n            \"errGroup\",\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n\n    {\n        // Test case for the case where the orderInfo is null\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            null);\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(0, consumerOrderInfoManager.getTable().size());\n    }\n\n    {\n        // Test case for the case where the orderInfoBuilder is null\n        consumerOrderInfoManager.update(\"errAttemptId\", false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n\n        consumerOrderInfoManager.autoClean();\n        assertEquals(1, consumerOrderInfoManager.getTable().size());\n        for (ConcurrentHashMap<Integer, ConsumerOrderInfoManager.OrderInfo> orderInfoMap : consumerOrderInfoManager.getTable().values()) {\n            assertEquals(1, orderInfoMap.size());\n            assertNotNull(orderInfoMap.get(QUEUE_ID_0));\n            break;\n        }\n    }\n}\n"
    ]
  },
  "22": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testLoadFromOldVersionOrderInfoData",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testLoadFromOldVersionOrderInfoData",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testLoadFromOldVersionOrderInfoData() {\n        consumerOrderInfoManager.update(false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n        ConsumerOrderInfoManager.OrderInfo orderInfo = consumerOrderInfoManager.getTable().values().stream().findFirst()\n            .get().get(QUEUE_ID_0);\n\n        orderInfo.setInvisibleTime(null);\n        orderInfo.setOffsetConsumedCount(null);\n        orderInfo.setOffsetNextVisibleTime(null);\n\n        String dataEncoded = consumerOrderInfoManager.encode();\n\n        consumerOrderInfoManager.decode(dataEncoded);\n        assertTrue(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, 3000));\n\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(3L, 4L, 5L),\n            orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(3, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 3)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 4)).intValue());\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#checkBlock"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
      "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#checkBlock"
    ],
    "focal_src": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
      "    public boolean checkBlock(String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(invisibleTime);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
      "    public boolean checkBlock(String attemptId, String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(attemptId, invisibleTime);\n    }\n"
    ],
    "test_id": 22,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testLoadFromOldVersionOrderInfoData() {\n    consumerOrderInfoManager.update(\"attemptId1\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n    ConsumerOrderInfoManager.OrderInfo orderInfo = consumerOrderInfoManager.getTable().values().stream().findFirst()\n        .get().get(QUEUE_ID_0);\n\n    orderInfo.setInvisibleTime(null);\n    orderInfo.setOffsetConsumedCount(null);\n    orderInfo.setOffsetNextVisibleTime(null);\n\n    String dataEncoded = consumerOrderInfoManager.encode();\n\n    consumerOrderInfoManager.decode(dataEncoded);\n    assertTrue(consumerOrderInfoManager.checkBlock(\"attemptId1\", TOPIC, GROUP, QUEUE_ID_0, 3000));\n\n    StringBuilder orderInfoBuilder = new StringBuilder();\n    consumerOrderInfoManager.update(\"attemptId2\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(3L, 4L, 5L), orderInfoBuilder);\n    assertEncodeAndDecode();\n    Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n    assertEquals(3, orderInfoMap.size());\n    assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 3)).intValue());\n    assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 4)).intValue());\n}\n",
      "@Test\npublic void testLoadFromOldVersionOrderInfoData() {\n    consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n    ConsumerOrderInfoManager.OrderInfo orderInfo = consumerOrderInfoManager.getTable().values().stream().findFirst()\n        .get().get(QUEUE_ID_0);\n\n    orderInfo.setInvisibleTime(null);\n    orderInfo.setOffsetConsumedCount(null);\n    orderInfo.setOffsetNextVisibleTime(null);\n\n    String dataEncoded = consumerOrderInfoManager.encode();\n\n    consumerOrderInfoManager.decode(dataEncoded);\n    assertTrue(consumerOrderInfoManager.checkBlock(\"attemptId\", TOPIC, GROUP, QUEUE_ID_0, 3000));\n\n    StringBuilder orderInfoBuilder = new StringBuilder();\n    consumerOrderInfoManager.update(\"attemptId\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(3L, 4L, 5L), orderInfoBuilder);\n    assertEncodeAndDecode();\n    Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n    assertEquals(3, orderInfoMap.size());\n    assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 3)).intValue());\n    assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 4)).intValue());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testLoadFromOldVersionOrderInfoData() {\n    consumerOrderInfoManager.update(\"attemptId1\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(2L, 3L, 4L), new StringBuilder());\n    ConsumerOrderInfoManager.OrderInfo orderInfo = consumerOrderInfoManager.getTable().values().stream().findFirst()\n        .get().get(QUEUE_ID_0);\n\n    orderInfo.setInvisibleTime(null);\n    orderInfo.setOffsetConsumedCount(null);\n    orderInfo.setOffsetNextVisibleTime(null);\n\n    String dataEncoded = consumerOrderInfoManager.encode();\n\n    consumerOrderInfoManager.decode(dataEncoded);\n    assertTrue(consumerOrderInfoManager.checkBlock(\"attemptId1\", TOPIC, GROUP, QUEUE_ID_0, 3000));\n\n    StringBuilder orderInfoBuilder = new StringBuilder();\n    consumerOrderInfoManager.update(\"attemptId2\", false, TOPIC, GROUP, QUEUE_ID_0, popTime, 1, Lists.newArrayList(3L, 4L, 5L), orderInfoBuilder);\n    assertEncodeAndDecode();\n    Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n    assertEquals(3, orderInfoMap.size());\n    assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n    assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 3)).intValue());\n    assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 4)).intValue());\n    // Testing the uncovered lines and branches\n    consumerOrderInfoManager.update(\"attemptId3\", true, TOPIC, GROUP, QUEUE_ID_1, popTime, 1, Lists.newArrayList(6L, 7L, 8L), new StringBuilder());\n    assertTrue(consumerOrderInfoManager.checkBlock(\"attemptId3\", TOPIC, GROUP, QUEUE_ID_1, 3000));\n\n    consumerOrderInfoManager.update(\"attemptId4\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 1, Lists.newArrayList(6L, 7L, 8L), new StringBuilder());\n    assertFalse(consumerOrderInfoManager.checkBlock(\"attemptId4\", TOPIC, GROUP, QUEUE_ID_1, 3000));\n\n    consumerOrderInfoManager.update(\"attemptId5\", false, TOPIC, GROUP, QUEUE_ID_1, popTime, 1, Lists.newArrayList(6L, 7L, 8L), new StringBuilder());\n    assertFalse(consumerOrderInfoManager.checkBlock(\"attemptId5\", TOPIC, GROUP, QUEUE_ID_1, 3000));\n}\n"
    ]
  },
  "23": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresent",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresent"
    ],
    "test_src_code": "    @Test\n    public void testGetWhenComputeIfPresent() {\n        String handle1 = createHandle();\n        String handle2 = createHandle();\n        AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n        receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n        CountDownLatch latch = new CountDownLatch(2);\n        Thread getThread = new Thread(() -> {\n            try {\n                latch.countDown();\n                latch.await();\n                getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n            } catch (Exception ignored) {\n            }\n        }, \"getThread\");\n        Thread computeThread = new Thread(() -> {\n            try {\n                receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                    } catch (Exception ignored) {\n                    }\n                    messageReceiptHandle.updateReceiptHandle(handle2);\n                    return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n                });\n            } catch (Exception ignored) {\n            }\n        }, \"computeThread\");\n        getThread.start();\n        computeThread.start();\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> getHandleRef.get() != null);\n        assertEquals(handle2, getHandleRef.get().getReceiptHandleStr());\n        assertFalse(receiptHandleGroup.isEmpty());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#put",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#get",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#put",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#get",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent"
    ],
    "focal_src": [
      "    public void put(String msgID, String handle, MessageReceiptHandle value) {\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        Map<String, HandleData> handleMap = ConcurrentHashMapUtils.computeIfAbsent((ConcurrentHashMap<String, Map<String, HandleData>>) this.receiptHandleMap,\n            msgID, msgIDKey -> new ConcurrentHashMap<>());\n        handleMap.compute(handle, (handleKey, handleData) -> {\n            if (handleData == null || handleData.needRemove) {\n                return new HandleData(value);\n            }\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to put handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return new HandleData(value);\n                }\n                handleData.messageReceiptHandle = value;\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n    }\n",
      "    public MessageReceiptHandle get(String msgID, String handle) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to get handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return null;\n                }\n                res.set(handleData.messageReceiptHandle);\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n        return res.get();\n    }\n",
      "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n"
    ],
    "focal_tgt": [
      "    public void put(String msgID, MessageReceiptHandle value) {\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        Map<HandleKey, HandleData> handleMap = ConcurrentHashMapUtils.computeIfAbsent((ConcurrentHashMap<String, Map<HandleKey, HandleData>>) this.receiptHandleMap,\n            msgID, msgIDKey -> new ConcurrentHashMap<>());\n        handleMap.compute(new HandleKey(value.getOriginalReceiptHandle()), (handleKey, handleData) -> {\n            if (handleData == null || handleData.needRemove) {\n                return new HandleData(value);\n            }\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to put handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return new HandleData(value);\n                }\n                handleData.messageReceiptHandle = value;\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n    }\n",
      "    public MessageReceiptHandle get(String msgID, String handle) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to get handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return null;\n                }\n                res.set(handleData.messageReceiptHandle);\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n        return res.get();\n    }\n",
      "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n"
    ],
    "test_id": 23,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> getHandleRef.get() != null);\n    assertEquals(handle2, getHandleRef.get().getReceiptHandleStr());\n    assertFalse(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testGetWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> getHandleRef.get() != null);\n    assertEquals(handle2, getHandleRef.get().getReceiptHandleStr());\n    assertFalse(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testGetWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> getHandleRef.get() != null);\n    assertEquals(handle2, getHandleRef.get().getReceiptHandleStr());\n    assertFalse(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testGetWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> getHandleRef.get() != null);\n    assertEquals(handle2, getHandleRef.get().getReceiptHandleStr());\n    assertFalse(receiptHandleGroup.isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testGetWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> getHandleRef.get() != null);\n    assertEquals(handle2, getHandleRef.get().getReceiptHandleStr());\n    assertFalse(receiptHandleGroup.isEmpty());\n    // Test for uncovered lines\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    assertNull(receiptHandleGroup.get(msgID, \"non-existing-handle\"));\n    assertNull(receiptHandleGroup.get(\"non-existing-msgID\", handle1));\n    assertNull(receiptHandleGroup.get(\"non-existing-msgID\", \"non-existing-handle\"));\n\n    // Test for uncovered branches\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n        messageReceiptHandle.updateReceiptHandle(handle2);\n        return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n    });\n    assertTrue(receiptHandleGroup.get(msgID, handle1).getReceiptHandleStr().equals(handle2));\n}\n",
      "@Test\npublic void testGetWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> getHandleRef.get() != null);\n    assertEquals(handle2, getHandleRef.get().getReceiptHandleStr());\n    assertFalse(receiptHandleGroup.isEmpty());\n    // Test for uncovered lines\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    assertNull(receiptHandleGroup.get(msgID, \"non-existing-handle\"));\n    assertNull(receiptHandleGroup.get(\"non-existing-msgID\", handle1));\n    assertNull(receiptHandleGroup.get(\"non-existing-msgID\", \"non-existing-handle\"));\n\n    // Test for uncovered branches\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n        messageReceiptHandle.updateReceiptHandle(handle2);\n        return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n    });\n    assertTrue(receiptHandleGroup.get(msgID, handle1).getReceiptHandleStr().equals(handle2));\n}\n",
      "@Test\npublic void testGetWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> getHandleRef.get() != null);\n    assertEquals(handle2, getHandleRef.get().getReceiptHandleStr());\n    assertFalse(receiptHandleGroup.isEmpty());\n    // Test for uncovered lines\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    assertNull(receiptHandleGroup.get(msgID, \"non-existing-handle\"));\n    assertNull(receiptHandleGroup.get(\"non-existing-msgID\", handle1));\n    assertNull(receiptHandleGroup.get(\"non-existing-msgID\", \"non-existing-handle\"));\n\n    // Test for uncovered branches\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n        messageReceiptHandle.updateReceiptHandle(handle2);\n        return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n    });\n    assertTrue(receiptHandleGroup.get(msgID, handle1).getReceiptHandleStr().equals(handle2));\n}\n",
      "@Test\npublic void testGetWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> getHandleRef.get() != null);\n    assertEquals(handle2, getHandleRef.get().getReceiptHandleStr());\n    assertFalse(receiptHandleGroup.isEmpty());\n    // Test for uncovered lines\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    assertNull(receiptHandleGroup.get(msgID, \"non-existing-handle\"));\n    assertNull(receiptHandleGroup.get(\"non-existing-msgID\", handle1));\n    assertNull(receiptHandleGroup.get(\"non-existing-msgID\", \"non-existing-handle\"));\n\n    // Test for uncovered branches\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n        messageReceiptHandle.updateReceiptHandle(handle2);\n        return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n    });\n    assertTrue(receiptHandleGroup.get(msgID, handle1).getReceiptHandleStr().equals(handle2));\n}\n"
    ]
  },
  "24": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresentReturnNull",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresentReturnNull"
    ],
    "test_src_code": "    @Test\n    public void testGetWhenComputeIfPresentReturnNull() {\n        String handle1 = createHandle();\n        AtomicBoolean getCalled = new AtomicBoolean(false);\n        AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n        receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n        CountDownLatch latch = new CountDownLatch(2);\n        Thread getThread = new Thread(() -> {\n            try {\n                latch.countDown();\n                latch.await();\n                getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n                getCalled.set(true);\n            } catch (Exception ignored) {\n            }\n        }, \"getThread\");\n        Thread computeThread = new Thread(() -> {\n            try {\n                receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                    } catch (Exception ignored) {\n                    }\n                    return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n                });\n            } catch (Exception ignored) {\n            }\n        }, \"computeThread\");\n        getThread.start();\n        computeThread.start();\n\n        await().atMost(Duration.ofSeconds(1)).until(getCalled::get);\n        assertNull(getHandleRef.get());\n        assertTrue(receiptHandleGroup.isEmpty());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#put",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#get",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#put",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#get",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent"
    ],
    "focal_src": [
      "    public void put(String msgID, String handle, MessageReceiptHandle value) {\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        Map<String, HandleData> handleMap = ConcurrentHashMapUtils.computeIfAbsent((ConcurrentHashMap<String, Map<String, HandleData>>) this.receiptHandleMap,\n            msgID, msgIDKey -> new ConcurrentHashMap<>());\n        handleMap.compute(handle, (handleKey, handleData) -> {\n            if (handleData == null || handleData.needRemove) {\n                return new HandleData(value);\n            }\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to put handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return new HandleData(value);\n                }\n                handleData.messageReceiptHandle = value;\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n    }\n",
      "    public MessageReceiptHandle get(String msgID, String handle) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to get handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return null;\n                }\n                res.set(handleData.messageReceiptHandle);\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n        return res.get();\n    }\n",
      "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n"
    ],
    "focal_tgt": [
      "    public void put(String msgID, MessageReceiptHandle value) {\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        Map<HandleKey, HandleData> handleMap = ConcurrentHashMapUtils.computeIfAbsent((ConcurrentHashMap<String, Map<HandleKey, HandleData>>) this.receiptHandleMap,\n            msgID, msgIDKey -> new ConcurrentHashMap<>());\n        handleMap.compute(new HandleKey(value.getOriginalReceiptHandle()), (handleKey, handleData) -> {\n            if (handleData == null || handleData.needRemove) {\n                return new HandleData(value);\n            }\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to put handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return new HandleData(value);\n                }\n                handleData.messageReceiptHandle = value;\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n    }\n",
      "    public MessageReceiptHandle get(String msgID, String handle) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to get handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return null;\n                }\n                res.set(handleData.messageReceiptHandle);\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n        return res.get();\n    }\n",
      "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n"
    ],
    "test_id": 24,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean getCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n            getCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(getCalled::get);\n    assertNull(getHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testGetWhenComputeIfPresentReturnNull() {\n    String msgID = \"testMsgID\";\n    String handle = createHandle();\n    AtomicBoolean getCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle));\n            getCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(getCalled::get);\n    assertNull(getHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testGetWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean getCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n            getCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(getCalled::get);\n    assertNull(getHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testGetWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean getCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread getThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n            getCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"getThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    getThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(getCalled::get);\n    assertNull(getHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n"
    ]
  },
  "25": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresent",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresent"
    ],
    "test_src_code": "    @Test\n    public void testRemoveWhenComputeIfPresent() {\n        String handle1 = createHandle();\n        String handle2 = createHandle();\n        AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n        receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n        CountDownLatch latch = new CountDownLatch(2);\n        Thread removeThread = new Thread(() -> {\n            try {\n                latch.countDown();\n                latch.await();\n                removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            } catch (Exception ignored) {\n            }\n        }, \"removeThread\");\n        Thread computeThread = new Thread(() -> {\n            try {\n                receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                    } catch (Exception ignored) {\n                    }\n                    messageReceiptHandle.updateReceiptHandle(handle2);\n                    return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n                });\n            } catch (Exception ignored) {\n            }\n        }, \"computeThread\");\n        removeThread.start();\n        computeThread.start();\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n        assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n        assertTrue(receiptHandleGroup.isEmpty());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#put",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#get",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#remove",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#put",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#get",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#remove",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent"
    ],
    "focal_src": [
      "    public void put(String msgID, String handle, MessageReceiptHandle value) {\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        Map<String, HandleData> handleMap = ConcurrentHashMapUtils.computeIfAbsent((ConcurrentHashMap<String, Map<String, HandleData>>) this.receiptHandleMap,\n            msgID, msgIDKey -> new ConcurrentHashMap<>());\n        handleMap.compute(handle, (handleKey, handleData) -> {\n            if (handleData == null || handleData.needRemove) {\n                return new HandleData(value);\n            }\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to put handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return new HandleData(value);\n                }\n                handleData.messageReceiptHandle = value;\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n    }\n",
      "    public MessageReceiptHandle get(String msgID, String handle) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to get handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return null;\n                }\n                res.set(handleData.messageReceiptHandle);\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n        return res.get();\n    }\n",
      "    public MessageReceiptHandle remove(String msgID, String handle) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to remove and get handle failed\");\n            }\n            try {\n                if (!handleData.needRemove) {\n                    handleData.needRemove = true;\n                    res.set(handleData.messageReceiptHandle);\n                }\n                return null;\n            } finally {\n                handleData.unlock();\n            }\n        });\n        removeHandleMapKeyIfNeed(msgID);\n        return res.get();\n    }\n",
      "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n"
    ],
    "focal_tgt": [
      "    public void put(String msgID, MessageReceiptHandle value) {\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        Map<HandleKey, HandleData> handleMap = ConcurrentHashMapUtils.computeIfAbsent((ConcurrentHashMap<String, Map<HandleKey, HandleData>>) this.receiptHandleMap,\n            msgID, msgIDKey -> new ConcurrentHashMap<>());\n        handleMap.compute(new HandleKey(value.getOriginalReceiptHandle()), (handleKey, handleData) -> {\n            if (handleData == null || handleData.needRemove) {\n                return new HandleData(value);\n            }\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to put handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return new HandleData(value);\n                }\n                handleData.messageReceiptHandle = value;\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n    }\n",
      "    public MessageReceiptHandle get(String msgID, String handle) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to get handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return null;\n                }\n                res.set(handleData.messageReceiptHandle);\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n        return res.get();\n    }\n",
      "    public MessageReceiptHandle remove(String msgID, String handle) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to remove and get handle failed\");\n            }\n            try {\n                if (!handleData.needRemove) {\n                    handleData.needRemove = true;\n                    res.set(handleData.messageReceiptHandle);\n                }\n                return null;\n            } finally {\n                handleData.unlock();\n            }\n        });\n        removeHandleMapKeyIfNeed(msgID);\n        return res.get();\n    }\n",
      "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n"
    ],
    "test_id": 25,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testRemoveWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n    assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n    assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n    assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n    assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n    assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testRemoveWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n    assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n    // Testing the case where the handle does not exist\n    assertNull(receiptHandleGroup.remove(msgID, handle1));\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n    assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n    // Testing the case where the handle does not exist\n    assertNull(receiptHandleGroup.remove(msgID, handle1));\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n    assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n    // Testing the case where the handle does not exist\n    assertNull(receiptHandleGroup.remove(msgID, handle1));\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n    assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n    // Testing the case where the handle does not exist\n    assertNull(receiptHandleGroup.remove(msgID, handle1));\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresent() {\n    String handle1 = createHandle();\n    String handle2 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                messageReceiptHandle.updateReceiptHandle(handle2);\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n    assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n    // Testing the case where the handle does not exist\n    assertNull(receiptHandleGroup.remove(msgID, handle1));\n}\n"
    ]
  },
  "26": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresentReturnNull",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresentReturnNull"
    ],
    "test_src_code": "    @Test\n    public void testRemoveWhenComputeIfPresentReturnNull() {\n        String handle1 = createHandle();\n        AtomicBoolean removeCalled = new AtomicBoolean(false);\n        AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n        receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n        CountDownLatch latch = new CountDownLatch(2);\n        Thread removeThread = new Thread(() -> {\n            try {\n                latch.countDown();\n                latch.await();\n                removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n                removeCalled.set(true);\n            } catch (Exception ignored) {\n            }\n        }, \"removeThread\");\n        Thread computeThread = new Thread(() -> {\n            try {\n                receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                    } catch (Exception ignored) {\n                    }\n                    return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n                });\n            } catch (Exception ignored) {\n            }\n        }, \"computeThread\");\n        removeThread.start();\n        computeThread.start();\n\n        await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n        assertNull(removeHandleRef.get());\n        assertTrue(receiptHandleGroup.isEmpty());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#put",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#get",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#remove",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#put",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#get",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#remove",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent"
    ],
    "focal_src": [
      "    public void put(String msgID, String handle, MessageReceiptHandle value) {\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        Map<String, HandleData> handleMap = ConcurrentHashMapUtils.computeIfAbsent((ConcurrentHashMap<String, Map<String, HandleData>>) this.receiptHandleMap,\n            msgID, msgIDKey -> new ConcurrentHashMap<>());\n        handleMap.compute(handle, (handleKey, handleData) -> {\n            if (handleData == null || handleData.needRemove) {\n                return new HandleData(value);\n            }\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to put handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return new HandleData(value);\n                }\n                handleData.messageReceiptHandle = value;\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n    }\n",
      "    public MessageReceiptHandle get(String msgID, String handle) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to get handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return null;\n                }\n                res.set(handleData.messageReceiptHandle);\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n        return res.get();\n    }\n",
      "    public MessageReceiptHandle remove(String msgID, String handle) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to remove and get handle failed\");\n            }\n            try {\n                if (!handleData.needRemove) {\n                    handleData.needRemove = true;\n                    res.set(handleData.messageReceiptHandle);\n                }\n                return null;\n            } finally {\n                handleData.unlock();\n            }\n        });\n        removeHandleMapKeyIfNeed(msgID);\n        return res.get();\n    }\n",
      "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n"
    ],
    "focal_tgt": [
      "    public void put(String msgID, MessageReceiptHandle value) {\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        Map<HandleKey, HandleData> handleMap = ConcurrentHashMapUtils.computeIfAbsent((ConcurrentHashMap<String, Map<HandleKey, HandleData>>) this.receiptHandleMap,\n            msgID, msgIDKey -> new ConcurrentHashMap<>());\n        handleMap.compute(new HandleKey(value.getOriginalReceiptHandle()), (handleKey, handleData) -> {\n            if (handleData == null || handleData.needRemove) {\n                return new HandleData(value);\n            }\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to put handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return new HandleData(value);\n                }\n                handleData.messageReceiptHandle = value;\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n    }\n",
      "    public MessageReceiptHandle get(String msgID, String handle) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to get handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return null;\n                }\n                res.set(handleData.messageReceiptHandle);\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n        return res.get();\n    }\n",
      "    public MessageReceiptHandle remove(String msgID, String handle) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to remove and get handle failed\");\n            }\n            try {\n                if (!handleData.needRemove) {\n                    handleData.needRemove = true;\n                    res.set(handleData.messageReceiptHandle);\n                }\n                return null;\n            } finally {\n                handleData.unlock();\n            }\n        });\n        removeHandleMapKeyIfNeed(msgID);\n        return res.get();\n    }\n",
      "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n"
    ],
    "test_id": 26,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testRemoveWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean removeCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            removeCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n    assertNull(removeHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean removeCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            removeCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n    assertNull(removeHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean removeCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            removeCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n    assertNull(removeHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean removeCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            removeCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n    assertNull(removeHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean removeCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            removeCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n    assertNull(removeHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testRemoveWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean removeCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            removeCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n    assertNull(removeHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n    // Add more test cases to cover the uncovered lines and branches\n    // Test case 1: Test when the handle does not exist\n    assertNull(receiptHandleGroup.remove(msgID, handle1));\n    assertTrue(receiptHandleGroup.isEmpty());\n\n    // Test case 2: Test when the handle is locked by another thread\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    Thread anotherThread = new Thread(() -> {\n        try {\n            Thread.sleep(100);\n            receiptHandleGroup.remove(msgID, handle1);\n        } catch (Exception ignored) {\n        }\n    });\n    anotherThread.start();\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeCalled.get() && receiptHandleGroup.isEmpty());\n\n    // Test case 3: Test when the handle is locked by the same thread\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    receiptHandleGroup.remove(msgID, handle1);\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean removeCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            removeCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n    assertNull(removeHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n    // Add more test cases to cover the uncovered lines and branches\n    // Test case 1: Test when the handle does not exist\n    assertNull(receiptHandleGroup.remove(msgID, handle1));\n    assertTrue(receiptHandleGroup.isEmpty());\n\n    // Test case 2: Test when the handle is locked by another thread\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    Thread anotherThread = new Thread(() -> {\n        try {\n            Thread.sleep(100);\n            receiptHandleGroup.remove(msgID, handle1);\n        } catch (Exception ignored) {\n        }\n    });\n    anotherThread.start();\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeCalled.get() && receiptHandleGroup.isEmpty());\n\n    // Test case 3: Test when the handle is locked by the same thread\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    receiptHandleGroup.remove(msgID, handle1);\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean removeCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            removeCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n    assertNull(removeHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n    // Add more test cases to cover the uncovered lines and branches\n    // Test case 1: Test when the handle does not exist\n    assertNull(receiptHandleGroup.remove(msgID, handle1));\n    assertTrue(receiptHandleGroup.isEmpty());\n\n    // Test case 2: Test when the handle is locked by another thread\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    Thread anotherThread = new Thread(() -> {\n        try {\n            Thread.sleep(100);\n            receiptHandleGroup.remove(msgID, handle1);\n        } catch (Exception ignored) {\n        }\n    });\n    anotherThread.start();\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeCalled.get() && receiptHandleGroup.isEmpty());\n\n    // Test case 3: Test when the handle is locked by the same thread\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    receiptHandleGroup.remove(msgID, handle1);\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean removeCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            removeCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n    assertNull(removeHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n    // Add more test cases to cover the uncovered lines and branches\n    // Test case 1: Test when the handle does not exist\n    assertNull(receiptHandleGroup.remove(msgID, handle1));\n    assertTrue(receiptHandleGroup.isEmpty());\n\n    // Test case 2: Test when the handle is locked by another thread\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    Thread anotherThread = new Thread(() -> {\n        try {\n            Thread.sleep(100);\n            receiptHandleGroup.remove(msgID, handle1);\n        } catch (Exception ignored) {\n        }\n    });\n    anotherThread.start();\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeCalled.get() && receiptHandleGroup.isEmpty());\n\n    // Test case 3: Test when the handle is locked by the same thread\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    receiptHandleGroup.remove(msgID, handle1);\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n",
      "@Test\npublic void testRemoveWhenComputeIfPresentReturnNull() {\n    String handle1 = createHandle();\n    AtomicBoolean removeCalled = new AtomicBoolean(false);\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    CountDownLatch latch = new CountDownLatch(2);\n    Thread removeThread = new Thread(() -> {\n        try {\n            latch.countDown();\n            latch.await();\n            removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            removeCalled.set(true);\n        } catch (Exception ignored) {\n        }\n    }, \"removeThread\");\n    Thread computeThread = new Thread(() -> {\n        try {\n            receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                } catch (Exception ignored) {\n                }\n                return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n            });\n        } catch (Exception ignored) {\n        }\n    }, \"computeThread\");\n    removeThread.start();\n    computeThread.start();\n\n    await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n    assertNull(removeHandleRef.get());\n    assertTrue(receiptHandleGroup.isEmpty());\n    // Add more test cases to cover the uncovered lines and branches\n    // Test case 1: Test when the handle does not exist\n    assertNull(receiptHandleGroup.remove(msgID, handle1));\n    assertTrue(receiptHandleGroup.isEmpty());\n\n    // Test case 2: Test when the handle is locked by another thread\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    Thread anotherThread = new Thread(() -> {\n        try {\n            Thread.sleep(100);\n            receiptHandleGroup.remove(msgID, handle1);\n        } catch (Exception ignored) {\n        }\n    });\n    anotherThread.start();\n    await().atMost(Duration.ofSeconds(1)).until(() -> removeCalled.get() && receiptHandleGroup.isEmpty());\n\n    // Test case 3: Test when the handle is locked by the same thread\n    receiptHandleGroup.put(msgID, createMessageReceiptHandle(handle1, msgID));\n    receiptHandleGroup.remove(msgID, handle1);\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n"
    ]
  },
  "27": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveMultiThread",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveMultiThread"
    ],
    "test_src_code": "    @Test\n    public void testRemoveMultiThread() {\n        String handle1 = createHandle();\n        AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n        AtomicInteger count = new AtomicInteger();\n\n        receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n        int threadNum = Math.max(Runtime.getRuntime().availableProcessors(), 3);\n        CountDownLatch latch = new CountDownLatch(threadNum);\n        for (int i = 0; i < threadNum; i++) {\n            Thread thread = new Thread(() -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                    MessageReceiptHandle handle = receiptHandleGroup.remove(msgID, handle1);\n                    if (handle != null) {\n                        removeHandleRef.set(handle);\n                        count.incrementAndGet();\n                    }\n                } catch (Exception ignored) {\n                }\n            });\n            thread.start();\n        }\n\n        await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> assertEquals(1, count.get()));\n        assertEquals(handle1, removeHandleRef.get().getReceiptHandleStr());\n        assertTrue(receiptHandleGroup.isEmpty());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#put",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#get",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#remove"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#put",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#get",
      "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#remove"
    ],
    "focal_src": [
      "    public void put(String msgID, String handle, MessageReceiptHandle value) {\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        Map<String, HandleData> handleMap = ConcurrentHashMapUtils.computeIfAbsent((ConcurrentHashMap<String, Map<String, HandleData>>) this.receiptHandleMap,\n            msgID, msgIDKey -> new ConcurrentHashMap<>());\n        handleMap.compute(handle, (handleKey, handleData) -> {\n            if (handleData == null || handleData.needRemove) {\n                return new HandleData(value);\n            }\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to put handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return new HandleData(value);\n                }\n                handleData.messageReceiptHandle = value;\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n    }\n",
      "    public MessageReceiptHandle get(String msgID, String handle) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to get handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return null;\n                }\n                res.set(handleData.messageReceiptHandle);\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n        return res.get();\n    }\n",
      "    public MessageReceiptHandle remove(String msgID, String handle) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to remove and get handle failed\");\n            }\n            try {\n                if (!handleData.needRemove) {\n                    handleData.needRemove = true;\n                    res.set(handleData.messageReceiptHandle);\n                }\n                return null;\n            } finally {\n                handleData.unlock();\n            }\n        });\n        removeHandleMapKeyIfNeed(msgID);\n        return res.get();\n    }\n"
    ],
    "focal_tgt": [
      "    public void put(String msgID, MessageReceiptHandle value) {\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        Map<HandleKey, HandleData> handleMap = ConcurrentHashMapUtils.computeIfAbsent((ConcurrentHashMap<String, Map<HandleKey, HandleData>>) this.receiptHandleMap,\n            msgID, msgIDKey -> new ConcurrentHashMap<>());\n        handleMap.compute(new HandleKey(value.getOriginalReceiptHandle()), (handleKey, handleData) -> {\n            if (handleData == null || handleData.needRemove) {\n                return new HandleData(value);\n            }\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to put handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return new HandleData(value);\n                }\n                handleData.messageReceiptHandle = value;\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n    }\n",
      "    public MessageReceiptHandle get(String msgID, String handle) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to get handle failed\");\n            }\n            try {\n                if (handleData.needRemove) {\n                    return null;\n                }\n                res.set(handleData.messageReceiptHandle);\n            } finally {\n                handleData.unlock();\n            }\n            return handleData;\n        });\n        return res.get();\n    }\n",
      "    public MessageReceiptHandle remove(String msgID, String handle) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to remove and get handle failed\");\n            }\n            try {\n                if (!handleData.needRemove) {\n                    handleData.needRemove = true;\n                    res.set(handleData.messageReceiptHandle);\n                }\n                return null;\n            } finally {\n                handleData.unlock();\n            }\n        });\n        removeHandleMapKeyIfNeed(msgID);\n        return res.get();\n    }\n"
    ],
    "test_id": 27,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testRemoveMultiThread() {\n    String handle1 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n    AtomicInteger count = new AtomicInteger();\n\n    receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n    int threadNum = Math.max(Runtime.getRuntime().availableProcessors(), 3);\n    CountDownLatch latch = new CountDownLatch(threadNum);\n    for (int i = 0; i < threadNum; i++) {\n        Thread thread = new Thread(() -> {\n            try {\n                latch.countDown();\n                latch.await();\n                MessageReceiptHandle handle = receiptHandleGroup.remove(msgID, handle1);\n                if (handle != null) {\n                    removeHandleRef.set(handle);\n                    count.incrementAndGet();\n                }\n            } catch (Exception ignored) {\n            }\n        });\n        thread.start();\n    }\n\n    await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> assertEquals(1, count.get()));\n    assertEquals(handle1, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testRemoveMultiThread() {\n    String handle1 = createHandle();\n    AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n    AtomicInteger count = new AtomicInteger();\n\n    receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n    int threadNum = Math.max(Runtime.getRuntime().availableProcessors(), 3);\n    CountDownLatch latch = new CountDownLatch(threadNum);\n    for (int i = 0; i < threadNum; i++) {\n        Thread thread = new Thread(() -> {\n            try {\n                latch.countDown();\n                latch.await();\n                MessageReceiptHandle handle = receiptHandleGroup.remove(msgID, handle1);\n                if (handle != null) {\n                    removeHandleRef.set(handle);\n                    count.incrementAndGet();\n                }\n            } catch (Exception ignored) {\n            }\n        });\n        thread.start();\n    }\n\n    await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> assertEquals(1, count.get()));\n    assertEquals(handle1, removeHandleRef.get().getReceiptHandleStr());\n    assertTrue(receiptHandleGroup.isEmpty());\n}\n"
    ]
  },
  "28": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessagePollingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessagePollingTime"
    ],
    "test_src_code": "    @Test\n    public void testReceiveMessagePollingTime() {\n        StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n        ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n        doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n        ArgumentCaptor<Long> pollTimeCaptor = ArgumentCaptor.forClass(Long.class);\n        when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder()\n            .setRequestTimeout(Durations.fromSeconds(3))\n            .build());\n        when(this.messagingProcessor.popMessage(any(), any(), anyString(), anyString(), anyInt(), anyLong(),\n            pollTimeCaptor.capture(), anyInt(), any(), anyBoolean(), any(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new PopResult(PopStatus.NO_NEW_MSG, Collections.emptyList())));\n\n\n        ProxyContext context = createContext();\n        context.setRemainingMs(1L);\n        this.receiveMessageActivity.receiveMessage(\n            context,\n            ReceiveMessageRequest.newBuilder()\n                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n                .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n                .setAutoRenew(true)\n                .setFilterExpression(FilterExpression.newBuilder()\n                    .setType(FilterType.TAG)\n                    .setExpression(\"*\")\n                    .build())\n                .build(),\n            receiveStreamObserver\n        );\n\n        assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n        assertEquals(0L, pollTimeCaptor.getValue().longValue());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java#receiveMessage"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java#receiveMessage"
    ],
    "focal_src": [
      "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), receiptHandle, messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    request.getAttemptId(),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n"
    ],
    "test_id": 28,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testReceiveMessagePollingTime() {\n    StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n    ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n    doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n    ArgumentCaptor<Long> pollTimeCaptor = ArgumentCaptor.forClass(Long.class);\n    when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder()\n        .setRequestTimeout(Durations.fromSeconds(3))\n        .build());\n    when(this.messagingProcessor.popMessage(any(), any(), anyString(), anyString(), anyInt(), anyLong(),\n        pollTimeCaptor.capture(), anyInt(), any(), anyBoolean(), any(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new PopResult(PopStatus.NO_NEW_MSG, Collections.emptyList())));\n\n\n    ProxyContext context = createContext();\n    context.setRemainingMs(1L);\n    this.receiveMessageActivity.receiveMessage(\n        context,\n        ReceiveMessageRequest.newBuilder()\n            .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n            .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n            .setAutoRenew(true)\n            .setFilterExpression(FilterExpression.newBuilder()\n                .setType(FilterType.TAG)\n                .setExpression(\"*\")\n                .build())\n            .build(),\n        receiveStreamObserver\n    );\n\n    assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n    assertEquals(0L, pollTimeCaptor.getValue().longValue());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testReceiveMessagePollingTime() {\n    StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n    ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n    doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n    ArgumentCaptor<Long> pollTimeCaptor = ArgumentCaptor.forClass(Long.class);\n    when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder()\n        .setRequestTimeout(Durations.fromSeconds(3))\n        .build());\n    when(this.messagingProcessor.popMessage(any(), any(), anyString(), anyString(), anyInt(), anyLong(),\n        pollTimeCaptor.capture(), anyInt(), any(), anyBoolean(), any(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new PopResult(PopStatus.NO_NEW_MSG, Collections.emptyList())));\n\n\n    ProxyContext context = createContext();\n    context.setRemainingMs(1L);\n    this.receiveMessageActivity.receiveMessage(\n        context,\n        ReceiveMessageRequest.newBuilder()\n            .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n            .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n            .setAutoRenew(true)\n            .setFilterExpression(FilterExpression.newBuilder()\n                .setType(FilterType.TAG)\n                .setExpression(\"*\")\n                .build())\n            .build(),\n        receiveStreamObserver\n    );\n\n    assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n    assertEquals(0L, pollTimeCaptor.getValue().longValue());\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "OutOfMemoryError('CUDA out of memory. Tried to allocate 6.18 GiB. GPU 0 has a total capacty of 23.69 GiB of which 4.52 GiB is free. Process 1478252 has 19.17 GiB memory in use. Of the allocated memory 12.92 GiB is allocated by PyTorch, and 5.21 GiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF')"
  },
  "29": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessage"
    ],
    "test_src_code": "    @Test\n    public void testReceiveMessage() {\n        StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n        ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n        doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n        when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder().getDefaultInstanceForType());\n\n        PopResult popResult = new PopResult(PopStatus.NO_NEW_MSG, new ArrayList<>());\n        when(this.messagingProcessor.popMessage(\n            any(),\n            any(),\n            anyString(),\n            anyString(),\n            anyInt(),\n            anyLong(),\n            anyLong(),\n            anyInt(),\n            any(),\n            anyBoolean(),\n            any(),\n            anyLong())).thenReturn(CompletableFuture.completedFuture(popResult));\n\n        this.receiveMessageActivity.receiveMessage(\n            createContext(),\n            ReceiveMessageRequest.newBuilder()\n                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n                .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n                .setAutoRenew(true)\n                .setFilterExpression(FilterExpression.newBuilder()\n                    .setType(FilterType.TAG)\n                    .setExpression(\"*\")\n                    .build())\n                .build(),\n            receiveStreamObserver\n        );\n        assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java#receiveMessage"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java#receiveMessage"
    ],
    "focal_src": [
      "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), receiptHandle, messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    request.getAttemptId(),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n"
    ],
    "test_id": 29,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testReceiveMessage() {\n    StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n    ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n    doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n    when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder().getDefaultInstanceForType());\n\n    PopResult popResult = new PopResult(PopStatus.NO_NEW_MSG, new ArrayList<>());\n    when(this.messagingProcessor.popMessage(\n        any(),\n        any(),\n        anyString(),\n        anyString(),\n        anyInt(),\n        anyLong(),\n        anyLong(),\n        anyInt(),\n        any(),\n        anyBoolean(),\n        any(),\n        anyLong())).thenReturn(CompletableFuture.completedFuture(popResult));\n\n    this.receiveMessageActivity.receiveMessage(\n        createContext(),\n        ReceiveMessageRequest.newBuilder()\n            .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n            .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n            .setAutoRenew(true)\n            .setFilterExpression(FilterExpression.newBuilder()\n                .setType(FilterType.TAG)\n                .setExpression(\"*\")\n                .build())\n            .build(),\n        receiveStreamObserver\n    );\n    assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testReceiveMessage() {\n    StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n    ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n    doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n    when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder().getDefaultInstanceForType());\n\n    PopResult popResult = new PopResult(PopStatus.NO_NEW_MSG, new ArrayList<>());\n    when(this.messagingProcessor.popMessage(\n        any(),\n        any(),\n        anyString(),\n        anyString(),\n        anyInt(),\n        anyLong(),\n        anyLong(),\n        anyInt(),\n        any(),\n        anyBoolean(),\n        any(),\n        anyLong())).thenReturn(CompletableFuture.completedFuture(popResult));\n\n    this.receiveMessageActivity.receiveMessage(\n        createContext(),\n        ReceiveMessageRequest.newBuilder()\n            .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n            .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n            .setAutoRenew(true)\n            .setFilterExpression(FilterExpression.newBuilder()\n                .setType(FilterType.TAG)\n                .setExpression(\"*\")\n                .build())\n            .build(),\n        receiveStreamObserver\n    );\n    assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "OutOfMemoryError('CUDA out of memory. Tried to allocate 5.91 GiB. GPU 0 has a total capacty of 23.69 GiB of which 3.54 GiB is free. Process 1478252 has 20.14 GiB memory in use. Of the allocated memory 12.51 GiB is allocated by PyTorch, and 6.60 GiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF')"
  },
  "30": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ConsumerProcessorTest#testPopMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ConsumerProcessorTest#testPopMessage"
    ],
    "test_src_code": "    @Test\n    public void testPopMessage() throws Throwable {\n        final String tag = \"tag\";\n        final long invisibleTime = Duration.ofSeconds(15).toMillis();\n        ArgumentCaptor<AddressableMessageQueue> messageQueueArgumentCaptor = ArgumentCaptor.forClass(AddressableMessageQueue.class);\n        ArgumentCaptor<PopMessageRequestHeader> requestHeaderArgumentCaptor = ArgumentCaptor.forClass(PopMessageRequestHeader.class);\n\n        List<MessageExt> messageExtList = new ArrayList<>();\n        messageExtList.add(createMessageExt(TOPIC, \"noMatch\", 0, invisibleTime));\n        messageExtList.add(createMessageExt(TOPIC, tag, 0, invisibleTime));\n        messageExtList.add(createMessageExt(TOPIC, tag, 1, invisibleTime));\n        PopResult innerPopResult = new PopResult(PopStatus.FOUND, messageExtList);\n        when(this.messageService.popMessage(any(), messageQueueArgumentCaptor.capture(), requestHeaderArgumentCaptor.capture(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(innerPopResult));\n\n        when(this.topicRouteService.getCurrentMessageQueueView(any(), anyString()))\n            .thenReturn(mock(MessageQueueView.class));\n\n        ArgumentCaptor<String> ackMessageIdArgumentCaptor = ArgumentCaptor.forClass(String.class);\n        when(this.messagingProcessor.ackMessage(any(), any(), ackMessageIdArgumentCaptor.capture(), anyString(), anyString(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(mock(AckResult.class)));\n\n        ArgumentCaptor<String> toDLQMessageIdArgumentCaptor = ArgumentCaptor.forClass(String.class);\n        when(this.messagingProcessor.forwardMessageToDeadLetterQueue(any(), any(), toDLQMessageIdArgumentCaptor.capture(), anyString(), anyString(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(mock(RemotingCommand.class)));\n\n        AddressableMessageQueue messageQueue = mock(AddressableMessageQueue.class);\n        PopResult popResult = this.consumerProcessor.popMessage(\n            createContext(),\n            (ctx, messageQueueView) -> messageQueue,\n            CONSUMER_GROUP,\n            TOPIC,\n            60,\n            invisibleTime,\n            Duration.ofSeconds(3).toMillis(),\n            ConsumeInitMode.MAX,\n            FilterAPI.build(TOPIC, tag, ExpressionType.TAG),\n            false,\n            (ctx, consumerGroup, subscriptionData, messageExt) -> {\n                if (!messageExt.getTags().equals(tag)) {\n                    return PopMessageResultFilter.FilterResult.NO_MATCH;\n                }\n                if (messageExt.getReconsumeTimes() > 0) {\n                    return PopMessageResultFilter.FilterResult.TO_DLQ;\n                }\n                return PopMessageResultFilter.FilterResult.MATCH;\n            },\n            Duration.ofSeconds(3).toMillis()\n        ).get();\n\n        assertSame(messageQueue, messageQueueArgumentCaptor.getValue());\n        assertEquals(CONSUMER_GROUP, requestHeaderArgumentCaptor.getValue().getConsumerGroup());\n        assertEquals(TOPIC, requestHeaderArgumentCaptor.getValue().getTopic());\n        assertEquals(ProxyUtils.MAX_MSG_NUMS_FOR_POP_REQUEST, requestHeaderArgumentCaptor.getValue().getMaxMsgNums());\n        assertEquals(tag, requestHeaderArgumentCaptor.getValue().getExp());\n        assertEquals(ExpressionType.TAG, requestHeaderArgumentCaptor.getValue().getExpType());\n\n        assertEquals(PopStatus.FOUND, popResult.getPopStatus());\n        assertEquals(1, popResult.getMsgFoundList().size());\n        assertEquals(messageExtList.get(1), popResult.getMsgFoundList().get(0));\n\n        assertEquals(messageExtList.get(0).getMsgId(), ackMessageIdArgumentCaptor.getValue());\n        assertEquals(messageExtList.get(2).getMsgId(), toDLQMessageIdArgumentCaptor.getValue());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ConsumerProcessor.java#popMessage",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ConsumerProcessor.java#popMessage"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ConsumerProcessor.java#popMessage",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ConsumerProcessor.java#popMessage"
    ],
    "focal_src": [
      "    public CompletableFuture<PopResult> popMessage(\n        ProxyContext ctx,\n        QueueSelector queueSelector,\n        String consumerGroup,\n        String topic,\n        int maxMsgNums,\n        long invisibleTime,\n        long pollTime,\n        int initMode,\n        SubscriptionData subscriptionData,\n        boolean fifo,\n        PopMessageResultFilter popMessageResultFilter,\n        long timeoutMillis\n    ) {\n        CompletableFuture<PopResult> future = new CompletableFuture<>();\n        try {\n            AddressableMessageQueue messageQueue = queueSelector.select(ctx, this.serviceManager.getTopicRouteService().getCurrentMessageQueueView(ctx, topic));\n            if (messageQueue == null) {\n                throw new ProxyException(ProxyExceptionCode.FORBIDDEN, \"no readable queue\");\n            }\n            return popMessage(ctx, messageQueue, consumerGroup, topic, maxMsgNums, invisibleTime, pollTime, initMode, subscriptionData, fifo, popMessageResultFilter, timeoutMillis);\n        }  catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n",
      "    public CompletableFuture<PopResult> popMessage(\n        ProxyContext ctx,\n        AddressableMessageQueue messageQueue,\n        String consumerGroup,\n        String topic,\n        int maxMsgNums,\n        long invisibleTime,\n        long pollTime,\n        int initMode,\n        SubscriptionData subscriptionData,\n        boolean fifo,\n        PopMessageResultFilter popMessageResultFilter,\n        long timeoutMillis\n    ) {\n        CompletableFuture<PopResult> future = new CompletableFuture<>();\n        try {\n            if (maxMsgNums > ProxyUtils.MAX_MSG_NUMS_FOR_POP_REQUEST) {\n                log.warn(\"change maxNums from {} to {} for pop request, with info: topic:{}, group:{}\",\n                    maxMsgNums, ProxyUtils.MAX_MSG_NUMS_FOR_POP_REQUEST, topic, consumerGroup);\n                maxMsgNums = ProxyUtils.MAX_MSG_NUMS_FOR_POP_REQUEST;\n            }\n\n            PopMessageRequestHeader requestHeader = new PopMessageRequestHeader();\n            requestHeader.setConsumerGroup(consumerGroup);\n            requestHeader.setTopic(topic);\n            requestHeader.setQueueId(messageQueue.getQueueId());\n            requestHeader.setMaxMsgNums(maxMsgNums);\n            requestHeader.setInvisibleTime(invisibleTime);\n            requestHeader.setPollTime(pollTime);\n            requestHeader.setInitMode(initMode);\n            requestHeader.setExpType(subscriptionData.getExpressionType());\n            requestHeader.setExp(subscriptionData.getSubString());\n            requestHeader.setOrder(fifo);\n\n            future = this.serviceManager.getMessageService().popMessage(\n                    ctx,\n                    messageQueue,\n                    requestHeader,\n                    timeoutMillis)\n                .thenApplyAsync(popResult -> {\n                    if (PopStatus.FOUND.equals(popResult.getPopStatus()) &&\n                        popResult.getMsgFoundList() != null &&\n                        !popResult.getMsgFoundList().isEmpty() &&\n                        popMessageResultFilter != null) {\n\n                        List<MessageExt> messageExtList = new ArrayList<>();\n                        for (MessageExt messageExt : popResult.getMsgFoundList()) {\n                            try {\n                                fillUniqIDIfNeed(messageExt);\n                                String handleString = createHandle(messageExt.getProperty(MessageConst.PROPERTY_POP_CK), messageExt.getCommitLogOffset());\n                                if (handleString == null) {\n                                    log.error(\"[BUG] pop message from broker but handle is empty. requestHeader:{}, msg:{}\", requestHeader, messageExt);\n                                    messageExtList.add(messageExt);\n                                    continue;\n                                }\n                                MessageAccessor.putProperty(messageExt, MessageConst.PROPERTY_POP_CK, handleString);\n\n                                PopMessageResultFilter.FilterResult filterResult =\n                                    popMessageResultFilter.filterMessage(ctx, consumerGroup, subscriptionData, messageExt);\n                                switch (filterResult) {\n                                    case NO_MATCH:\n                                        this.messagingProcessor.ackMessage(\n                                            ctx,\n                                            ReceiptHandle.decode(handleString),\n                                            messageExt.getMsgId(),\n                                            consumerGroup,\n                                            topic,\n                                            MessagingProcessor.DEFAULT_TIMEOUT_MILLS);\n                                        break;\n                                    case TO_DLQ:\n                                        this.messagingProcessor.forwardMessageToDeadLetterQueue(\n                                            ctx,\n                                            ReceiptHandle.decode(handleString),\n                                            messageExt.getMsgId(),\n                                            consumerGroup,\n                                            topic,\n                                            MessagingProcessor.DEFAULT_TIMEOUT_MILLS);\n                                        break;\n                                    case MATCH:\n                                    default:\n                                        messageExtList.add(messageExt);\n                                        break;\n                                }\n                            } catch (Throwable t) {\n                                log.error(\"process filterMessage failed. requestHeader:{}, msg:{}\", requestHeader, messageExt, t);\n                                messageExtList.add(messageExt);\n                            }\n                        }\n                        popResult.setMsgFoundList(messageExtList);\n                    }\n                    return popResult;\n                }, this.executor);\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return FutureUtils.addExecutor(future, this.executor);\n    }\n"
    ],
    "focal_tgt": [
      "    public CompletableFuture<PopResult> popMessage(\n        ProxyContext ctx,\n        QueueSelector queueSelector,\n        String consumerGroup,\n        String topic,\n        int maxMsgNums,\n        long invisibleTime,\n        long pollTime,\n        int initMode,\n        SubscriptionData subscriptionData,\n        boolean fifo,\n        PopMessageResultFilter popMessageResultFilter,\n        String attemptId,\n        long timeoutMillis\n    ) {\n        CompletableFuture<PopResult> future = new CompletableFuture<>();\n        try {\n            AddressableMessageQueue messageQueue = queueSelector.select(ctx, this.serviceManager.getTopicRouteService().getCurrentMessageQueueView(ctx, topic));\n            if (messageQueue == null) {\n                throw new ProxyException(ProxyExceptionCode.FORBIDDEN, \"no readable queue\");\n            }\n            return popMessage(ctx, messageQueue, consumerGroup, topic, maxMsgNums, invisibleTime, pollTime, initMode,\n                subscriptionData, fifo, popMessageResultFilter, attemptId, timeoutMillis);\n        }  catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n",
      "    public CompletableFuture<PopResult> popMessage(\n        ProxyContext ctx,\n        AddressableMessageQueue messageQueue,\n        String consumerGroup,\n        String topic,\n        int maxMsgNums,\n        long invisibleTime,\n        long pollTime,\n        int initMode,\n        SubscriptionData subscriptionData,\n        boolean fifo,\n        PopMessageResultFilter popMessageResultFilter,\n        String attemptId,\n        long timeoutMillis\n    ) {\n        CompletableFuture<PopResult> future = new CompletableFuture<>();\n        try {\n            if (maxMsgNums > ProxyUtils.MAX_MSG_NUMS_FOR_POP_REQUEST) {\n                log.warn(\"change maxNums from {} to {} for pop request, with info: topic:{}, group:{}\",\n                    maxMsgNums, ProxyUtils.MAX_MSG_NUMS_FOR_POP_REQUEST, topic, consumerGroup);\n                maxMsgNums = ProxyUtils.MAX_MSG_NUMS_FOR_POP_REQUEST;\n            }\n\n            PopMessageRequestHeader requestHeader = new PopMessageRequestHeader();\n            requestHeader.setConsumerGroup(consumerGroup);\n            requestHeader.setTopic(topic);\n            requestHeader.setQueueId(messageQueue.getQueueId());\n            requestHeader.setMaxMsgNums(maxMsgNums);\n            requestHeader.setInvisibleTime(invisibleTime);\n            requestHeader.setPollTime(pollTime);\n            requestHeader.setInitMode(initMode);\n            requestHeader.setExpType(subscriptionData.getExpressionType());\n            requestHeader.setExp(subscriptionData.getSubString());\n            requestHeader.setOrder(fifo);\n            requestHeader.setAttemptId(attemptId);\n\n            future = this.serviceManager.getMessageService().popMessage(\n                    ctx,\n                    messageQueue,\n                    requestHeader,\n                    timeoutMillis)\n                .thenApplyAsync(popResult -> {\n                    if (PopStatus.FOUND.equals(popResult.getPopStatus()) &&\n                        popResult.getMsgFoundList() != null &&\n                        !popResult.getMsgFoundList().isEmpty() &&\n                        popMessageResultFilter != null) {\n\n                        List<MessageExt> messageExtList = new ArrayList<>();\n                        for (MessageExt messageExt : popResult.getMsgFoundList()) {\n                            try {\n                                fillUniqIDIfNeed(messageExt);\n                                String handleString = createHandle(messageExt.getProperty(MessageConst.PROPERTY_POP_CK), messageExt.getCommitLogOffset());\n                                if (handleString == null) {\n                                    log.error(\"[BUG] pop message from broker but handle is empty. requestHeader:{}, msg:{}\", requestHeader, messageExt);\n                                    messageExtList.add(messageExt);\n                                    continue;\n                                }\n                                MessageAccessor.putProperty(messageExt, MessageConst.PROPERTY_POP_CK, handleString);\n\n                                PopMessageResultFilter.FilterResult filterResult =\n                                    popMessageResultFilter.filterMessage(ctx, consumerGroup, subscriptionData, messageExt);\n                                switch (filterResult) {\n                                    case NO_MATCH:\n                                        this.messagingProcessor.ackMessage(\n                                            ctx,\n                                            ReceiptHandle.decode(handleString),\n                                            messageExt.getMsgId(),\n                                            consumerGroup,\n                                            topic,\n                                            MessagingProcessor.DEFAULT_TIMEOUT_MILLS);\n                                        break;\n                                    case TO_DLQ:\n                                        this.messagingProcessor.forwardMessageToDeadLetterQueue(\n                                            ctx,\n                                            ReceiptHandle.decode(handleString),\n                                            messageExt.getMsgId(),\n                                            consumerGroup,\n                                            topic,\n                                            MessagingProcessor.DEFAULT_TIMEOUT_MILLS);\n                                        break;\n                                    case MATCH:\n                                    default:\n                                        messageExtList.add(messageExt);\n                                        break;\n                                }\n                            } catch (Throwable t) {\n                                log.error(\"process filterMessage failed. requestHeader:{}, msg:{}\", requestHeader, messageExt, t);\n                                messageExtList.add(messageExt);\n                            }\n                        }\n                        popResult.setMsgFoundList(messageExtList);\n                    }\n                    return popResult;\n                }, this.executor);\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return FutureUtils.addExecutor(future, this.executor);\n    }\n"
    ],
    "test_id": 30,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testPopMessage() throws Throwable {\n    final String tag = \"tag\";\n    final long invisibleTime = Duration.ofSeconds(15).toMillis();\n    ArgumentCaptor<AddressableMessageQueue> messageQueueArgumentCaptor = ArgumentCaptor.forClass(AddressableMessageQueue.class);\n    ArgumentCaptor<PopMessageRequestHeader> requestHeaderArgumentCaptor = ArgumentCaptor.forClass(PopMessageRequestHeader.class);\n\n    List<MessageExt> messageExtList = new ArrayList<>();\n    messageExtList.add(createMessageExt(TOPIC, \"noMatch\", 0, invisibleTime));\n    messageExtList.add(createMessageExt(TOPIC, tag, 0, invisibleTime));\n    messageExtList.add(createMessageExt(TOPIC, tag, 1, invisibleTime));\n    PopResult innerPopResult = new PopResult(PopStatus.FOUND, messageExtList);\n    when(this.messageService.popMessage(any(), messageQueueArgumentCaptor.capture(), requestHeaderArgumentCaptor.capture(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(innerPopResult));\n\n    when(this.topicRouteService.getCurrentMessageQueueView(any(), anyString()))\n        .thenReturn(mock(MessageQueueView.class));\n\n    ArgumentCaptor<String> ackMessageIdArgumentCaptor = ArgumentCaptor.forClass(String.class);\n    when(this.messagingProcessor.ackMessage(any(), any(), ackMessageIdArgumentCaptor.capture(), anyString(), anyString(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(mock(AckResult.class)));\n\n    ArgumentCaptor<String> toDLQMessageIdArgumentCaptor = ArgumentCaptor.forClass(String.class);\n    when(this.messagingProcessor.forwardMessageToDeadLetterQueue(any(), any(), toDLQMessageIdArgumentCaptor.capture(), anyString(), anyString(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(mock(RemotingCommand.class)));\n\n    AddressableMessageQueue messageQueue = mock(AddressableMessageQueue.class);\n    PopResult popResult = this.consumerProcessor.popMessage(\n        createContext(),\n        (ctx, messageQueueView) -> messageQueue,\n        CONSUMER_GROUP,\n        TOPIC,\n        60,\n        invisibleTime,\n        Duration.ofSeconds(3).toMillis(),\n        ConsumeInitMode.MAX,\n        FilterAPI.build(TOPIC, tag, ExpressionType.TAG),\n        false,\n        (ctx, consumerGroup, subscriptionData, messageExt) -> {\n            if (!messageExt.getTags().equals(tag)) {\n                return PopMessageResultFilter.FilterResult.NO_MATCH;\n            }\n            if (messageExt.getReconsumeTimes() > 0) {\n                return PopMessageResultFilter.FilterResult.TO_DLQ;\n            }\n            return PopMessageResultFilter.FilterResult.MATCH;\n        },\n        Duration.ofSeconds(3).toMillis()\n    ).get();\n\n    assertSame(messageQueue, messageQueueArgumentCaptor.getValue());\n    assertEquals(CONSUMER_GROUP, requestHeaderArgumentCaptor.getValue().getConsumerGroup());\n    assertEquals(TOPIC, requestHeaderArgumentCaptor.getValue().getTopic());\n    assertEquals(ProxyUtils.MAX_MSG_NUMS_FOR_POP_REQUEST, requestHeaderArgumentCaptor.getValue().getMaxMsgNums());\n    assertEquals(tag, requestHeaderArgumentCaptor.getValue().getExp());\n    assertEquals(ExpressionType.TAG, requestHeaderArgumentCaptor.getValue().getExpType());\n\n    assertEquals(PopStatus.FOUND, popResult.getPopStatus());\n    assertEquals(1, popResult.getMsgFoundList().size());\n    assertEquals(messageExtList.get(1), popResult.getMsgFoundList().get(0));\n\n    assertEquals(messageExtList.get(0).getMsgId(), ackMessageIdArgumentCaptor.getValue());\n    assertEquals(messageExtList.get(2).getMsgId(), toDLQMessageIdArgumentCaptor.getValue());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testPopMessage() throws Throwable {\n    final String tag = \"tag\";\n    final long invisibleTime = Duration.ofSeconds(15).toMillis();\n    ArgumentCaptor<AddressableMessageQueue> messageQueueArgumentCaptor = ArgumentCaptor.forClass(AddressableMessageQueue.class);\n    ArgumentCaptor<PopMessageRequestHeader> requestHeaderArgumentCaptor = ArgumentCaptor.forClass(PopMessageRequestHeader.class);\n\n    List<MessageExt> messageExtList = new ArrayList<>();\n    messageExtList.add(createMessageExt(TOPIC, \"noMatch\", 0, invisibleTime));\n    messageExtList.add(createMessageExt(TOPIC, tag, 0, invisibleTime));\n    messageExtList.add(createMessageExt(TOPIC, tag, 1, invisibleTime));\n    PopResult innerPopResult = new PopResult(PopStatus.FOUND, messageExtList);\n    when(this.messageService.popMessage(any(), messageQueueArgumentCaptor.capture(), requestHeaderArgumentCaptor.capture(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(innerPopResult));\n\n    when(this.topicRouteService.getCurrentMessageQueueView(any(), anyString()))\n        .thenReturn(mock(MessageQueueView.class));\n\n    ArgumentCaptor<String> ackMessageIdArgumentCaptor = ArgumentCaptor.forClass(String.class);\n    when(this.messagingProcessor.ackMessage(any(), any(), ackMessageIdArgumentCaptor.capture(), anyString(), anyString(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(mock(AckResult.class)));\n\n    ArgumentCaptor<String> toDLQMessageIdArgumentCaptor = ArgumentCaptor.forClass(String.class);\n    when(this.messagingProcessor.forwardMessageToDeadLetterQueue(any(), any(), toDLQMessageIdArgumentCaptor.capture(), anyString(), anyString(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(mock(RemotingCommand.class)));\n\n    AddressableMessageQueue messageQueue = mock(AddressableMessageQueue.class);\n    PopResult popResult = this.consumerProcessor.popMessage(\n        createContext(),\n        (ctx, messageQueueView) -> messageQueue,\n        CONSUMER_GROUP,\n        TOPIC,\n        60,\n        invisibleTime,\n        Duration.ofSeconds(3).toMillis(),\n        ConsumeInitMode.MAX,\n        FilterAPI.build(TOPIC, tag, ExpressionType.TAG),\n        false,\n        (ctx, consumerGroup, subscriptionData, messageExt) -> {\n            if (!messageExt.getTags().equals(tag)) {\n                return PopMessageResultFilter.FilterResult.NO_MATCH;\n            }\n            if (messageExt.getReconsumeTimes() > 0) {\n                return PopMessageResultFilter.FilterResult.TO_DLQ;\n            }\n            return PopMessageResultFilter.FilterResult.MATCH;\n        },\n        Duration.ofSeconds(3).toMillis()\n    ).get();\n\n    assertSame(messageQueue, messageQueueArgumentCaptor.getValue());\n    assertEquals(CONSUMER_GROUP, requestHeaderArgumentCaptor.getValue().getConsumerGroup());\n    assertEquals(TOPIC, requestHeaderArgumentCaptor.getValue().getTopic());\n    assertEquals(ProxyUtils.MAX_MSG_NUMS_FOR_POP_REQUEST, requestHeaderArgumentCaptor.getValue().getMaxMsgNums());\n    assertEquals(tag, requestHeaderArgumentCaptor.getValue().getExp());\n    assertEquals(ExpressionType.TAG, requestHeaderArgumentCaptor.getValue().getExpType());\n\n    assertEquals(PopStatus.FOUND, popResult.getPopStatus());\n    assertEquals(1, popResult.getMsgFoundList().size());\n    assertEquals(messageExtList.get(1), popResult.getMsgFoundList().get(0));\n\n    assertEquals(messageExtList.get(0).getMsgId(), ackMessageIdArgumentCaptor.getValue());\n    assertEquals(messageExtList.get(2).getMsgId(), toDLQMessageIdArgumentCaptor.getValue());\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "OutOfMemoryError('CUDA out of memory. Tried to allocate 9.17 GiB. GPU 0 has a total capacty of 23.69 GiB of which 985.19 MiB is free. Process 1478252 has 22.72 GiB memory in use. Of the allocated memory 17.60 GiB is allocated by PyTorch, and 4.09 GiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF')"
  },
  "31": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddReceiptHandle",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage"
    ],
    "test_src_code": "    @Test\n    public void testAddReceiptHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 31,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testAddReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MSG_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n}\n",
      "@Test\npublic void testAddReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MSG_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n}\n",
      "@Test\npublic void testAddReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MSG_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n}\n",
      "@Test\npublic void testAddReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n}\n",
      "@Test\npublic void testAddReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testAddReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MSG_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n    // Testing the case where key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verifyNoMoreInteractions(metadataService);\n    Mockito.verifyNoMoreInteractions(messagingProcessor);\n}\n",
      "@Test\npublic void testAddReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MSG_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n    // Testing the case where key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verifyNoMoreInteractions(metadataService);\n    Mockito.verifyNoMoreInteractions(messagingProcessor);\n}\n",
      "@Test\npublic void testAddReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MSG_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n    // Testing the case where key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verifyNoMoreInteractions(metadataService);\n    Mockito.verifyNoMoreInteractions(messagingProcessor);\n}\n",
      "@Test\npublic void testAddReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n    // Testing the case where key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verifyNoMoreInteractions(metadataService);\n    Mockito.verifyNoMoreInteractions(messagingProcessor);\n}\n",
      "@Test\npublic void testAddReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n    // Testing the case where key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verifyNoMoreInteractions(metadataService);\n    Mockito.verifyNoMoreInteractions(messagingProcessor);\n}\n"
    ]
  },
  "32": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandle() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        long newInvisibleTime = 18000L;\n\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        String newReceiptHandle = newReceiptHandleClass.encode();\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n        AtomicInteger times = new AtomicInteger(0);\n\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        ackResult.setExtraInfo(newReceiptHandle);\n\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n            .thenReturn(CompletableFuture.completedFuture(ackResult));\n        receiptHandleProcessor.scheduleRenewTask();\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n        receiptHandleProcessor.scheduleRenewTask();\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n        receiptHandleProcessor.scheduleRenewTask();\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 32,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testRenewReceiptHandle() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    long newInvisibleTime = 18000L;\n\n    ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build();\n    String newReceiptHandle = newReceiptHandleClass.encode();\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n\n    AckResult ackResult = new AckResult();\n    ackResult.setStatus(AckStatus.OK);\n    ackResult.setExtraInfo(newReceiptHandle);\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n        .thenReturn(CompletableFuture.completedFuture(ackResult));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n    receiptHandleProcessor.scheduleRenewTask();\n}\n",
      "@Test\npublic void testRenewReceiptHandle() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    long newInvisibleTime = 18000L;\n\n    ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build();\n    String newReceiptHandle = newReceiptHandleClass.encode();\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n\n    AckResult ackResult = new AckResult();\n    ackResult.setStatus(AckStatus.OK);\n    ackResult.setExtraInfo(newReceiptHandle);\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n        .thenReturn(CompletableFuture.completedFuture(ackResult));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n    receiptHandleProcessor.scheduleRenewTask();\n}\n",
      "@Test\npublic void testRenewReceiptHandle() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    long newInvisibleTime = 18000L;\n\n    ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build();\n    String newReceiptHandle = newReceiptHandleClass.encode();\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n\n    AckResult ackResult = new AckResult();\n    ackResult.setStatus(AckStatus.OK);\n    ackResult.setExtraInfo(newReceiptHandle);\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n        .thenReturn(CompletableFuture.completedFuture(ackResult));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n    receiptHandleProcessor.scheduleRenewTask();\n}\n",
      "@Test\npublic void testRenewReceiptHandle() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    long newInvisibleTime = 18000L;\n\n    ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build();\n    String newReceiptHandle = newReceiptHandleClass.encode();\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n\n    AckResult ackResult = new AckResult();\n    ackResult.setStatus(AckStatus.OK);\n    ackResult.setExtraInfo(newReceiptHandle);\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n        .thenReturn(CompletableFuture.completedFuture(ackResult));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n    receiptHandleProcessor.scheduleRenewTask();\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testRenewReceiptHandle() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    long newInvisibleTime = 18000L;\n\n    ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build();\n    String newReceiptHandle = newReceiptHandleClass.encode();\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n\n    AckResult ackResult = new AckResult();\n    ackResult.setStatus(AckStatus.OK);\n    ackResult.setExtraInfo(newReceiptHandle);\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n        .thenReturn(CompletableFuture.completedFuture(ackResult));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n    receiptHandleProcessor.scheduleRenewTask();\n    // Testing the case where the key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandle() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    long newInvisibleTime = 18000L;\n\n    ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build();\n    String newReceiptHandle = newReceiptHandleClass.encode();\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n\n    AckResult ackResult = new AckResult();\n    ackResult.setStatus(AckStatus.OK);\n    ackResult.setExtraInfo(newReceiptHandle);\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n        .thenReturn(CompletableFuture.completedFuture(ackResult));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n    receiptHandleProcessor.scheduleRenewTask();\n    // Testing the case where the key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandle() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    long newInvisibleTime = 18000L;\n\n    ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build();\n    String newReceiptHandle = newReceiptHandleClass.encode();\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n\n    AckResult ackResult = new AckResult();\n    ackResult.setStatus(AckStatus.OK);\n    ackResult.setExtraInfo(newReceiptHandle);\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n        .thenReturn(CompletableFuture.completedFuture(ackResult));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n    receiptHandleProcessor.scheduleRenewTask();\n    // Testing the case where the key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandle() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    long newInvisibleTime = 18000L;\n\n    ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build();\n    String newReceiptHandle = newReceiptHandleClass.encode();\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n\n    AckResult ackResult = new AckResult();\n    ackResult.setStatus(AckStatus.OK);\n    ackResult.setExtraInfo(newReceiptHandle);\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n        .thenReturn(CompletableFuture.completedFuture(ackResult));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n    receiptHandleProcessor.scheduleRenewTask();\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n    receiptHandleProcessor.scheduleRenewTask();\n    // Testing the case where the key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.anyLong());\n}\n"
    ]
  },
  "33": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes"
    ],
    "test_src_code": "    @Test\n    public void testRenewExceedMaxRenewTimes() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n            .thenReturn(ackResultFuture);\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        Mockito.verify(messagingProcessor, Mockito.times(3))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 33,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testRenewExceedMaxRenewTimes() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.times(3))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n}\n",
      "@Test\npublic void testRenewExceedMaxRenewTimes() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.times(3))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n}\n",
      "@Test\npublic void testRenewExceedMaxRenewTimes() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.times(3))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n}\n",
      "@Test\npublic void testRenewExceedMaxRenewTimes() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.times(3))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n}\n",
      "@Test\npublic void testRenewExceedMaxRenewTimes() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.times(3))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testRenewExceedMaxRenewTimes() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.times(3))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n}\n",
      "@Test\npublic void testRenewExceedMaxRenewTimes() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.times(3))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n}\n",
      "@Test\npublic void testRenewExceedMaxRenewTimes() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.times(3))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n}\n",
      "@Test\npublic void testRenewExceedMaxRenewTimes() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.times(3))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n}\n",
      "@Test\npublic void testRenewExceedMaxRenewTimes() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.times(3))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n}\n"
    ]
  },
  "34": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle"
    ],
    "test_src_code": "    @Test\n    public void testRenewWithInvalidHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n            .thenReturn(ackResultFuture);\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 34,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testRenewWithInvalidHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n}\n",
      "@Test\npublic void testRenewWithInvalidHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n}\n",
      "@Test\npublic void testRenewWithInvalidHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testRenewWithInvalidHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, MSG_ID, messageReceiptHandle);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n",
      "@Test\npublic void testRenewWithInvalidHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, MSG_ID, messageReceiptHandle);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n",
      "@Test\npublic void testRenewWithInvalidHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n    ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n        Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n        .thenReturn(ackResultFuture);\n\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, MSG_ID, messageReceiptHandle);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n"
    ]
  },
  "35": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK"
    ],
    "test_src_code": "    @Test\n    public void testRenewWithErrorThenOK() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        AtomicInteger count = new AtomicInteger(0);\n        List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n        {\n            CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n            ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n        }\n        {\n            long newInvisibleTime = 2000L;\n            ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n                .startOffset(0L)\n                .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n                .invisibleTime(newInvisibleTime)\n                .reviveQueueId(1)\n                .topicType(ReceiptHandle.NORMAL_TOPIC)\n                .brokerName(BROKER_NAME)\n                .queueId(QUEUE_ID)\n                .offset(OFFSET)\n                .commitLogOffset(0L)\n                .build();\n            String newReceiptHandle = newReceiptHandleClass.encode();\n            AckResult ackResult = new AckResult();\n            ackResult.setStatus(AckStatus.OK);\n            ackResult.setExtraInfo(newReceiptHandle);\n            futureList.add(CompletableFuture.completedFuture(ackResult));\n        }\n        {\n            CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n            ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n        }\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n        AtomicInteger times = new AtomicInteger(0);\n        for (int i = 0; i < 6; i++) {\n            Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n                return futureList.get(count.getAndIncrement());\n            }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                    Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n        }\n\n        await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        assertEquals(6, count.get());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 35,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testRenewWithErrorThenOK() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    AtomicInteger count = new AtomicInteger(0);\n    List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n    {\n        long newInvisibleTime = 2000L;\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        String newReceiptHandle = newReceiptHandleClass.encode();\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        ackResult.setExtraInfo(newReceiptHandle);\n        futureList.add(CompletableFuture.completedFuture(ackResult));\n    }\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n    for (int i = 0; i < 6; i++) {\n        Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n            return futureList.get(count.getAndIncrement());\n        }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n    }\n\n    await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    assertEquals(6, count.get());\n}\n",
      "@Test\npublic void testRenewWithErrorThenOK() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    AtomicInteger count = new AtomicInteger(0);\n    List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n    {\n        long newInvisibleTime = 2000L;\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        String newReceiptHandle = newReceiptHandleClass.encode();\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        ackResult.setExtraInfo(newReceiptHandle);\n        futureList.add(CompletableFuture.completedFuture(ackResult));\n    }\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n    for (int i = 0; i < 6; i++) {\n        Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n            return futureList.get(count.getAndIncrement());\n        }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n    }\n\n    await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    assertEquals(6, count.get());\n}\n",
      "@Test\npublic void testRenewWithErrorThenOK() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    AtomicInteger count = new AtomicInteger(0);\n    List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n    {\n        long newInvisibleTime = 2000L;\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        futureList.add(CompletableFuture.completedFuture(ackResult));\n    }\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n    for (int i = 0; i < 6; i++) {\n        Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n            return futureList.get(count.getAndIncrement());\n        }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MSG_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n    }\n\n    await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    assertEquals(6, count.get());\n}\n",
      "@Test\npublic void testRenewWithErrorThenOK() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    AtomicInteger count = new AtomicInteger(0);\n    List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n    {\n        long newInvisibleTime = 2000L;\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        String newReceiptHandle = newReceiptHandleClass.encode();\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        ackResult.setExtraInfo(newReceiptHandle);\n        futureList.add(CompletableFuture.completedFuture(ackResult));\n    }\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n    for (int i = 0; i < 6; i++) {\n        Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n            return futureList.get(count.getAndIncrement());\n        }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n    }\n\n    await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    assertEquals(6, count.get());\n}\n",
      "@Test\npublic void testRenewWithErrorThenOK() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    AtomicInteger count = new AtomicInteger(0);\n    List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n    {\n        long newInvisibleTime = 2000L;\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        String newReceiptHandle = newReceiptHandleClass.encode();\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        ackResult.setExtraInfo(newReceiptHandle);\n        futureList.add(CompletableFuture.completedFuture(ackResult));\n    }\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n    for (int i = 0; i < 6; i++) {\n        Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n            return futureList.get(count.getAndIncrement());\n        }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n    }\n\n    await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    assertEquals(6, count.get());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testRenewWithErrorThenOK() {\n    ProxyConfig config = ConfigurationManager.getProxyConfig();\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n\n    AtomicInteger count = new AtomicInteger(0);\n    List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n    {\n        long newInvisibleTime = 2000L;\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        futureList.add(CompletableFuture.completedFuture(ackResult));\n    }\n    {\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n        futureList.add(ackResultFuture);\n    }\n\n    RetryPolicy retryPolicy = new RenewStrategyPolicy();\n    AtomicInteger times = new AtomicInteger(0);\n    for (int i = 0; i < 6; i++) {\n        Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n            return futureList.get(count.getAndIncrement());\n        }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MSG_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n    }\n\n    await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n        receiptHandleProcessor.scheduleRenewTask();\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    assertEquals(6, count.get());\n    // Adding more test cases to cover the uncovered lines and branches\n    // Testing with null key\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n\n    // Testing with null messageReceiptHandle\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, null);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n\n    // Testing with null msgID\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, null, messageReceiptHandle);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n"
    ]
  },
  "36": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenTimeout() {\n        long newInvisibleTime = 200L;\n        long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n        await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            assertTrue(receiptHandleGroup.isEmpty());\n        });\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 36,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testRenewReceiptHandleWhenTimeout() {\n    long newInvisibleTime = 200L;\n    long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    MessageReceiptHandle messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n    await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n        ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n        assertTrue(receiptHandleGroup.isEmpty());\n    });\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenTimeout() {\n    long newInvisibleTime = 200L;\n    long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n    await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n        ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n        assertTrue(receiptHandleGroup.isEmpty());\n    });\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenTimeout() {\n    long newInvisibleTime = 200L;\n    long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    MessageReceiptHandle messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n    await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n        ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n        assertTrue(receiptHandleGroup.isEmpty());\n    });\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenTimeout() {\n    long newInvisibleTime = 200L;\n    long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    MessageReceiptHandle messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n    await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n        ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n        assertTrue(receiptHandleGroup.isEmpty());\n    });\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenTimeout() {\n    long newInvisibleTime = 200L;\n    long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n    await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n        ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n        assertTrue(receiptHandleGroup.isEmpty());\n    });\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testRenewReceiptHandleWhenTimeout() {\n    long newInvisibleTime = 200L;\n    long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n    await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n        ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n        assertTrue(receiptHandleGroup.isEmpty());\n    });\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenTimeout() {\n    long newInvisibleTime = 200L;\n    long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n        .invisibleTime(newInvisibleTime)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n    await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n        ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n        assertTrue(receiptHandleGroup.isEmpty());\n    });\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n"
    ]
  },
  "37": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenTimeoutWithNoSubscription() {\n        long newInvisibleTime = 0L;\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(0)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(null);\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n        receiptHandleProcessor.scheduleRenewTask();\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 37,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testRenewReceiptHandleWhenTimeoutWithNoSubscription() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(0)\n        .invisibleTime(0L)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    MessageReceiptHandle messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(null);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenTimeoutWithNoSubscription() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(0)\n        .invisibleTime(0L)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(null);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testRenewReceiptHandleWhenTimeoutWithNoSubscription() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(0)\n        .invisibleTime(0L)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    MessageReceiptHandle messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(null);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    // Adding a test case to cover the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenTimeoutWithNoSubscription() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(0)\n        .invisibleTime(0L)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(null);\n    Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n    receiptHandleProcessor.scheduleRenewTask();\n    await().atMost(Duration.ofSeconds(1)).until(() -> {\n        try {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            return receiptHandleGroup.isEmpty();\n        } catch (Exception e) {\n            return false;\n        }\n    });\n\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    // Add more test cases to cover the uncovered lines and branches\n    // Test case for when key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.times(0)).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n        Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n\n    // Test case for when messageReceiptHandle is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, null);\n    Mockito.verify(messagingProcessor, Mockito.times(0)).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n        Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n"
    ]
  },
  "38": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenNotArrivingTime() {\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis())\n            .invisibleTime(INVISIBLE_TIME)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 38,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testRenewReceiptHandleWhenNotArrivingTime() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis())\n        .invisibleTime(INVISIBLE_TIME)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenNotArrivingTime() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis())\n        .invisibleTime(INVISIBLE_TIME)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenNotArrivingTime() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis())\n        .invisibleTime(INVISIBLE_TIME)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenNotArrivingTime() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis())\n        .invisibleTime(INVISIBLE_TIME)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenNotArrivingTime() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis())\n        .invisibleTime(INVISIBLE_TIME)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testRenewReceiptHandleWhenNotArrivingTime() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis())\n        .invisibleTime(INVISIBLE_TIME)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenNotArrivingTime() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis())\n        .invisibleTime(INVISIBLE_TIME)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenNotArrivingTime() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis())\n        .invisibleTime(INVISIBLE_TIME)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenNotArrivingTime() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis())\n        .invisibleTime(INVISIBLE_TIME)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n",
      "@Test\npublic void testRenewReceiptHandleWhenNotArrivingTime() {\n    String newReceiptHandle = ReceiptHandle.builder()\n        .startOffset(0L)\n        .retrieveTime(System.currentTimeMillis())\n        .invisibleTime(INVISIBLE_TIME)\n        .reviveQueueId(1)\n        .topicType(ReceiptHandle.NORMAL_TOPIC)\n        .brokerName(BROKER_NAME)\n        .queueId(QUEUE_ID)\n        .offset(OFFSET)\n        .commitLogOffset(0L)\n        .build().encode();\n    messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n        RECONSUME_TIMES);\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verify(messagingProcessor, Mockito.never()).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n"
    ]
  },
  "39": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle"
    ],
    "test_src_code": "    @Test\n    public void testRemoveReceiptHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        receiptHandleProcessor.removeReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 39,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testRemoveReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n    receiptHandleProcessor.removeReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testRemoveReceiptHandle() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n    receiptHandleProcessor.removeReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle);\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n            Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n}\n"
    ]
  },
  "40": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup"
    ],
    "test_src_code": "    @Test\n    public void testClearGroup() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 40,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    // Testing the uncovered lines\n    // Testing the case where the key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verifyNoInteractions(messagingProcessor);\n\n    // Testing the case where the messageReceiptHandle is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, null);\n    Mockito.verifyNoInteractions(messagingProcessor);\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    // Testing the uncovered lines\n    // Testing the case where the key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verifyNoInteractions(messagingProcessor);\n\n    // Testing the case where the messageReceiptHandle is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, null);\n    Mockito.verifyNoInteractions(messagingProcessor);\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    // Testing the uncovered lines\n    // Testing the case where the key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verifyNoInteractions(messagingProcessor);\n\n    // Testing the case where the messageReceiptHandle is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, null);\n    Mockito.verifyNoInteractions(messagingProcessor);\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    // Testing the uncovered lines\n    // Testing the case where the key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verifyNoInteractions(messagingProcessor);\n\n    // Testing the case where the messageReceiptHandle is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, null);\n    Mockito.verifyNoInteractions(messagingProcessor);\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleProcessor.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    // Testing the uncovered lines\n    // Testing the case where the key is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    Mockito.verifyNoInteractions(messagingProcessor);\n\n    // Testing the case where the messageReceiptHandle is null\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, null);\n    Mockito.verifyNoInteractions(messagingProcessor);\n}\n"
    ]
  },
  "41": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline"
    ],
    "test_src_code": "    @Test\n    public void testClientOffline() {\n        ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n        Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n        assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
      "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n"
    ],
    "test_id": 41,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testClientOffline() {\n    ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n    Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n",
      "@Test\npublic void testClientOffline() {\n    ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n    Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n",
      "@Test\npublic void testClientOffline() {\n    ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n    Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n",
      "@Test\npublic void testClientOffline() {\n    ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n    Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n",
      "@Test\npublic void testClientOffline() {\n    ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n    Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testClientOffline() {\n    ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n    Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n",
      "@Test\npublic void testClientOffline() {\n    ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n    Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n",
      "@Test\npublic void testClientOffline() {\n    ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n    Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n",
      "@Test\npublic void testClientOffline() {\n    ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n    Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n",
      "@Test\npublic void testClientOffline() {\n    ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n    Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n    // Testing the uncovered line\n    receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, null, GROUP, MSG_ID, messageReceiptHandle);\n    assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n}\n"
    ]
  },
  "42": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "test_src_code": "    @Test\n    public void testNum() {\n        BrokerController brokerController = mock(BrokerController.class);\n        long brokerStartTime = System.currentTimeMillis();\n        when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n        PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n        final String topic = \"topic\";\n        final String group = \"group\";\n\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.incrementInFlightMessageNum(topic, group, 0, 3);\n        assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis() - 1000,\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        PopCheckPoint popCheckPoint = new PopCheckPoint();\n        popCheckPoint.setTopic(topic);\n        popCheckPoint.setCId(group);\n        popCheckPoint.setQueueId(0);\n        popCheckPoint.setPopTime(System.currentTimeMillis());\n\n        counter.decrementInFlightMessageNum(popCheckPoint);\n        assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    }\n",
    "focal_path_src": [
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum"
    ],
    "focal_path_tgt": [
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
      "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum"
    ],
    "focal_src": [
      "    public void decrementInFlightMessageNum(String topic, String group, String ckInfo) {\n        String[] ckInfoList = ExtraInfoUtil.split(ckInfo);\n        long popTime = ExtraInfoUtil.getPopTime(ckInfoList);\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, ExtraInfoUtil.getQueueId(ckInfoList));\n    }\n",
      "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId());\n    }\n",
      "    public void decrementInFlightMessageNum(String topic, String group, int queueId) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.decrementAndGet() <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n"
    ],
    "focal_tgt": [
      "    public void decrementInFlightMessageNum(String topic, String group, long popTime, int qId, int delta) {\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, qId, delta);\n    }\n",
      "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId(), 1);\n    }\n",
      "    private void decrementInFlightMessageNum(String topic, String group, int queueId, int delta) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.addAndGet(-delta) <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n"
    ],
    "test_id": 42,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testNum() {\n    BrokerController brokerController = mock(BrokerController.class);\n    long brokerStartTime = System.currentTimeMillis();\n    when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n    PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n    final String topic = \"topic\";\n    final String group = \"group\";\n\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.incrementInFlightMessageNum(topic, group, 0, 3);\n    assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 2);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis() - 1000, 0, 2);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    PopCheckPoint popCheckPoint = new PopCheckPoint();\n    popCheckPoint.setTopic(topic);\n    popCheckPoint.setCId(group);\n    popCheckPoint.setQueueId(0);\n    popCheckPoint.setPopTime(System.currentTimeMillis());\n\n    counter.decrementInFlightMessageNum(popCheckPoint);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n}\n",
      "@Test\npublic void testNum() {\n    BrokerController brokerController = mock(BrokerController.class);\n    long brokerStartTime = System.currentTimeMillis();\n    when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n    PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n    final String topic = \"topic\";\n    final String group = \"group\";\n\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.incrementInFlightMessageNum(topic, group, 0, 3);\n    assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis() - 1000, 0, 1);\n    assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    PopCheckPoint popCheckPoint = new PopCheckPoint();\n    popCheckPoint.setTopic(topic);\n    popCheckPoint.setCId(group);\n    popCheckPoint.setQueueId(0);\n    popCheckPoint.setPopTime(System.currentTimeMillis());\n\n    counter.decrementInFlightMessageNum(popCheckPoint);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n}\n",
      "@Test\npublic void testNum() {\n    BrokerController brokerController = mock(BrokerController.class);\n    long brokerStartTime = System.currentTimeMillis();\n    when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n    PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n    final String topic = \"topic\";\n    final String group = \"group\";\n\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.incrementInFlightMessageNum(topic, group, 0, 3);\n    assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis() - 1000, 0, 1);\n    assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    PopCheckPoint popCheckPoint = new PopCheckPoint();\n    popCheckPoint.setTopic(topic);\n    popCheckPoint.setCId(group);\n    popCheckPoint.setQueueId(0);\n    popCheckPoint.setPopTime(System.currentTimeMillis());\n\n    counter.decrementInFlightMessageNum(popCheckPoint);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testNum() {\n    BrokerController brokerController = mock(BrokerController.class);\n    long brokerStartTime = System.currentTimeMillis();\n    when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n    PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n    final String topic = \"topic\";\n    final String group = \"group\";\n\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.incrementInFlightMessageNum(topic, group, 0, 3);\n    assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 2);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis() - 1000, 0, 2);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    PopCheckPoint popCheckPoint = new PopCheckPoint();\n    popCheckPoint.setTopic(topic);\n    popCheckPoint.setCId(group);\n    popCheckPoint.setQueueId(0);\n    popCheckPoint.setPopTime(System.currentTimeMillis());\n\n    counter.decrementInFlightMessageNum(popCheckPoint);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    // Testing the uncovered lines and branches\n    counter.incrementInFlightMessageNum(topic, group, 0, 1);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis() + 1000, 0, 1);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    popCheckPoint.setPopTime(System.currentTimeMillis() + 1000);\n    counter.decrementInFlightMessageNum(popCheckPoint);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n}\n",
      "@Test\npublic void testNum() {\n    BrokerController brokerController = mock(BrokerController.class);\n    long brokerStartTime = System.currentTimeMillis();\n    when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n    PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n    final String topic = \"topic\";\n    final String group = \"group\";\n\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.incrementInFlightMessageNum(topic, group, 0, 3);\n    assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis() - 1000, 0, 1);\n    assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    PopCheckPoint popCheckPoint = new PopCheckPoint();\n    popCheckPoint.setTopic(topic);\n    popCheckPoint.setCId(group);\n    popCheckPoint.setQueueId(0);\n    popCheckPoint.setPopTime(System.currentTimeMillis());\n\n    counter.decrementInFlightMessageNum(popCheckPoint);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    // Testing the uncovered lines and branches\n    counter.incrementInFlightMessageNum(topic, group, 0, 1);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis() + 1000, 0, 1);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    popCheckPoint.setPopTime(System.currentTimeMillis() + 1000);\n    counter.decrementInFlightMessageNum(popCheckPoint);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 2);\n    assertEquals(-1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n}\n",
      "@Test\npublic void testNum() {\n    BrokerController brokerController = mock(BrokerController.class);\n    long brokerStartTime = System.currentTimeMillis();\n    when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n    PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n    final String topic = \"topic\";\n    final String group = \"group\";\n\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.incrementInFlightMessageNum(topic, group, 0, 3);\n    assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis() - 1000, 0, 1);\n    assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    PopCheckPoint popCheckPoint = new PopCheckPoint();\n    popCheckPoint.setTopic(topic);\n    popCheckPoint.setCId(group);\n    popCheckPoint.setQueueId(0);\n    popCheckPoint.setPopTime(System.currentTimeMillis());\n\n    counter.decrementInFlightMessageNum(popCheckPoint);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 1);\n    assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    // Testing the uncovered lines and branches\n    counter.incrementInFlightMessageNum(topic, group, 0, 1);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis() + 1000, 0, 1);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    popCheckPoint.setPopTime(System.currentTimeMillis() + 1000);\n    counter.decrementInFlightMessageNum(popCheckPoint);\n    assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n    counter.decrementInFlightMessageNum(topic, group, System.currentTimeMillis(), 0, 2);\n    assertEquals(-1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n}\n"
    ]
  },
  "43": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.message.ClusterMessageServiceTest#testAckMessageByInvalidBrokerNameHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.message.ClusterMessageServiceTest#testAckMessageByInvalidBrokerNameHandle"
    ],
    "test_src_code": "    @Test\n    public void testAckMessageByInvalidBrokerNameHandle() throws Exception {\n        when(topicRouteService.getBrokerAddr(anyString())).thenThrow(new MQClientException(ResponseCode.TOPIC_NOT_EXIST, \"\"));\n        try {\n            this.clusterMessageService.ackMessage(\n                ProxyContext.create(),\n                ReceiptHandle.builder()\n                    .startOffset(0L)\n                    .retrieveTime(System.currentTimeMillis())\n                    .invisibleTime(3000)\n                    .reviveQueueId(1)\n                    .topicType(ReceiptHandle.NORMAL_TOPIC)\n                    .brokerName(\"notExistBroker\")\n                    .queueId(0)\n                    .offset(123)\n                    .commitLogOffset(0L)\n                    .build(),\n                MessageClientIDSetter.createUniqID(),\n                new AckMessageRequestHeader(),\n                3000);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e instanceof ProxyException);\n            ProxyException proxyException = (ProxyException) e;\n            assertEquals(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, proxyException.getCode());\n        }\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/message/ClusterMessageService.java#ackMessage"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/message/ClusterMessageService.java#ackMessage"
    ],
    "focal_src": [
      "    @Override\n    public CompletableFuture<AckResult> ackMessage(ProxyContext ctx, ReceiptHandle handle, String messageId,\n        AckMessageRequestHeader requestHeader, long timeoutMillis) {\n        return this.mqClientAPIFactory.getClient().ackMessageAsync(\n            this.resolveBrokerAddrInReceiptHandle(handle),\n            requestHeader,\n            timeoutMillis\n        );\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public CompletableFuture<AckResult> ackMessage(ProxyContext ctx, ReceiptHandle handle, String messageId,\n        AckMessageRequestHeader requestHeader, long timeoutMillis) {\n        return this.mqClientAPIFactory.getClient().ackMessageAsync(\n            this.resolveBrokerAddrInReceiptHandle(ctx, handle),\n            requestHeader,\n            timeoutMillis\n        );\n    }\n"
    ],
    "test_id": 43,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testAckMessageByInvalidBrokerNameHandle() throws Exception {\n    when(topicRouteService.getBrokerAddr(anyString())).thenThrow(new MQClientException(ResponseCode.TOPIC_NOT_EXIST, \"\"));\n    try {\n        this.clusterMessageService.ackMessage(\n            ProxyContext.create(),\n            ReceiptHandle.builder()\n                .startOffset(0L)\n                .retrieveTime(System.currentTimeMillis())\n                .invisibleTime(3000)\n                .reviveQueueId(1)\n                .topicType(ReceiptHandle.NORMAL_TOPIC)\n                .brokerName(\"notExistBroker\")\n                .queueId(0)\n                .offset(123)\n                .commitLogOffset(0L)\n                .build(),\n            MessageClientIDSetter.createUniqID(),\n            new AckMessageRequestHeader(),\n            3000);\n        fail();\n    } catch (Exception e) {\n        assertTrue(e instanceof ProxyException);\n        ProxyException proxyException = (ProxyException) e;\n        assertEquals(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, proxyException.getCode());\n    }\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testAckMessageByInvalidBrokerNameHandle() throws Exception {\n    when(topicRouteService.getBrokerAddr(anyString())).thenThrow(new MQClientException(ResponseCode.TOPIC_NOT_EXIST, \"\"));\n    try {\n        this.clusterMessageService.ackMessage(\n            ProxyContext.create(),\n            ReceiptHandle.builder()\n                .startOffset(0L)\n                .retrieveTime(System.currentTimeMillis())\n                .invisibleTime(3000)\n                .reviveQueueId(1)\n                .topicType(ReceiptHandle.NORMAL_TOPIC)\n                .brokerName(\"notExistBroker\")\n                .queueId(0)\n                .offset(123)\n                .commitLogOffset(0L)\n                .build(),\n            MessageClientIDSetter.createUniqID(),\n            new AckMessageRequestHeader(),\n            3000);\n        fail();\n    } catch (Exception e) {\n        assertTrue(e instanceof ProxyException);\n        ProxyException proxyException = (ProxyException) e;\n        assertEquals(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, proxyException.getCode());\n    }\n}\n"
    ]
  },
  "44": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetTopicMessageType",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetTopicMessageType"
    ],
    "test_src_code": "    @Test\n    public void testGetTopicMessageType() {\n        assertEquals(TopicMessageType.UNSPECIFIED, this.clusterMetadataService.getTopicMessageType(ERR_TOPIC));\n        assertEquals(1, this.clusterMetadataService.topicConfigCache.asMap().size());\n        assertEquals(TopicMessageType.UNSPECIFIED, this.clusterMetadataService.getTopicMessageType(ERR_TOPIC));\n\n        assertEquals(TopicMessageType.NORMAL, this.clusterMetadataService.getTopicMessageType(TOPIC));\n        assertEquals(2, this.clusterMetadataService.topicConfigCache.asMap().size());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataService.java#getTopicMessageType"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataService.java#getTopicMessageType"
    ],
    "focal_src": [
      "    @Override\n    public TopicMessageType getTopicMessageType(String topic) {\n        TopicConfigAndQueueMapping topicConfigAndQueueMapping;\n        try {\n            topicConfigAndQueueMapping = topicConfigCache.get(topic);\n        } catch (Exception e) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        if (topicConfigAndQueueMapping.equals(EMPTY_TOPIC_CONFIG)) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        return topicConfigAndQueueMapping.getTopicMessageType();\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public TopicMessageType getTopicMessageType(ProxyContext ctx, String topic) {\n        TopicConfigAndQueueMapping topicConfigAndQueueMapping;\n        try {\n            topicConfigAndQueueMapping = topicConfigCache.get(topic);\n        } catch (Exception e) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        if (topicConfigAndQueueMapping.equals(EMPTY_TOPIC_CONFIG)) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        return topicConfigAndQueueMapping.getTopicMessageType();\n    }\n"
    ],
    "test_id": 44,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetTopicMessageType() {\n    ProxyContext ctx = new ProxyContext();\n    assertEquals(TopicMessageType.UNSPECIFIED, this.clusterMetadataService.getTopicMessageType(ctx, ERR_TOPIC));\n    assertEquals(1, this.clusterMetadataService.topicConfigCache.asMap().size());\n    assertEquals(TopicMessageType.UNSPECIFIED, this.clusterMetadataService.getTopicMessageType(ctx, ERR_TOPIC));\n\n    assertEquals(TopicMessageType.NORMAL, this.clusterMetadataService.getTopicMessageType(ctx, TOPIC));\n    assertEquals(2, this.clusterMetadataService.topicConfigCache.asMap().size());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testGetTopicMessageType() {\n    assertEquals(TopicMessageType.UNSPECIFIED, this.clusterMetadataService.getTopicMessageType(ERR_TOPIC));\n    assertEquals(1, this.clusterMetadataService.topicConfigCache.asMap().size());\n    assertEquals(TopicMessageType.UNSPECIFIED, this.clusterMetadataService.getTopicMessageType(ERR_TOPIC));\n\n    assertEquals(TopicMessageType.NORMAL, this.clusterMetadataService.getTopicMessageType(TOPIC));\n    assertEquals(2, this.clusterMetadataService.topicConfigCache.asMap().size());\n}\n"
    ]
  },
  "45": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetSubscriptionGroupConfig",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetSubscriptionGroupConfig"
    ],
    "test_src_code": "    @Test\n    public void testGetSubscriptionGroupConfig() {\n        assertNotNull(this.clusterMetadataService.getSubscriptionGroupConfig(GROUP));\n        assertEquals(1, this.clusterMetadataService.subscriptionGroupConfigCache.asMap().size());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataService.java#getSubscriptionGroupConfig"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataService.java#getSubscriptionGroupConfig"
    ],
    "focal_src": [
      "    @Override\n    public SubscriptionGroupConfig getSubscriptionGroupConfig(String group) {\n        SubscriptionGroupConfig config;\n        try {\n            config = this.subscriptionGroupConfigCache.get(group);\n        } catch (Exception e) {\n            return null;\n        }\n        if (config == EMPTY_SUBSCRIPTION_GROUP_CONFIG) {\n            return null;\n        }\n        return config;\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public SubscriptionGroupConfig getSubscriptionGroupConfig(ProxyContext ctx, String group) {\n        SubscriptionGroupConfig config;\n        try {\n            config = this.subscriptionGroupConfigCache.get(group);\n        } catch (Exception e) {\n            return null;\n        }\n        if (config == EMPTY_SUBSCRIPTION_GROUP_CONFIG) {\n            return null;\n        }\n        return config;\n    }\n"
    ],
    "test_id": 45,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetSubscriptionGroupConfig() {\n    ProxyContext ctx = new ProxyContext();\n    assertNotNull(this.clusterMetadataService.getSubscriptionGroupConfig(ctx, GROUP));\n    assertEquals(1, this.clusterMetadataService.subscriptionGroupConfigCache.asMap().size());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testGetSubscriptionGroupConfig() {\n    assertNotNull(this.clusterMetadataService.getSubscriptionGroupConfig(GROUP));\n    assertEquals(1, this.clusterMetadataService.subscriptionGroupConfigCache.asMap().size());\n}\n"
    ]
  },
  "46": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetCurrentMessageQueueView",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetCurrentMessageQueueView"
    ],
    "test_src_code": "    @Test\n    public void testGetCurrentMessageQueueView() throws Throwable {\n        MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(ERR_TOPIC), MQClientException.class);\n        assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n        assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n        assertNotNull(this.topicRouteService.getCurrentMessageQueueView(TOPIC));\n        assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteService.java#getCurrentMessageQueueView"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteService.java#getCurrentMessageQueueView"
    ],
    "focal_src": [
      "    @Override\n    public MessageQueueView getCurrentMessageQueueView(String topicName) throws Exception {\n        return getAllMessageQueueView(topicName);\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public MessageQueueView getCurrentMessageQueueView(ProxyContext ctx, String topicName) throws Exception {\n        return getAllMessageQueueView(ctx, topicName);\n    }\n"
    ],
    "test_id": 46,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(new ProxyContext(), ERR_TOPIC), MQClientException.class);\n    assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n    assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n    assertNotNull(this.topicRouteService.getCurrentMessageQueueView(new ProxyContext(), TOPIC));\n    assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n}\n",
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    // Assuming ProxyContext is a parameter in getCurrentMessageQueueView\n    ProxyContext ctx = new ProxyContext();\n\n    MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(ctx, ERR_TOPIC), MQClientException.class);\n    assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n    assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n    assertNotNull(this.topicRouteService.getCurrentMessageQueueView(ctx, TOPIC));\n    assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n}\n",
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    ProxyContext ctx = new ProxyContext();\n    MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(ctx, ERR_TOPIC), MQClientException.class);\n    assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n    assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n    assertNotNull(this.topicRouteService.getCurrentMessageQueueView(ctx, TOPIC));\n    assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n}\n",
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(new ProxyContext(), ERR_TOPIC), MQClientException.class);\n    assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n    assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n    assertNotNull(this.topicRouteService.getCurrentMessageQueueView(new ProxyContext(), TOPIC));\n    assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n}\n",
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    ProxyContext ctx = new ProxyContext();\n    MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(ctx, ERR_TOPIC), MQClientException.class);\n    assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n    assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n    assertNotNull(this.topicRouteService.getCurrentMessageQueueView(ctx, TOPIC));\n    assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(new ProxyContext(), ERR_TOPIC), MQClientException.class);\n    assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n    assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n    assertNotNull(this.topicRouteService.getCurrentMessageQueueView(new ProxyContext(), TOPIC));\n    assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n}\n",
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    // Assuming ProxyContext is a parameter in getCurrentMessageQueueView\n    ProxyContext ctx = new ProxyContext();\n\n    MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(ctx, ERR_TOPIC), MQClientException.class);\n    assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n    assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n    assertNotNull(this.topicRouteService.getCurrentMessageQueueView(ctx, TOPIC));\n    assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n}\n",
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    ProxyContext ctx = new ProxyContext();\n    MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(ctx, ERR_TOPIC), MQClientException.class);\n    assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n    assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n    assertNotNull(this.topicRouteService.getCurrentMessageQueueView(ctx, TOPIC));\n    assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n}\n",
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(new ProxyContext(), ERR_TOPIC), MQClientException.class);\n    assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n    assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n    assertNotNull(this.topicRouteService.getCurrentMessageQueueView(new ProxyContext(), TOPIC));\n    assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n}\n",
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    ProxyContext ctx = new ProxyContext();\n    MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(ctx, ERR_TOPIC), MQClientException.class);\n    assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n    assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n    assertNotNull(this.topicRouteService.getCurrentMessageQueueView(ctx, TOPIC));\n    assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n}\n"
    ]
  },
  "47": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetTopicRouteForProxy",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetTopicRouteForProxy"
    ],
    "test_src_code": "    @Test\n    public void testGetTopicRouteForProxy() throws Throwable {\n        List<Address> addressList = Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\"127.0.0.1\", 8888)));\n        ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(addressList, TOPIC);\n\n        assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n        assertEquals(addressList, proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteService.java#getTopicRouteForProxy"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteService.java#getTopicRouteForProxy"
    ],
    "focal_src": [
      "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        TopicRouteData topicRouteData = getAllMessageQueueView(topicName).getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                proxyBrokerData.getBrokerAddrs().put(brokerId, requestHostAndPortList);\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(ProxyContext ctx, List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        TopicRouteData topicRouteData = getAllMessageQueueView(ctx, topicName).getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                proxyBrokerData.getBrokerAddrs().put(brokerId, requestHostAndPortList);\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n"
    ],
    "test_id": 47,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetTopicRouteForProxy() throws Throwable {\n    List<Address> addressList = Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\"127.0.0.1\", 8888)));\n    ProxyContext ctx = new ProxyContext();\n    ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(ctx, addressList, TOPIC);\n\n    assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n    assertEquals(addressList, proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n}\n",
      "@Test\npublic void testGetTopicRouteForProxy() throws Throwable {\n    List<Address> addressList = Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\"127.0.0.1\", 8888)));\n    ProxyContext ctx = new ProxyContext();\n    ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(ctx, addressList, TOPIC);\n\n    assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n    assertEquals(addressList, proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n}\n",
      "@Test\npublic void testGetTopicRouteForProxy() throws Throwable {\n    List<Address> addressList = Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\"127.0.0.1\", 8888)));\n    ProxyContext ctx = new ProxyContext(); // Assuming ProxyContext is a valid context\n    ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(ctx, addressList, TOPIC);\n\n    assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n    assertEquals(addressList, proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n}\n",
      "@Test\npublic void testGetTopicRouteForProxy() throws Throwable {\n    ProxyContext ctx = new ProxyContext();\n    List<Address> addressList = Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\"127.0.0.1\", 8888)));\n    ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(ctx, addressList, TOPIC);\n\n    assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n    assertEquals(addressList, proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n}\n",
      "@Test\npublic void testGetTopicRouteForProxy() throws Throwable {\n    ProxyContext ctx = new ProxyContext();\n    List<Address> addressList = Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\"127.0.0.1\", 8888)));\n    ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(ctx, addressList, TOPIC);\n\n    assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n    assertEquals(addressList, proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testGetTopicRouteForProxy() throws Throwable {\n    List<Address> addressList = Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\"127.0.0.1\", 8888)));\n    ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(addressList, TOPIC);\n\n    assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n    assertEquals(addressList, proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n}\n"
    ]
  },
  "48": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetCurrentMessageQueueView",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetCurrentMessageQueueView"
    ],
    "test_src_code": "    @Test\n    public void testGetCurrentMessageQueueView() throws Throwable {\n        this.topicConfigTable.put(TOPIC, new TopicConfig(TOPIC, 3, 2, PermName.PERM_WRITE | PermName.PERM_READ));\n        MessageQueueView messageQueueView = this.topicRouteService.getCurrentMessageQueueView(TOPIC);\n        assertEquals(3, messageQueueView.getReadSelector().getQueues().size());\n        assertEquals(2, messageQueueView.getWriteSelector().getQueues().size());\n        assertEquals(1, messageQueueView.getReadSelector().getBrokerActingQueues().size());\n        assertEquals(1, messageQueueView.getWriteSelector().getBrokerActingQueues().size());\n\n        assertEquals(LOCAL_ADDR, messageQueueView.getReadSelector().selectOne(true).getBrokerAddr());\n        assertEquals(LOCAL_BROKER_NAME, messageQueueView.getReadSelector().selectOne(true).getBrokerName());\n        assertEquals(messageQueueView.getReadSelector().selectOne(true), messageQueueView.getWriteSelector().selectOne(true));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteService.java#getCurrentMessageQueueView",
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteService.java#getBrokerAddr"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteService.java#getCurrentMessageQueueView",
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteService.java#getBrokerAddr"
    ],
    "focal_src": [
      "    @Override\n    public MessageQueueView getCurrentMessageQueueView(String topic) throws Exception {\n        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().getTopicConfigTable().get(topic);\n        return new MessageQueueView(topic, toTopicRouteData(topicConfig));\n    }\n",
      "    @Override\n    public String getBrokerAddr(String brokerName) throws Exception {\n        return this.brokerController.getBrokerAddr();\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public MessageQueueView getCurrentMessageQueueView(ProxyContext ctx, String topic) throws Exception {\n        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().getTopicConfigTable().get(topic);\n        return new MessageQueueView(topic, toTopicRouteData(topicConfig));\n    }\n",
      "    @Override\n    public String getBrokerAddr(ProxyContext ctx, String brokerName) throws Exception {\n        return this.brokerController.getBrokerAddr();\n    }\n"
    ],
    "test_id": 48,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    this.topicConfigTable.put(TOPIC, new TopicConfig(TOPIC, 3, 2, PermName.PERM_WRITE | PermName.PERM_READ));\n    ProxyContext ctx = new ProxyContext();\n    MessageQueueView messageQueueView = this.topicRouteService.getCurrentMessageQueueView(ctx, TOPIC);\n    assertEquals(3, messageQueueView.getReadSelector().getQueues().size());\n    assertEquals(2, messageQueueView.getWriteSelector().getQueues().size());\n    assertEquals(1, messageQueueView.getReadSelector().getBrokerActingQueues().size());\n    assertEquals(1, messageQueueView.getWriteSelector().getBrokerActingQueues().size());\n\n    assertEquals(LOCAL_ADDR, messageQueueView.getReadSelector().selectOne(true).getBrokerAddr());\n    assertEquals(LOCAL_BROKER_NAME, messageQueueView.getReadSelector().selectOne(true).getBrokerName());\n    assertEquals(messageQueueView.getReadSelector().selectOne(true), messageQueueView.getWriteSelector().selectOne(true));\n}\n",
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    ProxyContext ctx = new ProxyContext();\n    this.topicConfigTable.put(TOPIC, new TopicConfig(TOPIC, 3, 2, PermName.PERM_WRITE | PermName.PERM_READ));\n    MessageQueueView messageQueueView = this.topicRouteService.getCurrentMessageQueueView(ctx, TOPIC);\n    assertEquals(3, messageQueueView.getReadSelector().getQueues().size());\n    assertEquals(2, messageQueueView.getWriteSelector().getQueues().size());\n    assertEquals(1, messageQueueView.getReadSelector().getBrokerActingQueues().size());\n    assertEquals(1, messageQueueView.getWriteSelector().getBrokerActingQueues().size());\n\n    assertEquals(LOCAL_ADDR, messageQueueView.getReadSelector().selectOne(true).getBrokerAddr());\n    assertEquals(LOCAL_BROKER_NAME, messageQueueView.getReadSelector().selectOne(true).getBrokerName());\n    assertEquals(messageQueueView.getReadSelector().selectOne(true), messageQueueView.getWriteSelector().selectOne(true));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    this.topicConfigTable.put(TOPIC, new TopicConfig(TOPIC, 3, 2, PermName.PERM_WRITE | PermName.PERM_READ));\n    ProxyContext ctx = new ProxyContext();\n    MessageQueueView messageQueueView = this.topicRouteService.getCurrentMessageQueueView(ctx, TOPIC);\n    assertEquals(3, messageQueueView.getReadSelector().getQueues().size());\n    assertEquals(2, messageQueueView.getWriteSelector().getQueues().size());\n    assertEquals(1, messageQueueView.getReadSelector().getBrokerActingQueues().size());\n    assertEquals(1, messageQueueView.getWriteSelector().getBrokerActingQueues().size());\n\n    assertEquals(LOCAL_ADDR, messageQueueView.getReadSelector().selectOne(true).getBrokerAddr());\n    assertEquals(LOCAL_BROKER_NAME, messageQueueView.getReadSelector().selectOne(true).getBrokerName());\n    assertEquals(messageQueueView.getReadSelector().selectOne(true), messageQueueView.getWriteSelector().selectOne(true));\n}\n",
      "@Test\npublic void testGetCurrentMessageQueueView() throws Throwable {\n    ProxyContext ctx = new ProxyContext();\n    this.topicConfigTable.put(TOPIC, new TopicConfig(TOPIC, 3, 2, PermName.PERM_WRITE | PermName.PERM_READ));\n    MessageQueueView messageQueueView = this.topicRouteService.getCurrentMessageQueueView(ctx, TOPIC);\n    assertEquals(3, messageQueueView.getReadSelector().getQueues().size());\n    assertEquals(2, messageQueueView.getWriteSelector().getQueues().size());\n    assertEquals(1, messageQueueView.getReadSelector().getBrokerActingQueues().size());\n    assertEquals(1, messageQueueView.getWriteSelector().getBrokerActingQueues().size());\n\n    assertEquals(LOCAL_ADDR, messageQueueView.getReadSelector().selectOne(true).getBrokerAddr());\n    assertEquals(LOCAL_BROKER_NAME, messageQueueView.getReadSelector().selectOne(true).getBrokerName());\n    assertEquals(messageQueueView.getReadSelector().selectOne(true), messageQueueView.getWriteSelector().selectOne(true));\n}\n"
    ]
  },
  "49": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetTopicRouteForProxy",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetTopicRouteForProxy"
    ],
    "test_src_code": "    @Test\n    public void testGetTopicRouteForProxy() throws Throwable {\n        ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(new ArrayList<>(), TOPIC);\n\n        assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n        assertEquals(\n            Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\n                HostAndPort.fromString(BROKER_ADDR).getHost(),\n                ConfigurationManager.getProxyConfig().getGrpcServerPort()))),\n            proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteService.java#getTopicRouteForProxy"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteService.java#getTopicRouteForProxy"
    ],
    "focal_src": [
      "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        MessageQueueView messageQueueView = getAllMessageQueueView(topicName);\n        TopicRouteData topicRouteData = messageQueueView.getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                String brokerAddr = brokerData.getBrokerAddrs().get(brokerId);\n                HostAndPort brokerHostAndPort = HostAndPort.fromString(brokerAddr);\n                HostAndPort grpcHostAndPort = HostAndPort.fromParts(brokerHostAndPort.getHost(), grpcPort);\n\n                proxyBrokerData.getBrokerAddrs().put(brokerId, Lists.newArrayList(new Address(Address.AddressScheme.IPv4, grpcHostAndPort)));\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(ProxyContext ctx, List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        MessageQueueView messageQueueView = getAllMessageQueueView(ctx, topicName);\n        TopicRouteData topicRouteData = messageQueueView.getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                String brokerAddr = brokerData.getBrokerAddrs().get(brokerId);\n                HostAndPort brokerHostAndPort = HostAndPort.fromString(brokerAddr);\n                HostAndPort grpcHostAndPort = HostAndPort.fromParts(brokerHostAndPort.getHost(), grpcPort);\n\n                proxyBrokerData.getBrokerAddrs().put(brokerId, Lists.newArrayList(new Address(Address.AddressScheme.IPv4, grpcHostAndPort)));\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n"
    ],
    "test_id": 49,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetTopicRouteForProxy() throws Throwable {\n    ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(new ProxyContext(), new ArrayList<>(), TOPIC);\n\n    assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n    assertEquals(\n        Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\n            HostAndPort.fromString(BROKER_ADDR).getHost(),\n            ConfigurationManager.getProxyConfig().getGrpcServerPort()))),\n        proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n}\n",
      "@Test\npublic void testGetTopicRouteForProxy() throws Throwable {\n    ProxyContext ctx = new ProxyContext();\n    ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(ctx, new ArrayList<>(), TOPIC);\n\n    assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n    assertEquals(\n        Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\n            HostAndPort.fromString(BROKER_ADDR).getHost(),\n            ConfigurationManager.getProxyConfig().getGrpcServerPort()))),\n        proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testGetTopicRouteForProxy() throws Throwable {\n    ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(new ArrayList<>(), TOPIC);\n\n    assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n    assertEquals(\n        Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\n            HostAndPort.fromString(BROKER_ADDR).getHost(),\n            ConfigurationManager.getProxyConfig().getGrpcServerPort()))),\n        proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n}\n"
    ]
  },
  "50": {
    "commit_src": "737c1e53383350a5671fa207ee0e4ce932850bac",
    "commit_tgt": "7996ec3b3f7ccea01f66951ac639b48303bbf7a6",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtilsTest.java"
    ],
    "refer_PR": "apache_rocketmq-6883",
    "test_src": ".org.apache.rocketmq.common.utils.ConcurrentHashMapUtilsTest#computeIfAbsent",
    "test_tgt": [
      ".org.apache.rocketmq.common.utils.ConcurrentHashMapUtilsTest#computeIfAbsent"
    ],
    "test_src_code": "    @Test\n    public void computeIfAbsent() {\n\n        ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n        map.put(\"123\", \"1111\");\n        String value = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"234\");\n        assertEquals(\"1111\", value);\n        String value1 = ConcurrentHashMapUtils.computeIfAbsent(map, \"1232\", k -> \"2342\");\n        assertEquals(\"2342\", value1);\n        String value2 = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"2342\");\n        assertEquals(\"1111\", value2);\n    }\n",
    "focal_path_src": [
      "common/src/main/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtils.java#computeIfAbsent"
    ],
    "focal_path_tgt": [
      "common/src/main/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtils.java#computeIfAbsent"
    ],
    "focal_src": [
      "    /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br> Use implementation of\n     * ConcurrentMap.computeIfAbsent instead.\n     *\n     * @see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\n    public static <K, V> V computeIfAbsent(ConcurrentMap<K, V> map, K key, Function<? super K, ? extends V> func) {\n        if (isJdk8) {\n            V v = map.get(key);\n            if (null == v) {\n                v = map.computeIfAbsent(key, func);\n            }\n            return v;\n        } else {\n            return map.computeIfAbsent(key, func);\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br> Use implementation of\n     * ConcurrentMap.computeIfAbsent instead.\n     *\n     * @see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\n    public static <K, V> V computeIfAbsent(ConcurrentMap<K, V> map, K key, Function<? super K, ? extends V> func) {\n        Objects.requireNonNull(func);\n        if (isJdk8) {\n            V v = map.get(key);\n            if (null == v) {\n//                v = map.computeIfAbsent(key, func);\n\n                // this bug fix methods maybe cause `func.apply` multiple calls.\n                v = func.apply(key);\n                if (null == v) {\n                    return null;\n                }\n                final V res = map.putIfAbsent(key, v);\n                if (null != res) {\n                    // if pre value present, means other thread put value already, and putIfAbsent not effect\n                    // return exist value\n                    return res;\n                }\n            }\n            return v;\n        } else {\n            return map.computeIfAbsent(key, func);\n        }\n    }\n"
    ],
    "test_id": 50,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void computeIfAbsent() {\n\n    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n    map.put(\"123\", \"1111\");\n\n    // Updated test code to test the updated version of the production code\n    String value = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"234\");\n    assertEquals(\"1111\", value);\n\n    // Test code should also check if the method behaves as expected with different keys and lambda expressions.\n    String value1 = ConcurrentHashMapUtils.computeIfAbsent(map, \"1232\", k -> \"2342\");\n    assertEquals(\"2342\", value1);\n\n    // This test should fail because the key \"123\" already has a value\n    String value2 = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"2342\");\n    assertEquals(\"1111\", value2);\n}\n",
      "@Test\npublic void computeIfAbsent() {\n\n    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n    map.put(\"123\", \"1111\");\n    String value = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"234\");\n    assertEquals(\"1111\", value);\n    String value1 = ConcurrentHashMapUtils.computeIfAbsent(map, \"1232\", k -> \"2342\");\n    assertEquals(\"2342\", value1);\n    String value2 = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"2342\");\n    assertEquals(\"1111\", value2);\n}\n",
      "@Test\npublic void computeIfAbsent() {\n\n    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n    map.put(\"123\", \"1111\");\n\n    String value = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> {\n        System.out.println(\"Computing value for \" + k);\n        return \"234\";\n    });\n    assertEquals(\"1111\", value);\n\n    String value1 = ConcurrentHashMapUtils.computeIfAbsent(map, \"1232\", k -> {\n        System.out.println(\"Computing value for \" + k);\n        return \"2342\";\n    });\n    assertEquals(\"2342\", value1);\n\n    String value2 = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> {\n        System.out.println(\"Computing value for \" + k);\n        return \"2342\";\n    });\n    assertEquals(\"1111\", value2);\n}\n",
      "@Test\npublic void computeIfAbsent() {\n\n    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n    map.put(\"123\", \"1111\");\n    String value = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"234\");\n    assertEquals(\"1111\", value);\n    String value1 = ConcurrentHashMapUtils.computeIfAbsent(map, \"1232\", k -> \"2342\");\n    assertEquals(\"2342\", value1);\n    String value2 = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"2342\");\n    assertEquals(\"1111\", value2);\n}\n",
      "@Test\npublic void computeIfAbsent() {\n\n    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n    map.put(\"123\", \"1111\");\n    String value = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"234\");\n    assertEquals(\"1111\", value);\n    String value1 = ConcurrentHashMapUtils.computeIfAbsent(map, \"1232\", k -> \"2342\");\n    assertEquals(\"2342\", value1);\n    String value2 = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"2342\");\n    assertEquals(\"1111\", value2);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void computeIfAbsent() {\n\n    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n    map.put(\"123\", \"1111\");\n    String value = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"234\");\n    assertEquals(\"1111\", value);\n    String value1 = ConcurrentHashMapUtils.computeIfAbsent(map, \"1232\", k -> \"2342\");\n    assertEquals(\"2342\", value1);\n    String value2 = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"2342\");\n    assertEquals(\"1111\", value2);\n}\n"
    ]
  },
  "51": {
    "commit_src": "3dda55e812240ee5bb667d078fb49acc13f0ccb4",
    "commit_tgt": "aea5811df007c2abf2d46eea931e4c867514e0eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6885",
    "test_src": ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncGrpcV2Channel",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncGrpcV2Channel"
    ],
    "test_src_code": "    @Test\n    public void testSyncGrpcV2Channel() throws Exception {\n        String consumerGroup = \"consumerGroup\";\n        GrpcClientSettingsManager grpcClientSettingsManager = mock(GrpcClientSettingsManager.class);\n        GrpcChannelManager grpcChannelManager = mock(GrpcChannelManager.class);\n        GrpcClientChannel grpcClientChannel = new GrpcClientChannel(\n            proxyRelayService, grpcClientSettingsManager, grpcChannelManager,\n            ProxyContext.create().setRemoteAddress(remoteAddress).setLocalAddress(localAddress),\n            clientId);\n        ClientChannelInfo clientChannelInfo = new ClientChannelInfo(\n            grpcClientChannel,\n            clientId,\n            LanguageCode.JAVA,\n            5\n        );\n\n        ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n        SendResult sendResult = new SendResult();\n        sendResult.setSendStatus(SendStatus.SEND_OK);\n        doReturn(CompletableFuture.completedFuture(sendResult)).when(this.mqClientAPIExt)\n            .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n\n        Settings settings = Settings.newBuilder()\n            .setSubscription(Subscription.newBuilder()\n                .addSubscriptions(SubscriptionEntry.newBuilder()\n                    .setTopic(Resource.newBuilder().setName(\"topic\").build())\n                    .setExpression(FilterExpression.newBuilder()\n                        .setType(FilterType.TAG)\n                        .setExpression(\"tag\")\n                        .build())\n                    .build())\n                .build())\n            .build();\n        when(grpcClientSettingsManager.getRawClientSettings(eq(clientId))).thenReturn(settings);\n\n        HeartbeatSyncer heartbeatSyncer = new HeartbeatSyncer(topicRouteService, adminService, consumerManager, mqClientAPIFactory);\n        heartbeatSyncer.onConsumerRegister(\n            consumerGroup,\n            clientChannelInfo,\n            ConsumeType.CONSUME_PASSIVELY,\n            MessageModel.CLUSTERING,\n            ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n            Sets.newHashSet(FilterAPI.buildSubscriptionData(\"topic\", \"tag\"))\n        );\n\n        await().atMost(Duration.ofSeconds(3)).until(() -> !messageArgumentCaptor.getAllValues().isEmpty());\n        heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n        verify(consumerManager, never()).registerConsumer(anyString(), any(), any(), any(), any(), any(), anyBoolean());\n\n        String localServeAddr = ConfigurationManager.getProxyConfig().getLocalServeAddr();\n        // change local serve addr, to simulate other proxy receive messages\n        heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n        ArgumentCaptor<ClientChannelInfo> syncChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n        doReturn(true).when(consumerManager).registerConsumer(anyString(), syncChannelInfoArgumentCaptor.capture(), any(), any(), any(), any(), anyBoolean());\n\n        heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n        heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n        assertEquals(2, syncChannelInfoArgumentCaptor.getAllValues().size());\n        List<ClientChannelInfo> channelInfoList = syncChannelInfoArgumentCaptor.getAllValues();\n        assertSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n        assertEquals(settings, GrpcClientChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n        assertEquals(settings, GrpcClientChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n\n        // start test sync client unregister\n        // reset localServeAddr\n        ConfigurationManager.getProxyConfig().setLocalServeAddr(localServeAddr);\n        heartbeatSyncer.onConsumerUnRegister(consumerGroup, clientChannelInfo);\n        await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n\n        ArgumentCaptor<ClientChannelInfo> syncUnRegisterChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n        doNothing().when(consumerManager).unregisterConsumer(anyString(), syncUnRegisterChannelInfoArgumentCaptor.capture(), anyBoolean());\n\n        // change local serve addr, to simulate other proxy receive messages\n        heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n        heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getAllValues().get(1))), null);\n        assertSame(channelInfoList.get(0).getChannel(), syncUnRegisterChannelInfoArgumentCaptor.getValue().getChannel());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncer.java#HeartbeatSyncer"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncer.java#HeartbeatSyncer"
    ],
    "focal_src": [
      "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n        ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory) {\n        super(topicRouteService, adminService, mqClientAPIFactory);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n"
    ],
    "focal_tgt": [
      "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n                           ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory, RPCHook rpcHook) {\n        super(topicRouteService, adminService, mqClientAPIFactory, rpcHook);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n"
    ],
    "test_id": 51,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testSyncGrpcV2Channel() throws Exception {\n    String consumerGroup = \"consumerGroup\";\n    GrpcClientSettingsManager grpcClientSettingsManager = mock(GrpcClientSettingsManager.class);\n    GrpcChannelManager grpcChannelManager = mock(GrpcChannelManager.class);\n    GrpcClientChannel grpcClientChannel = new GrpcClientChannel(\n        proxyRelayService, grpcClientSettingsManager, grpcChannelManager,\n        ProxyContext.create().setRemoteAddress(remoteAddress).setLocalAddress(localAddress),\n        clientId);\n    ClientChannelInfo clientChannelInfo = new ClientChannelInfo(\n        grpcClientChannel,\n        clientId,\n        LanguageCode.JAVA,\n        5\n    );\n\n    ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n    SendResult sendResult = new SendResult();\n    sendResult.setSendStatus(SendStatus.SEND_OK);\n    doReturn(CompletableFuture.completedFuture(sendResult)).when(this.mqClientAPIExt)\n        .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n\n    Settings settings = Settings.newBuilder()\n        .setSubscription(Subscription.newBuilder()\n            .addSubscriptions(SubscriptionEntry.newBuilder()\n                .setTopic(Resource.newBuilder().setName(\"topic\").build())\n                .setExpression(FilterExpression.newBuilder()\n                    .setType(FilterType.TAG)\n                    .setExpression(\"tag\")\n                    .build())\n                .build())\n            .build())\n        .build();\n    when(grpcClientSettingsManager.getRawClientSettings(eq(clientId))).thenReturn(settings);\n\n    HeartbeatSyncer heartbeatSyncer = new HeartbeatSyncer(topicRouteService, adminService, consumerManager, mqClientAPIFactory);\n    heartbeatSyncer.onConsumerRegister(\n        consumerGroup,\n        clientChannelInfo,\n        ConsumeType.CONSUME_PASSIVELY,\n        MessageModel.CLUSTERING,\n        ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n        Sets.newHashSet(FilterAPI.buildSubscriptionData(\"topic\", \"tag\"))\n    );\n\n    await().atMost(Duration.ofSeconds(3)).until(() -> !messageArgumentCaptor.getAllValues().isEmpty());\n    heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n    verify(consumerManager, never()).registerConsumer(anyString(), any(), any(), any(), any(), any(), anyBoolean());\n\n    String localServeAddr = ConfigurationManager.getProxyConfig().getLocalServeAddr();\n    // change local serve addr, to simulate other proxy receive messages\n    heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n    ArgumentCaptor<ClientChannelInfo> syncChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n    doReturn(true).when(consumerManager).registerConsumer(anyString(), syncChannelInfoArgumentCaptor.capture(), any(), any(), any(), any(), anyBoolean());\n\n    heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n    heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n    assertEquals(2, syncChannelInfoArgumentCaptor.getAllValues().size());\n    List<ClientChannelInfo> channelInfoList = syncChannelInfoArgumentCaptor.getAllValues();\n    assertSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n    assertEquals(settings, GrpcClientChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n    assertEquals(settings, GrpcClientChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n\n    // start test sync client unregister\n    // reset localServeAddr\n    ConfigurationManager.getProxyConfig().setLocalServeAddr(localServeAddr);\n    heartbeatSyncer.onConsumerUnRegister(consumerGroup, clientChannelInfo);\n    await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n\n    ArgumentCaptor<ClientChannelInfo> syncUnRegisterChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n    doNothing().when(consumerManager).unregisterConsumer(anyString(), syncUnRegisterChannelInfoArgumentCaptor.capture(), anyBoolean());\n\n    // change local serve addr, to simulate other proxy receive messages\n    heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n    heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getAllValues().get(1))), null);\n    assertSame(channelInfoList.get(0).getChannel(), syncUnRegisterChannelInfoArgumentCaptor.getValue().getChannel());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testSyncGrpcV2Channel() throws Exception {\n    String consumerGroup = \"consumerGroup\";\n    GrpcClientSettingsManager grpcClientSettingsManager = mock(GrpcClientSettingsManager.class);\n    GrpcChannelManager grpcChannelManager = mock(GrpcChannelManager.class);\n    GrpcClientChannel grpcClientChannel = new GrpcClientChannel(\n        proxyRelayService, grpcClientSettingsManager, grpcChannelManager,\n        ProxyContext.create().setRemoteAddress(remoteAddress).setLocalAddress(localAddress),\n        clientId);\n    ClientChannelInfo clientChannelInfo = new ClientChannelInfo(\n        grpcClientChannel,\n        clientId,\n        LanguageCode.JAVA,\n        5\n    );\n\n    ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n    SendResult sendResult = new SendResult();\n    sendResult.setSendStatus(SendStatus.SEND_OK);\n    doReturn(CompletableFuture.completedFuture(sendResult)).when(this.mqClientAPIExt)\n        .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n\n    Settings settings = Settings.newBuilder()\n        .setSubscription(Subscription.newBuilder()\n            .addSubscriptions(SubscriptionEntry.newBuilder()\n                .setTopic(Resource.newBuilder().setName(\"topic\").build())\n                .setExpression(FilterExpression.newBuilder()\n                    .setType(FilterType.TAG)\n                    .setExpression(\"tag\")\n                    .build())\n                .build())\n            .build())\n        .build();\n    when(grpcClientSettingsManager.getRawClientSettings(eq(clientId))).thenReturn(settings);\n\n    HeartbeatSyncer heartbeatSyncer = new HeartbeatSyncer(topicRouteService, adminService, consumerManager, mqClientAPIFactory);\n    heartbeatSyncer.onConsumerRegister(\n        consumerGroup,\n        clientChannelInfo,\n        ConsumeType.CONSUME_PASSIVELY,\n        MessageModel.CLUSTERING,\n        ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n        Sets.newHashSet(FilterAPI.buildSubscriptionData(\"topic\", \"tag\"))\n    );\n\n    await().atMost(Duration.ofSeconds(3)).until(() -> !messageArgumentCaptor.getAllValues().isEmpty());\n    heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n    verify(consumerManager, never()).registerConsumer(anyString(), any(), any(), any(), any(), any(), anyBoolean());\n\n    String localServeAddr = ConfigurationManager.getProxyConfig().getLocalServeAddr();\n    // change local serve addr, to simulate other proxy receive messages\n    heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n    ArgumentCaptor<ClientChannelInfo> syncChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n    doReturn(true).when(consumerManager).registerConsumer(anyString(), syncChannelInfoArgumentCaptor.capture(), any(), any(), any(), any(), anyBoolean());\n\n    heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n    heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n    assertEquals(2, syncChannelInfoArgumentCaptor.getAllValues().size());\n    List<ClientChannelInfo> channelInfoList = syncChannelInfoArgumentCaptor.getAllValues();\n    assertSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n    assertEquals(settings, GrpcClientChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n    assertEquals(settings, GrpcClientChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n\n    // start test sync client unregister\n    // reset localServeAddr\n    ConfigurationManager.getProxyConfig().setLocalServeAddr(localServeAddr);\n    heartbeatSyncer.onConsumerUnRegister(consumerGroup, clientChannelInfo);\n    await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n\n    ArgumentCaptor<ClientChannelInfo> syncUnRegisterChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n    doNothing().when(consumerManager).unregisterConsumer(anyString(), syncUnRegisterChannelInfoArgumentCaptor.capture(), anyBoolean());\n\n    // change local serve addr, to simulate other proxy receive messages\n    heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n    heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getAllValues().get(1))), null);\n    assertSame(channelInfoList.get(0).getChannel(), syncUnRegisterChannelInfoArgumentCaptor.getValue().getChannel());\n}\n"
    ]
  },
  "52": {
    "commit_src": "3dda55e812240ee5bb667d078fb49acc13f0ccb4",
    "commit_tgt": "aea5811df007c2abf2d46eea931e4c867514e0eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6885",
    "test_src": ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncRemotingChannel",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncRemotingChannel"
    ],
    "test_src_code": "    @Test\n    public void testSyncRemotingChannel() throws Exception {\n        String consumerGroup = \"consumerGroup\";\n        String consumerGroup2 = \"consumerGroup2\";\n        Channel channel = createMockChannel();\n        Set<SubscriptionData> subscriptionDataSet = new HashSet<>();\n        subscriptionDataSet.add(FilterAPI.buildSubscriptionData(\"topic\", \"tagSub\"));\n        Set<SubscriptionData> subscriptionDataSet2 = new HashSet<>();\n        subscriptionDataSet2.add(FilterAPI.buildSubscriptionData(\"topic2\", \"tagSub2\"));\n        RemotingProxyOutClient remotingProxyOutClient = mock(RemotingProxyOutClient.class);\n        RemotingChannel remotingChannel = new RemotingChannel(remotingProxyOutClient, proxyRelayService, channel, clientId, subscriptionDataSet);\n        ClientChannelInfo clientChannelInfo = new ClientChannelInfo(\n            remotingChannel,\n            clientId,\n            LanguageCode.JAVA,\n            4\n        );\n        RemotingChannel remotingChannel2 = new RemotingChannel(remotingProxyOutClient, proxyRelayService, channel, clientId, subscriptionDataSet2);\n        ClientChannelInfo clientChannelInfo2 = new ClientChannelInfo(\n            remotingChannel2,\n            clientId,\n            LanguageCode.JAVA,\n            4\n        );\n\n        HeartbeatSyncer heartbeatSyncer = new HeartbeatSyncer(topicRouteService, adminService, consumerManager, mqClientAPIFactory);\n        SendResult okSendResult = new SendResult();\n        okSendResult.setSendStatus(SendStatus.SEND_OK);\n        {\n            ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n            doReturn(CompletableFuture.completedFuture(okSendResult)).when(this.mqClientAPIExt)\n                .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n\n            heartbeatSyncer.onConsumerRegister(\n                consumerGroup,\n                clientChannelInfo,\n                ConsumeType.CONSUME_PASSIVELY,\n                MessageModel.CLUSTERING,\n                ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n                subscriptionDataSet\n            );\n            heartbeatSyncer.onConsumerRegister(\n                consumerGroup2,\n                clientChannelInfo2,\n                ConsumeType.CONSUME_PASSIVELY,\n                MessageModel.CLUSTERING,\n                ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n                subscriptionDataSet2\n            );\n\n            await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n            heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n            verify(consumerManager, never()).registerConsumer(anyString(), any(), any(), any(), any(), any(), anyBoolean());\n\n            // change local serve addr, to simulate other proxy receive messages\n            heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n            ArgumentCaptor<ClientChannelInfo> syncChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n            doReturn(true).when(consumerManager).registerConsumer(anyString(), syncChannelInfoArgumentCaptor.capture(), any(), any(), any(), any(), anyBoolean());\n\n            heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n            heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n            /*\n            data in syncChannelInfoArgumentCaptor will be like:\n            1st, data of group1\n            2nd, data of group2\n            3rd, data of group1\n            4th, data of group2\n             */\n            assertEquals(4, syncChannelInfoArgumentCaptor.getAllValues().size());\n            List<ClientChannelInfo> channelInfoList = syncChannelInfoArgumentCaptor.getAllValues();\n            assertSame(channelInfoList.get(0).getChannel(), channelInfoList.get(2).getChannel());\n            assertNotSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n            Set<Set<SubscriptionData>> checkSubscriptionDatas = new HashSet<>();\n            checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n            checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n            assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet));\n            assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet2));\n        }\n\n        {\n            // start test sync client unregister\n            // reset localServeAddr\n            ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n            doReturn(CompletableFuture.completedFuture(okSendResult)).when(this.mqClientAPIExt)\n                .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n            heartbeatSyncer.onConsumerUnRegister(consumerGroup, clientChannelInfo);\n            heartbeatSyncer.onConsumerUnRegister(consumerGroup2, clientChannelInfo2);\n            await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n\n            ArgumentCaptor<ClientChannelInfo> syncUnRegisterChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n            doNothing().when(consumerManager).unregisterConsumer(anyString(), syncUnRegisterChannelInfoArgumentCaptor.capture(), anyBoolean());\n\n            // change local serve addr, to simulate other proxy receive messages\n            heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n            heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n            List<ClientChannelInfo> channelInfoList = syncUnRegisterChannelInfoArgumentCaptor.getAllValues();\n            assertNotSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n            Set<Set<SubscriptionData>> checkSubscriptionDatas = new HashSet<>();\n            checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n            checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n            assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet));\n            assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet2));\n        }\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncer.java#HeartbeatSyncer"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncer.java#HeartbeatSyncer"
    ],
    "focal_src": [
      "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n        ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory) {\n        super(topicRouteService, adminService, mqClientAPIFactory);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n"
    ],
    "focal_tgt": [
      "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n                           ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory, RPCHook rpcHook) {\n        super(topicRouteService, adminService, mqClientAPIFactory, rpcHook);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n"
    ],
    "test_id": 52,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testSyncRemotingChannel() throws Exception {\n    String consumerGroup = \"consumerGroup\";\n    String consumerGroup2 = \"consumerGroup2\";\n    Channel channel = createMockChannel();\n    Set<SubscriptionData> subscriptionDataSet = new HashSet<>();\n    subscriptionDataSet.add(FilterAPI.buildSubscriptionData(\"topic\", \"tagSub\"));\n    Set<SubscriptionData> subscriptionDataSet2 = new HashSet<>();\n    subscriptionDataSet2.add(FilterAPI.buildSubscriptionData(\"topic2\", \"tagSub2\"));\n    RemotingProxyOutClient remotingProxyOutClient = mock(RemotingProxyOutClient.class);\n    RemotingChannel remotingChannel = new RemotingChannel(remotingProxyOutClient, proxyRelayService, channel, clientId, subscriptionDataSet);\n    ClientChannelInfo clientChannelInfo = new ClientChannelInfo(\n        remotingChannel,\n        clientId,\n        LanguageCode.JAVA,\n        4\n    );\n    RemotingChannel remotingChannel2 = new RemotingChannel(remotingProxyOutClient, proxyRelayService, channel, clientId, subscriptionDataSet2);\n    ClientChannelInfo clientChannelInfo2 = new ClientChannelInfo(\n        remotingChannel2,\n        clientId,\n        LanguageCode.JAVA,\n        4\n    );\n\n    HeartbeatSyncer heartbeatSyncer = new HeartbeatSyncer(topicRouteService, adminService, consumerManager, mqClientAPIFactory);\n    SendResult okSendResult = new SendResult();\n    okSendResult.setSendStatus(SendStatus.SEND_OK);\n    {\n        ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n        doReturn(CompletableFuture.completedFuture(okSendResult)).when(this.mqClientAPIExt)\n            .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n\n        heartbeatSyncer.onConsumerRegister(\n            consumerGroup,\n            clientChannelInfo,\n            ConsumeType.CONSUME_PASSIVELY,\n            MessageModel.CLUSTERING,\n            ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n            subscriptionDataSet\n        );\n        heartbeatSyncer.onConsumerRegister(\n            consumerGroup2,\n            clientChannelInfo2,\n            ConsumeType.CONSUME_PASSIVELY,\n            MessageModel.CLUSTERING,\n            ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n            subscriptionDataSet2\n        );\n\n        await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n        heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n        verify(consumerManager, never()).registerConsumer(anyString(), any(), any(), any(), any(), any(), anyBoolean());\n\n        // change local serve addr, to simulate other proxy receive messages\n        heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n        ArgumentCaptor<ClientChannelInfo> syncChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n        doReturn(true).when(consumerManager).registerConsumer(anyString(), syncChannelInfoArgumentCaptor.capture(), any(), any(), any(), any(), anyBoolean());\n\n        heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n        heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n        /*\n        data in syncChannelInfoArgumentCaptor will be like:\n        1st, data of group1\n        2nd, data of group2\n        3rd, data of group1\n        4th, data of group2\n         */\n        assertEquals(4, syncChannelInfoArgumentCaptor.getAllValues().size());\n        List<ClientChannelInfo> channelInfoList = syncChannelInfoArgumentCaptor.getAllValues();\n        assertSame(channelInfoList.get(0).getChannel(), channelInfoList.get(2).getChannel());\n        assertNotSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n        Set<Set<SubscriptionData>> checkSubscriptionDatas = new HashSet<>();\n        checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n        checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n        assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet));\n        assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet2));\n    }\n\n    {\n        // start test sync client unregister\n        // reset localServeAddr\n        ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n        doReturn(CompletableFuture.completedFuture(okSendResult)).when(this.mqClientAPIExt)\n            .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n        heartbeatSyncer.onConsumerUnRegister(consumerGroup, clientChannelInfo);\n        heartbeatSyncer.onConsumerUnRegister(consumerGroup2, clientChannelInfo2);\n        await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n\n        ArgumentCaptor<ClientChannelInfo> syncUnRegisterChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n        doNothing().when(consumerManager).unregisterConsumer(anyString(), syncUnRegisterChannelInfoArgumentCaptor.capture(), anyBoolean());\n\n        // change local serve addr, to simulate other proxy receive messages\n        heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n        heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n        List<ClientChannelInfo> channelInfoList = syncUnRegisterChannelInfoArgumentCaptor.getAllValues();\n        assertNotSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n        Set<Set<SubscriptionData>> checkSubscriptionDatas = new HashSet<>();\n        checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n        checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n        assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet));\n        assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet2));\n    }\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testSyncRemotingChannel() throws Exception {\n    String consumerGroup = \"consumerGroup\";\n    String consumerGroup2 = \"consumerGroup2\";\n    Channel channel = createMockChannel();\n    Set<SubscriptionData> subscriptionDataSet = new HashSet<>();\n    subscriptionDataSet.add(FilterAPI.buildSubscriptionData(\"topic\", \"tagSub\"));\n    Set<SubscriptionData> subscriptionDataSet2 = new HashSet<>();\n    subscriptionDataSet2.add(FilterAPI.buildSubscriptionData(\"topic2\", \"tagSub2\"));\n    RemotingProxyOutClient remotingProxyOutClient = mock(RemotingProxyOutClient.class);\n    RemotingChannel remotingChannel = new RemotingChannel(remotingProxyOutClient, proxyRelayService, channel, clientId, subscriptionDataSet);\n    ClientChannelInfo clientChannelInfo = new ClientChannelInfo(\n        remotingChannel,\n        clientId,\n        LanguageCode.JAVA,\n        4\n    );\n    RemotingChannel remotingChannel2 = new RemotingChannel(remotingProxyOutClient, proxyRelayService, channel, clientId, subscriptionDataSet2);\n    ClientChannelInfo clientChannelInfo2 = new ClientChannelInfo(\n        remotingChannel2,\n        clientId,\n        LanguageCode.JAVA,\n        4\n    );\n\n    HeartbeatSyncer heartbeatSyncer = new HeartbeatSyncer(topicRouteService, adminService, consumerManager, mqClientAPIFactory);\n    SendResult okSendResult = new SendResult();\n    okSendResult.setSendStatus(SendStatus.SEND_OK);\n    {\n        ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n        doReturn(CompletableFuture.completedFuture(okSendResult)).when(this.mqClientAPIExt)\n            .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n\n        heartbeatSyncer.onConsumerRegister(\n            consumerGroup,\n            clientChannelInfo,\n            ConsumeType.CONSUME_PASSIVELY,\n            MessageModel.CLUSTERING,\n            ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n            subscriptionDataSet\n        );\n        heartbeatSyncer.onConsumerRegister(\n            consumerGroup2,\n            clientChannelInfo2,\n            ConsumeType.CONSUME_PASSIVELY,\n            MessageModel.CLUSTERING,\n            ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n            subscriptionDataSet2\n        );\n\n        await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n        heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n        verify(consumerManager, never()).registerConsumer(anyString(), any(), any(), any(), any(), any(), anyBoolean());\n\n        // change local serve addr, to simulate other proxy receive messages\n        heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n        ArgumentCaptor<ClientChannelInfo> syncChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n        doReturn(true).when(consumerManager).registerConsumer(anyString(), syncChannelInfoArgumentCaptor.capture(), any(), any(), any(), any(), anyBoolean());\n\n        heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n        heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n        /*\n        data in syncChannelInfoArgumentCaptor will be like:\n        1st, data of group1\n        2nd, data of group2\n        3rd, data of group1\n        4th, data of group2\n         */\n        assertEquals(4, syncChannelInfoArgumentCaptor.getAllValues().size());\n        List<ClientChannelInfo> channelInfoList = syncChannelInfoArgumentCaptor.getAllValues();\n        assertSame(channelInfoList.get(0).getChannel(), channelInfoList.get(2).getChannel());\n        assertNotSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n        Set<Set<SubscriptionData>> checkSubscriptionDatas = new HashSet<>();\n        checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n        checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n        assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet));\n        assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet2));\n    }\n\n    {\n        // start test sync client unregister\n        // reset localServeAddr\n        ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n        doReturn(CompletableFuture.completedFuture(okSendResult)).when(this.mqClientAPIExt)\n            .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n        heartbeatSyncer.onConsumerUnRegister(consumerGroup, clientChannelInfo);\n        heartbeatSyncer.onConsumerUnRegister(consumerGroup2, clientChannelInfo2);\n        await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n\n        ArgumentCaptor<ClientChannelInfo> syncUnRegisterChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n        doNothing().when(consumerManager).unregisterConsumer(anyString(), syncUnRegisterChannelInfoArgumentCaptor.capture(), anyBoolean());\n\n        // change local serve addr, to simulate other proxy receive messages\n        heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n        heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n        List<ClientChannelInfo> channelInfoList = syncUnRegisterChannelInfoArgumentCaptor.getAllValues();\n        assertNotSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n        Set<Set<SubscriptionData>> checkSubscriptionDatas = new HashSet<>();\n        checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n        checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n        assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet));\n        assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet2));\n    }\n}\n"
    ]
  },
  "53": {
    "commit_src": "e369d7deac6e4dde950a8da7c3d976bb26d0e6b5",
    "commit_tgt": "16ef5755375e7c8f4fb11dd63f5fdfdfa25668e7",
    "changed_tests": [
      "client/src/test/java/org/apache/rocketmq/client/trace/TraceDataEncoderTest.java"
    ],
    "refer_PR": "apache_rocketmq-6941",
    "test_src": ".org.apache.rocketmq.client.trace.TraceDataEncoderTest#testSubAfterTraceDataFormatTest",
    "test_tgt": [
      ".org.apache.rocketmq.client.trace.TraceDataEncoderTest#testSubAfterTraceDataFormatTest"
    ],
    "test_src_code": "    @Test\n    public void testSubAfterTraceDataFormatTest() {\n        TraceContext subAfterContext = new TraceContext();\n        subAfterContext.setTraceType(TraceType.SubAfter);\n        subAfterContext.setRequestId(\"3455848576927\");\n        subAfterContext.setCostTime(20);\n        subAfterContext.setSuccess(true);\n        subAfterContext.setTimeStamp(1625883640000L);\n        subAfterContext.setGroupName(\"GroupName-test\");\n        subAfterContext.setContextCode(98623046);\n        TraceBean bean = new TraceBean();\n        bean.setMsgId(\"AC1415116D1418B4AAC217FE1B4E0000\");\n        bean.setKeys(\"keys\");\n        subAfterContext.setTraceBeans(new ArrayList<>(1));\n        subAfterContext.getTraceBeans().add(bean);\n\n        TraceTransferBean traceTransferBean = TraceDataEncoder.encoderFromContextBean(subAfterContext);\n        String transData = traceTransferBean.getTransData();\n        Assert.assertNotNull(transData);\n        String[] items = transData.split(String.valueOf(TraceConstants.CONTENT_SPLITOR));\n        Assert.assertEquals(9, items.length);\n\n    }\n",
    "focal_path_src": [
      "client/src/main/java/org/apache/rocketmq/client/trace/TraceDataEncoder.java#encoderFromContextBean"
    ],
    "focal_path_tgt": [
      "client/src/main/java/org/apache/rocketmq/client/trace/TraceDataEncoder.java#encoderFromContextBean"
    ],
    "focal_src": [
      "    /**\n     * Encoding the trace context into data strings and keyset sets\n     *\n     * @param ctx\n     * @return\n     */\n    public static TraceTransferBean encoderFromContextBean(TraceContext ctx) {\n        if (ctx == null) {\n            return null;\n        }\n        //build message trace of the transferring entity content bean\n        TraceTransferBean transferBean = new TraceTransferBean();\n        StringBuilder sb = new StringBuilder(256);\n        switch (ctx.getTraceType()) {\n            case Pub: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                //append the content of context and traceBean to transferBean's TransData\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getBodyLength()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getOffsetMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.isSuccess()).append(TraceConstants.FIELD_SPLITOR);//\n            }\n            break;\n            case SubBefore: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getRetryTimes()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.FIELD_SPLITOR);//\n                }\n            }\n            break;\n            case SubAfter: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.isSuccess()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getContextCode()).append(TraceConstants.CONTENT_SPLITOR)\n                        .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)\n                        .append(ctx.getGroupName()).append(TraceConstants.FIELD_SPLITOR);\n                }\n            }\n            break;\n            case EndTransaction: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionState().name()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.isFromTransactionCheck()).append(TraceConstants.FIELD_SPLITOR);\n            }\n            break;\n            default:\n        }\n        transferBean.setTransData(sb.toString());\n        for (TraceBean bean : ctx.getTraceBeans()) {\n\n            transferBean.getTransKey().add(bean.getMsgId());\n            if (bean.getKeys() != null && bean.getKeys().length() > 0) {\n                String[] keys = bean.getKeys().split(MessageConst.KEY_SEPARATOR);\n                transferBean.getTransKey().addAll(Arrays.asList(keys));\n            }\n        }\n        return transferBean;\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * Encoding the trace context into data strings and keyset sets\n     *\n     * @param ctx\n     * @return\n     */\n    public static TraceTransferBean encoderFromContextBean(TraceContext ctx) {\n        if (ctx == null) {\n            return null;\n        }\n        //build message trace of the transferring entity content bean\n        TraceTransferBean transferBean = new TraceTransferBean();\n        StringBuilder sb = new StringBuilder(256);\n        switch (ctx.getTraceType()) {\n            case Pub: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                //append the content of context and traceBean to transferBean's TransData\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getBodyLength()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getOffsetMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.isSuccess()).append(TraceConstants.FIELD_SPLITOR);//\n            }\n            break;\n            case SubBefore: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getRetryTimes()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.FIELD_SPLITOR);//\n                }\n            }\n            break;\n            case SubAfter: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.isSuccess()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getContextCode()).append(TraceConstants.CONTENT_SPLITOR);\n                    if (!ctx.getAccessChannel().equals(AccessChannel.CLOUD)) {\n                        sb.append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)\n                            .append(ctx.getGroupName()).append(TraceConstants.FIELD_SPLITOR);\n                    }\n                }\n            }\n            break;\n            case EndTransaction: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionState().name()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.isFromTransactionCheck()).append(TraceConstants.FIELD_SPLITOR);\n            }\n            break;\n            default:\n        }\n        transferBean.setTransData(sb.toString());\n        for (TraceBean bean : ctx.getTraceBeans()) {\n\n            transferBean.getTransKey().add(bean.getMsgId());\n            if (bean.getKeys() != null && bean.getKeys().length() > 0) {\n                String[] keys = bean.getKeys().split(MessageConst.KEY_SEPARATOR);\n                transferBean.getTransKey().addAll(Arrays.asList(keys));\n            }\n        }\n        return transferBean;\n    }\n"
    ],
    "test_id": 53,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testSubAfterTraceDataFormatTest() {\n    TraceContext subAfterContext = new TraceContext();\n    subAfterContext.setTraceType(TraceType.SubAfter);\n    subAfterContext.setRequestId(\"3455848576927\");\n    subAfterContext.setCostTime(20);\n    subAfterContext.setSuccess(true);\n    subAfterContext.setTimeStamp(1625883640000L);\n    subAfterContext.setGroupName(\"GroupName-test\");\n    subAfterContext.setContextCode(98623046);\n    TraceBean bean = new TraceBean();\n    bean.setMsgId(\"AC1415116D1418B4AAC217FE1B4E0000\");\n    bean.setKeys(\"keys\");\n    subAfterContext.setTraceBeans(new ArrayList<>(1));\n    subAfterContext.getTraceBeans().add(bean);\n\n    TraceTransferBean traceTransferBean = TraceDataEncoder.encoderFromContextBean(subAfterContext);\n    String transData = traceTransferBean.getTransData();\n    Assert.assertNotNull(transData);\n    String[] items = transData.split(String.valueOf(TraceConstants.CONTENT_SPLITOR));\n    Assert.assertEquals(9, items.length);\n\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testSubAfterTraceDataFormatTest() {\n    TraceContext subAfterContext = new TraceContext();\n    subAfterContext.setTraceType(TraceType.SubAfter);\n    subAfterContext.setRequestId(\"3455848576927\");\n    subAfterContext.setCostTime(20);\n    subAfterContext.setSuccess(true);\n    subAfterContext.setTimeStamp(1625883640000L);\n    subAfterContext.setGroupName(\"GroupName-test\");\n    subAfterContext.setContextCode(98623046);\n    TraceBean bean = new TraceBean();\n    bean.setMsgId(\"AC1415116D1418B4AAC217FE1B4E0000\");\n    bean.setKeys(\"keys\");\n    subAfterContext.setTraceBeans(new ArrayList<>(1));\n    subAfterContext.getTraceBeans().add(bean);\n\n    TraceTransferBean traceTransferBean = TraceDataEncoder.encoderFromContextBean(subAfterContext);\n    String transData = traceTransferBean.getTransData();\n    Assert.assertNotNull(transData);\n    String[] items = transData.split(String.valueOf(TraceConstants.CONTENT_SPLITOR));\n    Assert.assertEquals(9, items.length);\n\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "OutOfMemoryError('CUDA out of memory. Tried to allocate 7.87 GiB. GPU 0 has a total capacty of 23.69 GiB of which 6.87 GiB is free. Process 1478252 has 16.81 GiB memory in use. Of the allocated memory 7.70 GiB is allocated by PyTorch, and 8.08 GiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF')"
  },
  "54": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetProducerData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetProducerData"
    ],
    "test_src_code": "    @Test\n    public void testGetProducerData() {\n        ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n        this.grpcClientSettingsManager.updateClientSettings(CLIENT_ID, Settings.newBuilder()\n            .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n            .setPublishing(Publishing.getDefaultInstance())\n            .build());\n        Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n        assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#getClientSettings",
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#updateClientSettings"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#getClientSettings",
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#updateClientSettings"
    ],
    "focal_src": [
      "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = CLIENT_SETTINGS_MAP.get(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
      "    public void updateClientSettings(String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n"
    ],
    "focal_tgt": [
      "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = getRawClientSettings(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
      "    public void updateClientSettings(ProxyContext ctx, String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n"
    ],
    "test_id": 54,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetProducerData() {\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n        .setPublishing(Publishing.getDefaultInstance())\n        .build());\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n    assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n}\n",
      "@Test\npublic void testGetProducerData() {\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n        .setPublishing(Publishing.getDefaultInstance())\n        .build());\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n    assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n}\n",
      "@Test\npublic void testGetProducerData() {\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n        .setPublishing(Publishing.getDefaultInstance())\n        .build());\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n    assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n}\n",
      "@Test\npublic void testGetProducerData() {\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n        .setPublishing(Publishing.getDefaultInstance())\n        .build());\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n    assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n}\n",
      "@Test\npublic void testGetProducerData() {\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n        .setPublishing(Publishing.getDefaultInstance())\n        .build());\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n    assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testGetProducerData() {\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n        .setPublishing(Publishing.getDefaultInstance())\n        .build());\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n    assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n    // Testing the case where settings are null\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, \"non_existing_client\");\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n}\n",
      "@Test\npublic void testGetProducerData() {\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n        .setPublishing(Publishing.getDefaultInstance())\n        .build());\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n    assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n    // Testing the case where settings are null\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, \"non_existing_client\");\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n}\n",
      "@Test\npublic void testGetProducerData() {\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n        .setPublishing(Publishing.getDefaultInstance())\n        .build());\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n    assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n    // Testing the case where settings are null\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, \"non_existing_client\");\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n}\n",
      "@Test\npublic void testGetProducerData() {\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n        .setPublishing(Publishing.getDefaultInstance())\n        .build());\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n    assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n    // Testing the case where settings are null\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, \"non_existing_client\");\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n}\n",
      "@Test\npublic void testGetProducerData() {\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n        .setPublishing(Publishing.getDefaultInstance())\n        .build());\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n    assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n    // Testing the case where settings are null\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, \"non_existing_client\");\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n}\n"
    ]
  },
  "55": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData"
    ],
    "test_src_code": "    @Test\n    public void testGetSubscriptionData() {\n        SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n        when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n            .thenReturn(subscriptionGroupConfig);\n\n        this.grpcClientSettingsManager.updateClientSettings(CLIENT_ID, Settings.newBuilder()\n            .setSubscription(Subscription.newBuilder()\n                .setGroup(Resource.newBuilder().setName(\"group\").build())\n                .build())\n            .build());\n\n        ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n        Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n        subscriptionGroupConfig.setRetryMaxTimes(3);\n        subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n        subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n        settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(RetryPolicy.newBuilder()\n            .setMaxAttempts(4)\n            .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n                .addNext(Durations.fromSeconds(1))\n                .build())\n            .build(), settings.getBackoffPolicy());\n\n        subscriptionGroupConfig.setRetryMaxTimes(10);\n        subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n        subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n        settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(RetryPolicy.newBuilder()\n            .setMaxAttempts(11)\n            .setExponentialBackoff(ExponentialBackoff.newBuilder()\n                .setMax(Durations.fromSeconds(2))\n                .setInitial(Durations.fromSeconds(1))\n                .setMultiplier(3)\n                .build())\n            .build(), settings.getBackoffPolicy());\n\n        Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n        assertEquals(settings, settings1);\n\n        assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n        assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#getClientSettings",
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#updateClientSettings",
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#removeAndGetClientSettings"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#getClientSettings",
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#updateClientSettings",
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#removeAndGetClientSettings"
    ],
    "focal_src": [
      "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = CLIENT_SETTINGS_MAP.get(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
      "    public void updateClientSettings(String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n",
      "    public Settings removeAndGetClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = CLIENT_SETTINGS_MAP.remove(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n"
    ],
    "focal_tgt": [
      "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = getRawClientSettings(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
      "    public void updateClientSettings(ProxyContext ctx, String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n",
      "    public Settings removeAndGetClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = this.removeAndGetRawClientSettings(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n"
    ],
    "test_id": 55,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testGetSubscriptionData() {\n    SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n    when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n        .thenReturn(subscriptionGroupConfig);\n\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setSubscription(Subscription.newBuilder()\n            .setGroup(Resource.newBuilder().setName(\"group\").build())\n            .build())\n        .build());\n\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(3);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n    subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(4)\n        .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n            .addNext(Durations.fromSeconds(1))\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(10);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n    subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(11)\n        .setExponentialBackoff(ExponentialBackoff.newBuilder()\n            .setMax(Durations.fromSeconds(2))\n            .setInitial(Durations.fromSeconds(1))\n            .setMultiplier(3)\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n    assertEquals(settings, settings1);\n\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n}\n",
      "@Test\npublic void testGetSubscriptionData() {\n    SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n    when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n        .thenReturn(subscriptionGroupConfig);\n\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setSubscription(Subscription.newBuilder()\n            .setGroup(Resource.newBuilder().setName(\"group\").build())\n            .build())\n        .build());\n\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(3);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n    subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(4)\n        .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n            .addNext(Durations.fromSeconds(1))\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(10);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n    subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(11)\n        .setExponentialBackoff(ExponentialBackoff.newBuilder()\n            .setMax(Durations.fromSeconds(2))\n            .setInitial(Durations.fromSeconds(1))\n            .setMultiplier(3)\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n    assertEquals(settings, settings1);\n\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n}\n",
      "@Test\npublic void testGetSubscriptionData() {\n    SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n    when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n        .thenReturn(subscriptionGroupConfig);\n\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setSubscription(Subscription.newBuilder()\n            .setGroup(Resource.newBuilder().setName(\"group\").build())\n            .build())\n        .build());\n\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(3);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n    subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(4)\n        .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n            .addNext(Durations.fromSeconds(1))\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(10);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n    subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(11)\n        .setExponentialBackoff(ExponentialBackoff.newBuilder()\n            .setMax(Durations.fromSeconds(2))\n            .setInitial(Durations.fromSeconds(1))\n            .setMultiplier(3)\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n    assertEquals(settings, settings1);\n\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n}\n",
      "@Test\npublic void testGetSubscriptionData() {\n    SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n    when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n        .thenReturn(subscriptionGroupConfig);\n\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    Settings settings = Settings.newBuilder()\n        .setSubscription(Subscription.newBuilder()\n            .setGroup(Resource.newBuilder().setName(\"group\").build())\n            .build())\n        .build();\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, settings);\n\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(3);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n    subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(4)\n        .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n            .addNext(Durations.fromSeconds(1))\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(10);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n    subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(11)\n        .setExponentialBackoff(ExponentialBackoff.newBuilder()\n            .setMax(Durations.fromSeconds(2))\n            .setInitial(Durations.fromSeconds(1))\n            .setMultiplier(3)\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n    assertEquals(settings, settings1);\n\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testGetSubscriptionData() {\n    SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n    when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n        .thenReturn(subscriptionGroupConfig);\n\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setSubscription(Subscription.newBuilder()\n            .setGroup(Resource.newBuilder().setName(\"group\").build())\n            .build())\n        .build());\n\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(3);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n    subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(4)\n        .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n            .addNext(Durations.fromSeconds(1))\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(10);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n    subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(11)\n        .setExponentialBackoff(ExponentialBackoff.newBuilder()\n            .setMax(Durations.fromSeconds(2))\n            .setInitial(Durations.fromSeconds(1))\n            .setMultiplier(3)\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n    assertEquals(settings, settings1);\n\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n    // Testing null clientId\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, null);\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n\n    // Testing empty clientId\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, \"\");\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n}\n",
      "@Test\npublic void testGetSubscriptionData() {\n    SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n    when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n        .thenReturn(subscriptionGroupConfig);\n\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setSubscription(Subscription.newBuilder()\n            .setGroup(Resource.newBuilder().setName(\"group\").build())\n            .build())\n        .build());\n\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(3);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n    subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(4)\n        .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n            .addNext(Durations.fromSeconds(1))\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(10);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n    subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(11)\n        .setExponentialBackoff(ExponentialBackoff.newBuilder()\n            .setMax(Durations.fromSeconds(2))\n            .setInitial(Durations.fromSeconds(1))\n            .setMultiplier(3)\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n    assertEquals(settings, settings1);\n\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n    // Testing null clientId\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, null);\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n\n    // Testing empty clientId\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, \"\");\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n}\n",
      "@Test\npublic void testGetSubscriptionData() {\n    SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n    when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n        .thenReturn(subscriptionGroupConfig);\n\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, Settings.newBuilder()\n        .setSubscription(Subscription.newBuilder()\n            .setGroup(Resource.newBuilder().setName(\"group\").build())\n            .build())\n        .build());\n\n    Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(3);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n    subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(4)\n        .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n            .addNext(Durations.fromSeconds(1))\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(10);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n    subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(11)\n        .setExponentialBackoff(ExponentialBackoff.newBuilder()\n            .setMax(Durations.fromSeconds(2))\n            .setInitial(Durations.fromSeconds(1))\n            .setMultiplier(3)\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n    assertEquals(settings, settings1);\n\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n    // Testing null clientId\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, null);\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n\n    // Testing empty clientId\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, \"\");\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n}\n",
      "@Test\npublic void testGetSubscriptionData() {\n    SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n    when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n        .thenReturn(subscriptionGroupConfig);\n\n    ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n    Settings settings = Settings.newBuilder()\n        .setSubscription(Subscription.newBuilder()\n            .setGroup(Resource.newBuilder().setName(\"group\").build())\n            .build())\n        .build();\n\n    this.grpcClientSettingsManager.updateClientSettings(context, CLIENT_ID, settings);\n\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(3);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n    subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(4)\n        .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n            .addNext(Durations.fromSeconds(1))\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    subscriptionGroupConfig.setRetryMaxTimes(10);\n    subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n    subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n    settings = this.grpcClientSettingsManager.getClientSettings(context);\n    assertEquals(RetryPolicy.newBuilder()\n        .setMaxAttempts(11)\n        .setExponentialBackoff(ExponentialBackoff.newBuilder()\n            .setMax(Durations.fromSeconds(2))\n            .setInitial(Durations.fromSeconds(1))\n            .setMultiplier(3)\n            .build())\n        .build(), settings.getBackoffPolicy());\n\n    Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n    assertEquals(settings, settings1);\n\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n    // Testing for null clientId\n    context = ProxyContext.create();\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n\n    // Testing for null settings\n    context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n    assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n    assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n}\n"
    ]
  },
  "56": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithoutSub",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithoutSub"
    ],
    "test_src_code": "    @Test\n    public void testPullMessageWithoutSub() throws Exception {\n        when(messagingProcessorMock.getConsumerGroupInfo(eq(group)))\n            .thenReturn(consumerGroupInfoMock);\n        SubscriptionData subscriptionData = new SubscriptionData();\n        subscriptionData.setSubString(subString);\n        subscriptionData.setExpressionType(type);\n        when(consumerGroupInfoMock.findSubscriptionData(eq(topic)))\n            .thenReturn(subscriptionData);\n\n        PullMessageRequestHeader header = new PullMessageRequestHeader();\n        header.setTopic(topic);\n        header.setConsumerGroup(group);\n        header.setQueueId(0);\n        header.setQueueOffset(0L);\n        header.setMaxMsgNums(16);\n        header.setSysFlag(PullSysFlag.buildSysFlag(true, false, false, false));\n        header.setCommitOffset(0L);\n        header.setSuspendTimeoutMillis(1000L);\n        header.setSubVersion(0L);\n        header.setBname(brokerName);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, header);\n        request.makeCustomHeaderToNet();\n        RemotingCommand expectResponse = RemotingCommand.createResponseCommand(ResponseCode.NO_MESSAGE, \"success\");\n        PullMessageRequestHeader newHeader = new PullMessageRequestHeader();\n        newHeader.setTopic(topic);\n        newHeader.setConsumerGroup(group);\n        newHeader.setQueueId(0);\n        newHeader.setQueueOffset(0L);\n        newHeader.setMaxMsgNums(16);\n        newHeader.setSysFlag(PullSysFlag.buildSysFlag(true, false, true, false));\n        newHeader.setCommitOffset(0L);\n        newHeader.setSuspendTimeoutMillis(1000L);\n        newHeader.setSubVersion(0L);\n        newHeader.setBname(brokerName);\n        newHeader.setSubscription(subString);\n        newHeader.setExpressionType(type);\n        RemotingCommand matchRequest = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, newHeader);\n        matchRequest.setOpaque(request.getOpaque());\n        matchRequest.makeCustomHeaderToNet();\n\n        ArgumentCaptor<RemotingCommand> captor = ArgumentCaptor.forClass(RemotingCommand.class);\n        when(messagingProcessorMock.request(any(), eq(brokerName), captor.capture(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(expectResponse));\n        RemotingCommand response = pullMessageActivity.processRequest0(ctx, request, null);\n        assertThat(captor.getValue().getExtFields()).isEqualTo(matchRequest.getExtFields());\n        assertThat(response).isNull();\n        verify(ctx, times(1)).writeAndFlush(eq(expectResponse));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivity.java#processRequest0"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivity.java#processRequest0"
    ],
    "focal_src": [
      "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(context, requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n"
    ],
    "test_id": 56,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testPullMessageWithoutSub() throws Exception {\n    when(messagingProcessorMock.getConsumerGroupInfo(eq(group)))\n        .thenReturn(consumerGroupInfoMock);\n    SubscriptionData subscriptionData = new SubscriptionData();\n    subscriptionData.setSubString(subString);\n    subscriptionData.setExpressionType(type);\n    when(consumerGroupInfoMock.findSubscriptionData(eq(topic)))\n        .thenReturn(subscriptionData);\n\n    PullMessageRequestHeader header = new PullMessageRequestHeader();\n    header.setTopic(topic);\n    header.setConsumerGroup(group);\n    header.setQueueId(0);\n    header.setQueueOffset(0L);\n    header.setMaxMsgNums(16);\n    header.setSysFlag(PullSysFlag.buildSysFlag(true, false, false, false));\n    header.setCommitOffset(0L);\n    header.setSuspendTimeoutMillis(1000L);\n    header.setSubVersion(0L);\n    header.setBname(brokerName);\n\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, header);\n    request.makeCustomHeaderToNet();\n    RemotingCommand expectResponse = RemotingCommand.createResponseCommand(ResponseCode.NO_MESSAGE, \"success\");\n    PullMessageRequestHeader newHeader = new PullMessageRequestHeader();\n    newHeader.setTopic(topic);\n    newHeader.setConsumerGroup(group);\n    newHeader.setQueueId(0);\n    newHeader.setQueueOffset(0L);\n    newHeader.setMaxMsgNums(16);\n    newHeader.setSysFlag(PullSysFlag.buildSysFlag(true, false, true, false));\n    newHeader.setCommitOffset(0L);\n    newHeader.setSuspendTimeoutMillis(1000L);\n    newHeader.setSubVersion(0L);\n    newHeader.setBname(brokerName);\n    newHeader.setSubscription(subString);\n    newHeader.setExpressionType(type);\n    RemotingCommand matchRequest = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, newHeader);\n    matchRequest.setOpaque(request.getOpaque());\n    matchRequest.makeCustomHeaderToNet();\n\n    ArgumentCaptor<RemotingCommand> captor = ArgumentCaptor.forClass(RemotingCommand.class);\n    when(messagingProcessorMock.request(any(), eq(brokerName), captor.capture(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(expectResponse));\n    RemotingCommand response = pullMessageActivity.processRequest0(ctx, request, null);\n    assertThat(captor.getValue().getExtFields()).isEqualTo(matchRequest.getExtFields());\n    assertThat(response).isNull();\n    verify(ctx, times(1)).writeAndFlush(eq(expectResponse));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testPullMessageWithoutSub() throws Exception {\n    when(messagingProcessorMock.getConsumerGroupInfo(eq(group)))\n        .thenReturn(consumerGroupInfoMock);\n    SubscriptionData subscriptionData = new SubscriptionData();\n    subscriptionData.setSubString(subString);\n    subscriptionData.setExpressionType(type);\n    when(consumerGroupInfoMock.findSubscriptionData(eq(topic)))\n        .thenReturn(subscriptionData);\n\n    PullMessageRequestHeader header = new PullMessageRequestHeader();\n    header.setTopic(topic);\n    header.setConsumerGroup(group);\n    header.setQueueId(0);\n    header.setQueueOffset(0L);\n    header.setMaxMsgNums(16);\n    header.setSysFlag(PullSysFlag.buildSysFlag(true, false, false, false));\n    header.setCommitOffset(0L);\n    header.setSuspendTimeoutMillis(1000L);\n    header.setSubVersion(0L);\n    header.setBname(brokerName);\n\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, header);\n    request.makeCustomHeaderToNet();\n    RemotingCommand expectResponse = RemotingCommand.createResponseCommand(ResponseCode.NO_MESSAGE, \"success\");\n    PullMessageRequestHeader newHeader = new PullMessageRequestHeader();\n    newHeader.setTopic(topic);\n    newHeader.setConsumerGroup(group);\n    newHeader.setQueueId(0);\n    newHeader.setQueueOffset(0L);\n    newHeader.setMaxMsgNums(16);\n    newHeader.setSysFlag(PullSysFlag.buildSysFlag(true, false, true, false));\n    newHeader.setCommitOffset(0L);\n    newHeader.setSuspendTimeoutMillis(1000L);\n    newHeader.setSubVersion(0L);\n    newHeader.setBname(brokerName);\n    newHeader.setSubscription(subString);\n    newHeader.setExpressionType(type);\n    RemotingCommand matchRequest = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, newHeader);\n    matchRequest.setOpaque(request.getOpaque());\n    matchRequest.makeCustomHeaderToNet();\n\n    ArgumentCaptor<RemotingCommand> captor = ArgumentCaptor.forClass(RemotingCommand.class);\n    when(messagingProcessorMock.request(any(), eq(brokerName), captor.capture(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(expectResponse));\n    RemotingCommand response = pullMessageActivity.processRequest0(ctx, request, null);\n    assertThat(captor.getValue().getExtFields()).isEqualTo(matchRequest.getExtFields());\n    assertThat(response).isNull();\n    verify(ctx, times(1)).writeAndFlush(eq(expectResponse));\n}\n"
    ]
  },
  "57": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithSub",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithSub"
    ],
    "test_src_code": "    @Test\n    public void testPullMessageWithSub() throws Exception {\n        when(messagingProcessorMock.getConsumerGroupInfo(eq(group)))\n            .thenReturn(consumerGroupInfoMock);\n        SubscriptionData subscriptionData = new SubscriptionData();\n        subscriptionData.setSubString(subString);\n        subscriptionData.setExpressionType(type);\n        when(consumerGroupInfoMock.findSubscriptionData(eq(topic)))\n            .thenReturn(subscriptionData);\n\n        PullMessageRequestHeader header = new PullMessageRequestHeader();\n        header.setTopic(topic);\n        header.setConsumerGroup(group);\n        header.setQueueId(0);\n        header.setQueueOffset(0L);\n        header.setMaxMsgNums(16);\n        header.setSysFlag(PullSysFlag.buildSysFlag(true, true, false, false));\n        header.setCommitOffset(0L);\n        header.setSuspendTimeoutMillis(1000L);\n        header.setSubVersion(0L);\n        header.setBname(brokerName);\n        header.setSubscription(subString);\n        header.setExpressionType(type);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, header);\n        request.makeCustomHeaderToNet();\n        RemotingCommand expectResponse = RemotingCommand.createResponseCommand(ResponseCode.NO_MESSAGE, \"success\");\n\n        ArgumentCaptor<RemotingCommand> captor = ArgumentCaptor.forClass(RemotingCommand.class);\n        when(messagingProcessorMock.request(any(), eq(brokerName), captor.capture(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(expectResponse));\n        RemotingCommand response = pullMessageActivity.processRequest0(ctx, request, null);\n        assertThat(captor.getValue().getExtFields()).isEqualTo(request.getExtFields());\n        assertThat(response).isNull();\n        verify(ctx, times(1)).writeAndFlush(eq(expectResponse));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivity.java#processRequest0"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivity.java#processRequest0"
    ],
    "focal_src": [
      "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(context, requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n"
    ],
    "test_id": 57,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testPullMessageWithSub() throws Exception {\n    when(messagingProcessorMock.getConsumerGroupInfo(eq(group)))\n        .thenReturn(consumerGroupInfoMock);\n    SubscriptionData subscriptionData = new SubscriptionData();\n    subscriptionData.setSubString(subString);\n    subscriptionData.setExpressionType(type);\n    when(consumerGroupInfoMock.findSubscriptionData(eq(topic)))\n        .thenReturn(subscriptionData);\n\n    PullMessageRequestHeader header = new PullMessageRequestHeader();\n    header.setTopic(topic);\n    header.setConsumerGroup(group);\n    header.setQueueId(0);\n    header.setQueueOffset(0L);\n    header.setMaxMsgNums(16);\n    header.setSysFlag(PullSysFlag.buildSysFlag(true, true, false, false));\n    header.setCommitOffset(0L);\n    header.setSuspendTimeoutMillis(1000L);\n    header.setSubVersion(0L);\n    header.setBname(brokerName);\n    header.setSubscription(subString);\n    header.setExpressionType(type);\n\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, header);\n    request.makeCustomHeaderToNet();\n    RemotingCommand expectResponse = RemotingCommand.createResponseCommand(ResponseCode.NO_MESSAGE, \"success\");\n\n    ArgumentCaptor<RemotingCommand> captor = ArgumentCaptor.forClass(RemotingCommand.class);\n    when(messagingProcessorMock.request(any(), eq(brokerName), captor.capture(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(expectResponse));\n    RemotingCommand response = pullMessageActivity.processRequest0(ctx, request, null);\n    assertThat(captor.getValue().getExtFields()).isEqualTo(request.getExtFields());\n    assertThat(response).isNull();\n    verify(ctx, times(1)).writeAndFlush(eq(expectResponse));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testPullMessageWithSub() throws Exception {\n    when(messagingProcessorMock.getConsumerGroupInfo(eq(group)))\n        .thenReturn(consumerGroupInfoMock);\n    SubscriptionData subscriptionData = new SubscriptionData();\n    subscriptionData.setSubString(subString);\n    subscriptionData.setExpressionType(type);\n    when(consumerGroupInfoMock.findSubscriptionData(eq(topic)))\n        .thenReturn(subscriptionData);\n\n    PullMessageRequestHeader header = new PullMessageRequestHeader();\n    header.setTopic(topic);\n    header.setConsumerGroup(group);\n    header.setQueueId(0);\n    header.setQueueOffset(0L);\n    header.setMaxMsgNums(16);\n    header.setSysFlag(PullSysFlag.buildSysFlag(true, true, false, false));\n    header.setCommitOffset(0L);\n    header.setSuspendTimeoutMillis(1000L);\n    header.setSubVersion(0L);\n    header.setBname(brokerName);\n    header.setSubscription(subString);\n    header.setExpressionType(type);\n\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, header);\n    request.makeCustomHeaderToNet();\n    RemotingCommand expectResponse = RemotingCommand.createResponseCommand(ResponseCode.NO_MESSAGE, \"success\");\n\n    ArgumentCaptor<RemotingCommand> captor = ArgumentCaptor.forClass(RemotingCommand.class);\n    when(messagingProcessorMock.request(any(), eq(brokerName), captor.capture(), anyLong()))\n        .thenReturn(CompletableFuture.completedFuture(expectResponse));\n    RemotingCommand response = pullMessageActivity.processRequest0(ctx, request, null);\n    assertThat(captor.getValue().getExtFields()).isEqualTo(request.getExtFields());\n    assertThat(response).isNull();\n    verify(ctx, times(1)).writeAndFlush(eq(expectResponse));\n}\n"
    ]
  },
  "58": {
    "commit_src": "a1bf49d5d07cf64374bc3dde5ab43add831433ad",
    "commit_tgt": "ab61183030f4f230619ea539cbd2cb977234208b",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-7105",
    "test_src": ".org.apache.rocketmq.proxy.service.receipt.DefaultReceiptHandleManagerTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.receipt.DefaultReceiptHandleManagerTest#testClearGroup"
    ],
    "test_src_code": "    @Test\n    public void testClearGroup() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleManager.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n        receiptHandleManager.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleManager.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManager.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManager.java#scheduleRenewTask",
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManager.java#clearGroup"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManager.java#addReceiptHandle",
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManager.java#scheduleRenewTask",
      "proxy/src/main/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManager.java#clearGroup"
    ],
    "focal_src": [
      "    public void addReceiptHandle(ProxyContext context, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, group),\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
      "    protected void scheduleRenewTask() {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        try {\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            for (Map.Entry<ReceiptHandleProcessor.ReceiptHandleGroupKey, ReceiptHandleGroup> entry : receiptHandleGroupMap.entrySet()) {\n                ReceiptHandleProcessor.ReceiptHandleGroupKey key = entry.getKey();\n                if (clientIsOffline(key)) {\n                    clearGroup(key);\n                    continue;\n                }\n\n                ReceiptHandleGroup group = entry.getValue();\n                group.scan((msgID, handleStr, v) -> {\n                    long current = System.currentTimeMillis();\n                    ReceiptHandle handle = ReceiptHandle.decode(v.getReceiptHandleStr());\n                    if (handle.getNextVisibleTime() - current > proxyConfig.getRenewAheadTimeMillis()) {\n                        return;\n                    }\n                    renewalWorkerService.submit(() -> renewMessage(group, msgID, handleStr));\n                });\n            }\n        } catch (Exception e) {\n            log.error(\"unexpect error when schedule renew task\", e);\n        }\n\n        log.debug(\"scan for renewal done. cost:{}ms\", stopwatch.elapsed().toMillis());\n    }\n",
      "    protected void clearGroup(ReceiptHandleProcessor.ReceiptHandleGroupKey key) {\n        if (key == null) {\n            return;\n        }\n        ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n        ReceiptHandleGroup handleGroup = receiptHandleGroupMap.remove(key);\n        if (handleGroup == null) {\n            return;\n        }\n        handleGroup.scan((msgID, handle, v) -> {\n            try {\n                handleGroup.computeIfPresent(msgID, handle, messageReceiptHandle -> {\n                    CompletableFuture<AckResult> future = new CompletableFuture<>();\n                    eventListener.fireEvent(new RenewEvent(messageReceiptHandle, proxyConfig.getInvisibleTimeMillisWhenClear(), RenewEvent.EventType.CLEAR_GROUP, future));\n                    return CompletableFuture.completedFuture(null);\n                });\n            } catch (Exception e) {\n                log.error(\"error when clear handle for group. key:{}\", key, e);\n            }\n        });\n    }\n"
    ],
    "focal_tgt": [
      "    public void addReceiptHandle(ProxyContext context, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, new ReceiptHandleGroupKey(channel, group),\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
      "    protected void scheduleRenewTask() {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        try {\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            for (Map.Entry<ReceiptHandleGroupKey, ReceiptHandleGroup> entry : receiptHandleGroupMap.entrySet()) {\n                ReceiptHandleGroupKey key = entry.getKey();\n                if (clientIsOffline(key)) {\n                    clearGroup(key);\n                    continue;\n                }\n\n                ReceiptHandleGroup group = entry.getValue();\n                group.scan((msgID, handleStr, v) -> {\n                    long current = System.currentTimeMillis();\n                    ReceiptHandle handle = ReceiptHandle.decode(v.getReceiptHandleStr());\n                    if (handle.getNextVisibleTime() - current > proxyConfig.getRenewAheadTimeMillis()) {\n                        return;\n                    }\n                    renewalWorkerService.submit(() -> renewMessage(key, group, msgID, handleStr));\n                });\n            }\n        } catch (Exception e) {\n            log.error(\"unexpect error when schedule renew task\", e);\n        }\n\n        log.debug(\"scan for renewal done. cost:{}ms\", stopwatch.elapsed().toMillis());\n    }\n",
      "    protected void clearGroup(ReceiptHandleGroupKey key) {\n        if (key == null) {\n            return;\n        }\n        ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n        ReceiptHandleGroup handleGroup = receiptHandleGroupMap.remove(key);\n        if (handleGroup == null) {\n            return;\n        }\n        handleGroup.scan((msgID, handle, v) -> {\n            try {\n                handleGroup.computeIfPresent(msgID, handle, messageReceiptHandle -> {\n                    CompletableFuture<AckResult> future = new CompletableFuture<>();\n                    eventListener.fireEvent(new RenewEvent(key, messageReceiptHandle, proxyConfig.getInvisibleTimeMillisWhenClear(), RenewEvent.EventType.CLEAR_GROUP, future));\n                    return CompletableFuture.completedFuture(null);\n                });\n            } catch (Exception e) {\n                log.error(\"error when clear handle for group. key:{}\", key, e);\n            }\n        });\n    }\n"
    ],
    "test_id": 58,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleManager.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleManager.clearGroup(new ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleManager.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleManager.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleManager.clearGroup(new ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleManager.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleManager.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleManager.clearGroup(new ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleManager.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n}\n",
      "@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleManager.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleManager.clearGroup(new ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleManager.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testClearGroup() {\n    Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n    receiptHandleManager.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n    receiptHandleManager.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n    SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n    Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n    receiptHandleManager.scheduleRenewTask();\n    Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n        .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n}\n"
    ]
  },
  "59": {
    "commit_src": "bcba5a8e628e35086c699852388990ba8a4bdcf8",
    "commit_tgt": "b2deef179dbc6a9eb1a2b6dd7b652d95cb768295",
    "changed_tests": [
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/CompositeQueueFlatFileTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-7145",
    "test_src": ".org.apache.rocketmq.tieredstore.TieredDispatcherTest#testDispatchByFlatFile",
    "test_tgt": [
      ".org.apache.rocketmq.tieredstore.TieredDispatcherTest#testDispatchByFlatFile"
    ],
    "test_src_code": "    @Test\n    public void testDispatchByFlatFile() {\n        metadataStore.addQueue(mq, 6);\n        TieredFlatFileManager flatFileManager = TieredFlatFileManager.getInstance(storeConfig);\n        DefaultMessageStore defaultStore = Mockito.mock(DefaultMessageStore.class);\n        Mockito.when(defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).thenReturn(Mockito.mock(ConsumeQueue.class));\n        TieredDispatcher dispatcher = new TieredDispatcher(defaultStore, storeConfig);\n\n        Mockito.when(defaultStore.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(0L);\n        Mockito.when(defaultStore.getMaxOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(9L);\n\n        ByteBuffer cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);\n        cqItem.putLong(7);\n        cqItem.putInt(MessageBufferUtilTest.MSG_LEN);\n        cqItem.putLong(1);\n        cqItem.flip();\n        SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);\n        Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(6)).thenReturn(mockResult);\n\n        cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);\n        cqItem.putLong(8);\n        cqItem.putInt(MessageBufferUtilTest.MSG_LEN);\n        cqItem.putLong(1);\n        cqItem.flip();\n        mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);\n\n        Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(7)).thenReturn(mockResult);\n\n        mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMockedMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);\n        Mockito.when(defaultStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);\n\n        ByteBuffer msg = MessageBufferUtilTest.buildMockedMessageBuffer();\n        msg.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);\n        mockResult = new SelectMappedBufferResult(0, msg, MessageBufferUtilTest.MSG_LEN, null);\n        Mockito.when(defaultStore.selectOneMessageByOffset(8, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);\n\n        dispatcher.dispatchFlatFile(flatFileManager.getOrCreateFlatFileIfAbsent(mq));\n        Assert.assertEquals(8, flatFileManager.getFlatFile(mq).getDispatchOffset());\n    }\n",
    "focal_path_src": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/TieredDispatcher.java#dispatchFlatFile"
    ],
    "focal_path_tgt": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/TieredDispatcher.java#dispatchFlatFile"
    ],
    "focal_src": [
      "    protected void dispatchFlatFile(CompositeQueueFlatFile flatFile) {\n        if (stopped) {\n            return;\n        }\n\n        if (flatFile.getDispatchOffset() == -1L) {\n            return;\n        }\n\n        if (detectFallBehind(flatFile)) {\n            return;\n        }\n\n        MessageQueue mq = flatFile.getMessageQueue();\n        String topic = mq.getTopic();\n        int queueId = mq.getQueueId();\n\n        long beforeOffset = flatFile.getDispatchOffset();\n        long minOffsetInQueue = defaultStore.getMinOffsetInQueue(topic, queueId);\n        long maxOffsetInQueue = defaultStore.getMaxOffsetInQueue(topic, queueId);\n\n        // perhaps it was caused by local cq file corruption or ha truncation\n        if (beforeOffset >= maxOffsetInQueue) {\n            return;\n        }\n\n        try {\n            if (!flatFile.getCompositeFlatFileLock().tryLock(200, TimeUnit.MILLISECONDS)) {\n                return;\n            }\n        } catch (Exception e) {\n            logger.warn(\"TieredDispatcher#dispatchFlatFile: can not acquire flatFile lock, \" +\n                \"topic: {}, queueId: {}\", mq.getTopic(), mq.getQueueId(), e);\n            if (flatFile.getCompositeFlatFileLock().isLocked()) {\n                flatFile.getCompositeFlatFileLock().unlock();\n            }\n            return;\n        }\n\n        try {\n            long dispatchOffset = flatFile.getDispatchOffset();\n            if (dispatchOffset < minOffsetInQueue) {\n                // If the tiered storage feature is turned off midway,\n                // it may cause cq discontinuity, resulting in data loss here.\n                logger.warn(\"TieredDispatcher#dispatchFlatFile: dispatch offset is too small, \" +\n                        \"topic: {}, queueId: {}, dispatch offset: {}, local cq offset range {}-{}\",\n                    topic, queueId, dispatchOffset, minOffsetInQueue, maxOffsetInQueue);\n\n                // when dispatch offset is smaller than min offset in local cq\n                // some earliest messages may be lost at this time\n                tieredFlatFileManager.destroyCompositeFile(flatFile.getMessageQueue());\n                CompositeQueueFlatFile newFlatFile =\n                    tieredFlatFileManager.getOrCreateFlatFileIfAbsent(new MessageQueue(topic, brokerName, queueId));\n                if (newFlatFile != null) {\n                    newFlatFile.initOffset(maxOffsetInQueue);\n                }\n                return;\n            }\n            beforeOffset = dispatchOffset;\n\n            // flow control by max count, also we could do flow control based on message size\n            long maxCount = storeConfig.getTieredStoreGroupCommitCount();\n            long upperBound = Math.min(dispatchOffset + maxCount, maxOffsetInQueue);\n            ConsumeQueue consumeQueue = (ConsumeQueue) defaultStore.getConsumeQueue(topic, queueId);\n\n            for (; dispatchOffset < upperBound; dispatchOffset++) {\n                // get consume queue\n                SelectMappedBufferResult cqItem = consumeQueue.getIndexBuffer(dispatchOffset);\n                if (cqItem == null) {\n                    logger.error(\"[Bug] TieredDispatcher#dispatchFlatFile: cq item is null, \" +\n                            \"topic: {}, queueId: {}, dispatch offset: {}, local cq offset range {}-{}\",\n                        topic, queueId, dispatchOffset, minOffsetInQueue, maxOffsetInQueue);\n                    return;\n                }\n                long commitLogOffset = CQItemBufferUtil.getCommitLogOffset(cqItem.getByteBuffer());\n                int size = CQItemBufferUtil.getSize(cqItem.getByteBuffer());\n                long tagCode = CQItemBufferUtil.getTagCode(cqItem.getByteBuffer());\n                cqItem.release();\n\n                // get message\n                SelectMappedBufferResult message = defaultStore.selectOneMessageByOffset(commitLogOffset, size);\n                if (message == null) {\n                    logger.error(\"TieredDispatcher#dispatchFlatFile: get message from next store failed, \" +\n                            \"topic: {}, queueId: {}, commitLog offset: {}, size: {}\",\n                        topic, queueId, commitLogOffset, size);\n                    // not dispatch immediately\n                    return;\n                }\n\n                // append commitlog will increase dispatch offset here\n                AppendResult result = flatFile.appendCommitLog(message.getByteBuffer(), true);\n                long newCommitLogOffset = flatFile.getCommitLogMaxOffset() - message.getByteBuffer().remaining();\n                doRedispatchRequestToWriteMap(\n                    result, flatFile, dispatchOffset, newCommitLogOffset, size, tagCode, message.getByteBuffer());\n                message.release();\n\n                switch (result) {\n                    case SUCCESS:\n                        continue;\n                    case FILE_CLOSED:\n                        tieredFlatFileManager.destroyCompositeFile(flatFile.getMessageQueue());\n                        logger.info(\"TieredDispatcher#dispatchFlatFile: file has been close and destroy, \" +\n                            \"topic: {}, queueId: {}\", topic, queueId);\n                        return;\n                    default:\n                        dispatchOffset--;\n                        break;\n                }\n            }\n\n            Attributes attributes = TieredStoreMetricsManager.newAttributesBuilder()\n                .put(TieredStoreMetricsConstant.LABEL_TOPIC, mq.getTopic())\n                .put(TieredStoreMetricsConstant.LABEL_QUEUE_ID, mq.getQueueId())\n                .put(TieredStoreMetricsConstant.LABEL_FILE_TYPE, FileSegmentType.COMMIT_LOG.name().toLowerCase())\n                .build();\n\n            TieredStoreMetricsManager.messagesDispatchTotal.add(dispatchOffset - beforeOffset, attributes);\n        } finally {\n            flatFile.getCompositeFlatFileLock().unlock();\n        }\n\n        // If this queue dispatch falls too far, dispatch again immediately\n        if (flatFile.getDispatchOffset() < maxOffsetInQueue && !flatFile.getCompositeFlatFileLock().isLocked()) {\n            dispatchFlatFileAsync(flatFile);\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    protected void dispatchFlatFile(CompositeQueueFlatFile flatFile) {\n        if (stopped) {\n            return;\n        }\n\n        if (flatFile.getDispatchOffset() == -1L) {\n            return;\n        }\n\n        if (detectFallBehind(flatFile)) {\n            return;\n        }\n\n        MessageQueue mq = flatFile.getMessageQueue();\n        String topic = mq.getTopic();\n        int queueId = mq.getQueueId();\n\n        long beforeOffset = flatFile.getDispatchOffset();\n        long minOffsetInQueue = defaultStore.getMinOffsetInQueue(topic, queueId);\n        long maxOffsetInQueue = defaultStore.getMaxOffsetInQueue(topic, queueId);\n\n        // perhaps it was caused by local cq file corruption or ha truncation\n        if (beforeOffset >= maxOffsetInQueue) {\n            return;\n        }\n\n        try {\n            if (!flatFile.getCompositeFlatFileLock().tryLock(200, TimeUnit.MILLISECONDS)) {\n                return;\n            }\n        } catch (Exception e) {\n            logger.warn(\"TieredDispatcher#dispatchFlatFile: can not acquire flatFile lock, \" +\n                \"topic: {}, queueId: {}\", mq.getTopic(), mq.getQueueId(), e);\n            if (flatFile.getCompositeFlatFileLock().isLocked()) {\n                flatFile.getCompositeFlatFileLock().unlock();\n            }\n            return;\n        }\n\n        try {\n            long dispatchOffset = flatFile.getDispatchOffset();\n            if (dispatchOffset < minOffsetInQueue) {\n                // If the tiered storage feature is turned off midway,\n                // it may cause cq discontinuity, resulting in data loss here.\n                logger.warn(\"TieredDispatcher#dispatchFlatFile: dispatch offset is too small, \" +\n                        \"topic: {}, queueId: {}, dispatch offset: {}, local cq offset range {}-{}\",\n                    topic, queueId, dispatchOffset, minOffsetInQueue, maxOffsetInQueue);\n\n                // when dispatch offset is smaller than min offset in local cq\n                // some earliest messages may be lost at this time\n                tieredFlatFileManager.destroyCompositeFile(flatFile.getMessageQueue());\n                CompositeQueueFlatFile newFlatFile =\n                    tieredFlatFileManager.getOrCreateFlatFileIfAbsent(new MessageQueue(topic, brokerName, queueId));\n                if (newFlatFile != null) {\n                    newFlatFile.initOffset(maxOffsetInQueue);\n                }\n                return;\n            }\n            beforeOffset = dispatchOffset;\n\n            // flow control by max count, also we could do flow control based on message size\n            long maxCount = storeConfig.getTieredStoreGroupCommitCount();\n            long upperBound = Math.min(dispatchOffset + maxCount, maxOffsetInQueue);\n            ConsumeQueue consumeQueue = (ConsumeQueue) defaultStore.getConsumeQueue(topic, queueId);\n\n            logger.debug(\"DispatchFlatFile race, topic={}, queueId={}, cq range={}-{}, dispatch offset={}-{}\",\n                topic, queueId, minOffsetInQueue, maxOffsetInQueue, dispatchOffset, upperBound - 1);\n\n            for (; dispatchOffset < upperBound; dispatchOffset++) {\n                // get consume queue\n                SelectMappedBufferResult cqItem = consumeQueue.getIndexBuffer(dispatchOffset);\n                if (cqItem == null) {\n                    logger.error(\"[Bug] TieredDispatcher#dispatchFlatFile: cq item is null, \" +\n                            \"topic: {}, queueId: {}, dispatch offset: {}, local cq offset range {}-{}\",\n                        topic, queueId, dispatchOffset, minOffsetInQueue, maxOffsetInQueue);\n                    return;\n                }\n                long commitLogOffset = CQItemBufferUtil.getCommitLogOffset(cqItem.getByteBuffer());\n                int size = CQItemBufferUtil.getSize(cqItem.getByteBuffer());\n                long tagCode = CQItemBufferUtil.getTagCode(cqItem.getByteBuffer());\n                cqItem.release();\n\n                // get message\n                SelectMappedBufferResult message = defaultStore.selectOneMessageByOffset(commitLogOffset, size);\n                if (message == null) {\n                    logger.error(\"TieredDispatcher#dispatchFlatFile: get message from next store failed, \" +\n                            \"topic: {}, queueId: {}, commitLog offset: {}, size: {}\",\n                        topic, queueId, commitLogOffset, size);\n                    // not dispatch immediately\n                    return;\n                }\n\n                // append commitlog will increase dispatch offset here\n                AppendResult result = flatFile.appendCommitLog(message.getByteBuffer(), true);\n                long newCommitLogOffset = flatFile.getCommitLogMaxOffset() - message.getByteBuffer().remaining();\n                doRedispatchRequestToWriteMap(\n                    result, flatFile, dispatchOffset, newCommitLogOffset, size, tagCode, message.getByteBuffer());\n                message.release();\n\n                switch (result) {\n                    case SUCCESS:\n                        continue;\n                    case FILE_CLOSED:\n                        tieredFlatFileManager.destroyCompositeFile(flatFile.getMessageQueue());\n                        logger.info(\"TieredDispatcher#dispatchFlatFile: file has been close and destroy, \" +\n                            \"topic: {}, queueId: {}\", topic, queueId);\n                        return;\n                    default:\n                        dispatchOffset--;\n                        break;\n                }\n            }\n\n            Attributes attributes = TieredStoreMetricsManager.newAttributesBuilder()\n                .put(TieredStoreMetricsConstant.LABEL_TOPIC, mq.getTopic())\n                .put(TieredStoreMetricsConstant.LABEL_QUEUE_ID, mq.getQueueId())\n                .put(TieredStoreMetricsConstant.LABEL_FILE_TYPE, FileSegmentType.COMMIT_LOG.name().toLowerCase())\n                .build();\n\n            TieredStoreMetricsManager.messagesDispatchTotal.add(dispatchOffset - beforeOffset, attributes);\n        } finally {\n            flatFile.getCompositeFlatFileLock().unlock();\n        }\n\n        // If this queue dispatch falls too far, dispatch again immediately\n        if (flatFile.getDispatchOffset() < maxOffsetInQueue && !flatFile.getCompositeFlatFileLock().isLocked()) {\n            dispatchFlatFileAsync(flatFile);\n        }\n    }\n"
    ],
    "test_id": 59,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testDispatchByFlatFile() {\n    metadataStore.addQueue(mq, 6);\n    TieredFlatFileManager flatFileManager = TieredFlatFileManager.getInstance(storeConfig);\n    DefaultMessageStore defaultStore = Mockito.mock(DefaultMessageStore.class);\n    Mockito.when(defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).thenReturn(Mockito.mock(ConsumeQueue.class));\n    TieredDispatcher dispatcher = new TieredDispatcher(defaultStore, storeConfig);\n\n    Mockito.when(defaultStore.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(0L);\n    Mockito.when(defaultStore.getMaxOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(9L);\n\n    ByteBuffer cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);\n    cqItem.putLong(7);\n    cqItem.putInt(MessageBufferUtilTest.MSG_LEN);\n    cqItem.putLong(1);\n    cqItem.flip();\n    SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);\n    Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(6)).thenReturn(mockResult);\n\n    cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);\n    cqItem.putLong(8);\n    cqItem.putInt(MessageBufferUtilTest.MSG_LEN);\n    cqItem.putLong(1);\n    cqItem.flip();\n    mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);\n\n    Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(7)).thenReturn(mockResult);\n\n    mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMockedMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);\n    Mockito.when(defaultStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);\n\n    ByteBuffer msg = MessageBufferUtilTest.buildMockedMessageBuffer();\n    msg.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);\n    mockResult = new SelectMappedBufferResult(0, msg, MessageBufferUtilTest.MSG_LEN, null);\n    Mockito.when(defaultStore.selectOneMessageByOffset(8, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);\n\n    dispatcher.dispatchFlatFile(flatFileManager.getOrCreateFlatFileIfAbsent(mq));\n    Assert.assertEquals(8, flatFileManager.getFlatFile(mq).getDispatchOffset());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testDispatchByFlatFile() {\n    metadataStore.addQueue(mq, 6);\n    TieredFlatFileManager flatFileManager = TieredFlatFileManager.getInstance(storeConfig);\n    DefaultMessageStore defaultStore = Mockito.mock(DefaultMessageStore.class);\n    Mockito.when(defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).thenReturn(Mockito.mock(ConsumeQueue.class));\n    TieredDispatcher dispatcher = new TieredDispatcher(defaultStore, storeConfig);\n\n    Mockito.when(defaultStore.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(0L);\n    Mockito.when(defaultStore.getMaxOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(9L);\n\n    ByteBuffer cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);\n    cqItem.putLong(7);\n    cqItem.putInt(MessageBufferUtilTest.MSG_LEN);\n    cqItem.putLong(1);\n    cqItem.flip();\n    SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);\n    Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(6)).thenReturn(mockResult);\n\n    cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);\n    cqItem.putLong(8);\n    cqItem.putInt(MessageBufferUtilTest.MSG_LEN);\n    cqItem.putLong(1);\n    cqItem.flip();\n    mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);\n\n    Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(7)).thenReturn(mockResult);\n\n    mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMockedMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);\n    Mockito.when(defaultStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);\n\n    ByteBuffer msg = MessageBufferUtilTest.buildMockedMessageBuffer();\n    msg.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);\n    mockResult = new SelectMappedBufferResult(0, msg, MessageBufferUtilTest.MSG_LEN, null);\n    Mockito.when(defaultStore.selectOneMessageByOffset(8, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);\n\n    dispatcher.dispatchFlatFile(flatFileManager.getOrCreateFlatFileIfAbsent(mq));\n    Assert.assertEquals(8, flatFileManager.getFlatFile(mq).getDispatchOffset());\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "OutOfMemoryError('CUDA out of memory. Tried to allocate 10.12 GiB. GPU 0 has a total capacty of 23.69 GiB of which 7.15 GiB is free. Process 1478252 has 16.53 GiB memory in use. Of the allocated memory 8.95 GiB is allocated by PyTorch, and 6.55 GiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF')"
  },
  "60": {
    "commit_src": "bcba5a8e628e35086c699852388990ba8a4bdcf8",
    "commit_tgt": "b2deef179dbc6a9eb1a2b6dd7b652d95cb768295",
    "changed_tests": [
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/CompositeQueueFlatFileTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-7145",
    "test_src": ".org.apache.rocketmq.tieredstore.file.CompositeQueueFlatFileTest#testAppendConsumeQueue",
    "test_tgt": [
      ".org.apache.rocketmq.tieredstore.file.CompositeQueueFlatFileTest#testAppendConsumeQueue"
    ],
    "test_src_code": "    @Test\n    public void testAppendConsumeQueue() {\n        CompositeQueueFlatFile file = new CompositeQueueFlatFile(tieredFileAllocator, mq);\n        DispatchRequest request = new DispatchRequest(\n            mq.getTopic(), mq.getQueueId(), 51, 2, 3, 4);\n        AppendResult result = file.appendConsumeQueue(request);\n        Assert.assertEquals(AppendResult.OFFSET_INCORRECT, result);\n\n        // Create new segment in file queue\n        MemoryFileSegment segment = new MemoryFileSegment(FileSegmentType.CONSUME_QUEUE, mq, 20, storeConfig);\n        segment.initPosition(segment.getSize());\n        file.consumeQueue.getFlatFile().setBaseOffset(20L);\n        file.consumeQueue.getFlatFile().getFileToWrite();\n\n        // Recreate will load metadata and build consume queue\n        file = new CompositeQueueFlatFile(tieredFileAllocator, mq);\n        segment.initPosition(ConsumeQueue.CQ_STORE_UNIT_SIZE);\n        result = file.appendConsumeQueue(request);\n        Assert.assertEquals(AppendResult.SUCCESS, result);\n\n        request = new DispatchRequest(\n            mq.getTopic(), mq.getQueueId(), 52, 2, 3, 4);\n        result = file.appendConsumeQueue(request);\n        Assert.assertEquals(AppendResult.SUCCESS, result);\n\n        file.commit(true);\n        file.persistMetadata();\n\n        QueueMetadata queueMetadata = metadataStore.getQueue(mq);\n        Assert.assertEquals(53, queueMetadata.getMaxOffset());\n    }\n",
    "focal_path_src": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/CompositeQueueFlatFile.java#CompositeQueueFlatFile",
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/CompositeQueueFlatFile.java#persistMetadata"
    ],
    "focal_path_tgt": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/CompositeQueueFlatFile.java#CompositeQueueFlatFile"
    ],
    "focal_src": [
      "    public CompositeQueueFlatFile(TieredFileAllocator fileQueueFactory, MessageQueue messageQueue) {\n        super(fileQueueFactory, TieredStoreUtil.toPath(messageQueue));\n        this.messageQueue = messageQueue;\n        this.recoverTopicMetadata();\n        super.recoverMetadata();\n        this.indexFile = TieredFlatFileManager.getIndexFile(storeConfig);\n    }\n",
      "    public void persistMetadata() {\n        try {\n            if (consumeQueue.getCommitOffset() < queueMetadata.getMinOffset()) {\n                return;\n            }\n            queueMetadata.setMaxOffset(consumeQueue.getCommitOffset() / TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);\n            metadataStore.updateQueue(queueMetadata);\n        } catch (Exception e) {\n            LOGGER.error(\"CompositeFlatFile#flushMetadata: update queue metadata failed: topic: {}, queue: {}\", messageQueue.getTopic(), messageQueue.getQueueId(), e);\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    public CompositeQueueFlatFile(TieredFileAllocator fileQueueFactory, MessageQueue messageQueue) {\n        super(fileQueueFactory, TieredStoreUtil.toPath(messageQueue));\n        this.messageQueue = messageQueue;\n        this.recoverQueueMetadata();\n        this.indexFile = TieredFlatFileManager.getIndexFile(storeConfig);\n    }\n"
    ],
    "test_id": 60,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testAppendConsumeQueue() {\n    CompositeQueueFlatFile file = new CompositeQueueFlatFile(tieredFileAllocator, mq);\n    DispatchRequest request = new DispatchRequest(\n        mq.getTopic(), mq.getQueueId(), 51, 2, 3, 4);\n    AppendResult result = file.appendConsumeQueue(request);\n    Assert.assertEquals(AppendResult.OFFSET_INCORRECT, result);\n\n    // Create new segment in file queue\n    MemoryFileSegment segment = new MemoryFileSegment(FileSegmentType.CONSUME_QUEUE, mq, 20, storeConfig);\n    segment.initPosition(segment.getSize());\n    file.consumeQueue.getFlatFile().setBaseOffset(20L);\n    file.consumeQueue.getFlatFile().getFileToWrite();\n\n    // Recreate will load metadata and build consume queue\n    file = new CompositeQueueFlatFile(tieredFileAllocator, mq);\n    segment.initPosition(ConsumeQueue.CQ_STORE_UNIT_SIZE);\n    result = file.appendConsumeQueue(request);\n    Assert.assertEquals(AppendResult.SUCCESS, result);\n\n    request = new DispatchRequest(\n        mq.getTopic(), mq.getQueueId(), 52, 2, 3, 4);\n    result = file.appendConsumeQueue(request);\n    Assert.assertEquals(AppendResult.SUCCESS, result);\n\n    file.commit(true);\n    file.persistMetadata();\n\n    QueueMetadata queueMetadata = metadataStore.getQueue(mq);\n    Assert.assertEquals(53, queueMetadata.getMaxOffset());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testAppendConsumeQueue() {\n    CompositeQueueFlatFile file = new CompositeQueueFlatFile(tieredFileAllocator, mq);\n    DispatchRequest request = new DispatchRequest(\n        mq.getTopic(), mq.getQueueId(), 51, 2, 3, 4);\n    AppendResult result = file.appendConsumeQueue(request);\n    Assert.assertEquals(AppendResult.OFFSET_INCORRECT, result);\n\n    // Create new segment in file queue\n    MemoryFileSegment segment = new MemoryFileSegment(FileSegmentType.CONSUME_QUEUE, mq, 20, storeConfig);\n    segment.initPosition(segment.getSize());\n    file.consumeQueue.getFlatFile().setBaseOffset(20L);\n    file.consumeQueue.getFlatFile().getFileToWrite();\n\n    // Recreate will load metadata and build consume queue\n    file = new CompositeQueueFlatFile(tieredFileAllocator, mq);\n    segment.initPosition(ConsumeQueue.CQ_STORE_UNIT_SIZE);\n    result = file.appendConsumeQueue(request);\n    Assert.assertEquals(AppendResult.SUCCESS, result);\n\n    request = new DispatchRequest(\n        mq.getTopic(), mq.getQueueId(), 52, 2, 3, 4);\n    result = file.appendConsumeQueue(request);\n    Assert.assertEquals(AppendResult.SUCCESS, result);\n\n    file.commit(true);\n    file.persistMetadata();\n\n    QueueMetadata queueMetadata = metadataStore.getQueue(mq);\n    Assert.assertEquals(53, queueMetadata.getMaxOffset());\n}\n"
    ]
  },
  "61": {
    "commit_src": "bcba5a8e628e35086c699852388990ba8a4bdcf8",
    "commit_tgt": "b2deef179dbc6a9eb1a2b6dd7b652d95cb768295",
    "changed_tests": [
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/CompositeQueueFlatFileTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-7145",
    "test_src": ".org.apache.rocketmq.tieredstore.file.TieredFlatFileManagerTest#testLoadAndDestroy",
    "test_tgt": [
      ".org.apache.rocketmq.tieredstore.file.TieredFlatFileManagerTest#testLoadAndDestroy"
    ],
    "test_src_code": "    @Test\n    public void testLoadAndDestroy() {\n        metadataStore.addTopic(mq.getTopic(), 0);\n        metadataStore.addQueue(mq, 100);\n        MessageQueue mq1 = new MessageQueue(mq.getTopic(), mq.getBrokerName(), 1);\n        metadataStore.addQueue(mq1, 200);\n        TieredFlatFileManager flatFileManager = TieredFlatFileManager.getInstance(storeConfig);\n        boolean load = flatFileManager.load();\n        Assert.assertTrue(load);\n\n        Awaitility.await()\n            .atMost(3, TimeUnit.SECONDS)\n            .until(() -> flatFileManager.deepCopyFlatFileToList().size() == 2);\n\n        CompositeFlatFile flatFile = flatFileManager.getFlatFile(mq);\n        Assert.assertNotNull(flatFile);\n        Assert.assertEquals(100, flatFile.getDispatchOffset());\n\n        CompositeFlatFile flatFile1 = flatFileManager.getFlatFile(mq1);\n        Assert.assertNotNull(flatFile1);\n        Assert.assertEquals(200, flatFile1.getDispatchOffset());\n\n        flatFileManager.destroyCompositeFile(mq);\n        Assert.assertTrue(flatFile.isClosed());\n        Assert.assertNull(flatFileManager.getFlatFile(mq));\n        Assert.assertNull(metadataStore.getQueue(mq));\n\n        flatFileManager.destroy();\n        Assert.assertTrue(flatFile1.isClosed());\n        Assert.assertNull(flatFileManager.getFlatFile(mq1));\n        Assert.assertNull(metadataStore.getQueue(mq1));\n    }\n",
    "focal_path_src": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManager.java#getInstance",
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManager.java#load",
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManager.java#getFlatFile",
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManager.java#deepCopyFlatFileToList",
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManager.java#destroyCompositeFile"
    ],
    "focal_path_tgt": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManager.java#getInstance",
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManager.java#load",
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManager.java#getFlatFile",
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManager.java#deepCopyFlatFileToList",
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileManager.java#destroyCompositeFile"
    ],
    "focal_src": [
      "    public static TieredFlatFileManager getInstance(TieredMessageStoreConfig storeConfig) {\n        if (storeConfig == null) {\n            return instance;\n        }\n\n        if (instance == null) {\n            synchronized (TieredFlatFileManager.class) {\n                if (instance == null) {\n                    try {\n                        instance = new TieredFlatFileManager(storeConfig);\n                    } catch (Exception e) {\n                        logger.error(\"TieredFlatFileManager#getInstance: create flat file manager failed\", e);\n                    }\n                }\n            }\n        }\n        return instance;\n    }\n",
      "    public boolean load() {\n        try {\n            AtomicLong topicSequenceNumber = new AtomicLong();\n            List<Future<?>> futureList = new ArrayList<>();\n            queueFlatFileMap.clear();\n            metadataStore.iterateTopic(topicMetadata -> {\n                topicSequenceNumber.set(Math.max(topicSequenceNumber.get(), topicMetadata.getTopicId()));\n                Future<?> future = TieredStoreExecutor.dispatchExecutor.submit(() -> {\n                    if (topicMetadata.getStatus() != 0) {\n                        return;\n                    }\n                    try {\n                        metadataStore.iterateQueue(topicMetadata.getTopic(),\n                            queueMetadata -> getOrCreateFlatFileIfAbsent(\n                                new MessageQueue(topicMetadata.getTopic(),\n                                    storeConfig.getBrokerName(),\n                                    queueMetadata.getQueue().getQueueId())));\n                    } catch (Exception e) {\n                        logger.error(\"load mq composite flat file from metadata failed\", e);\n                    }\n                });\n                futureList.add(future);\n            });\n\n            // Wait for load all metadata done\n            for (Future<?> future : futureList) {\n                future.get();\n            }\n            metadataStore.setTopicSequenceNumber(topicSequenceNumber.incrementAndGet());\n        } catch (Exception e) {\n            logger.error(\"load mq composite flat file from metadata failed\", e);\n            return false;\n        }\n        return true;\n    }\n",
      "    public CompositeQueueFlatFile getFlatFile(MessageQueue messageQueue) {\n        return queueFlatFileMap.get(messageQueue);\n    }\n",
      "    public ImmutableList<CompositeQueueFlatFile> deepCopyFlatFileToList() {\n        return ImmutableList.copyOf(queueFlatFileMap.values());\n    }\n",
      "    public void destroyCompositeFile(MessageQueue mq) {\n        if (mq == null) {\n            return;\n        }\n\n        // delete memory reference\n        CompositeQueueFlatFile flatFile = queueFlatFileMap.remove(mq);\n        if (flatFile != null) {\n            MessageQueue messageQueue = flatFile.getMessageQueue();\n            logger.info(\"TieredFlatFileManager#destroyCompositeFile: \" +\n                    \"try to destroy composite flat file: topic: {}, queueId: {}\",\n                messageQueue.getTopic(), messageQueue.getQueueId());\n\n            // delete queue metadata\n            flatFile.destroy();\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    public static TieredFlatFileManager getInstance(TieredMessageStoreConfig storeConfig) {\n        if (storeConfig == null || instance != null) {\n            return instance;\n        }\n        synchronized (TieredFlatFileManager.class) {\n            if (instance == null) {\n                try {\n                    instance = new TieredFlatFileManager(storeConfig);\n                } catch (Exception e) {\n                    logger.error(\"Construct FlatFileManager instance error\", e);\n                }\n            }\n        }\n        return instance;\n    }\n",
      "    public boolean load() {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        try {\n            flatFileConcurrentMap.clear();\n            this.recoverSequenceNumber();\n            this.recoverTieredFlatFile();\n            logger.info(\"Message store recover end, total cost={}ms\", stopwatch.elapsed(TimeUnit.MILLISECONDS));\n        } catch (Exception e) {\n            long costTime = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n            logger.info(\"Message store recover error, total cost={}ms\", costTime);\n            BROKER_LOG.error(\"Message store recover error, total cost={}ms\", costTime, e);\n            return false;\n        }\n        return true;\n    }\n",
      "    public CompositeQueueFlatFile getFlatFile(MessageQueue messageQueue) {\n        return flatFileConcurrentMap.get(messageQueue);\n    }\n",
      "    public ImmutableList<CompositeQueueFlatFile> deepCopyFlatFileToList() {\n        return ImmutableList.copyOf(flatFileConcurrentMap.values());\n    }\n",
      "    public void destroyCompositeFile(MessageQueue mq) {\n        if (mq == null) {\n            return;\n        }\n\n        // delete memory reference\n        CompositeQueueFlatFile flatFile = flatFileConcurrentMap.remove(mq);\n        if (flatFile != null) {\n            MessageQueue messageQueue = flatFile.getMessageQueue();\n            logger.info(\"TieredFlatFileManager#destroyCompositeFile: \" +\n                    \"try to destroy composite flat file: topic: {}, queueId: {}\",\n                messageQueue.getTopic(), messageQueue.getQueueId());\n\n            // delete queue metadata\n            flatFile.destroy();\n        }\n    }\n"
    ],
    "test_id": 61,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testLoadAndDestroy() {\n    metadataStore.addTopic(mq.getTopic(), 0);\n    metadataStore.addQueue(mq, 100);\n    MessageQueue mq1 = new MessageQueue(mq.getTopic(), mq.getBrokerName(), 1);\n    metadataStore.addQueue(mq1, 200);\n    TieredFlatFileManager flatFileManager = TieredFlatFileManager.getInstance(storeConfig);\n    boolean load = flatFileManager.load();\n    Assert.assertTrue(load);\n\n    Awaitility.await()\n        .atMost(3, TimeUnit.SECONDS)\n        .until(() -> flatFileManager.deepCopyFlatFileToList().size() == 2);\n\n    CompositeFlatFile flatFile = flatFileManager.getFlatFile(mq);\n    Assert.assertNotNull(flatFile);\n    Assert.assertEquals(100, flatFile.getDispatchOffset());\n\n    CompositeFlatFile flatFile1 = flatFileManager.getFlatFile(mq1);\n    Assert.assertNotNull(flatFile1);\n    Assert.assertEquals(200, flatFile1.getDispatchOffset());\n\n    flatFileManager.destroyCompositeFile(mq);\n    Assert.assertTrue(flatFile.isClosed());\n    Assert.assertNull(flatFileManager.getFlatFile(mq));\n    Assert.assertNull(metadataStore.getQueue(mq));\n\n    flatFileManager.destroy();\n    Assert.assertTrue(flatFile1.isClosed());\n    Assert.assertNull(flatFileManager.getFlatFile(mq1));\n    Assert.assertNull(metadataStore.getQueue(mq1));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testLoadAndDestroy() {\n    metadataStore.addTopic(mq.getTopic(), 0);\n    metadataStore.addQueue(mq, 100);\n    MessageQueue mq1 = new MessageQueue(mq.getTopic(), mq.getBrokerName(), 1);\n    metadataStore.addQueue(mq1, 200);\n    TieredFlatFileManager flatFileManager = TieredFlatFileManager.getInstance(storeConfig);\n    boolean load = flatFileManager.load();\n    Assert.assertTrue(load);\n\n    Awaitility.await()\n        .atMost(3, TimeUnit.SECONDS)\n        .until(() -> flatFileManager.deepCopyFlatFileToList().size() == 2);\n\n    CompositeFlatFile flatFile = flatFileManager.getFlatFile(mq);\n    Assert.assertNotNull(flatFile);\n    Assert.assertEquals(100, flatFile.getDispatchOffset());\n\n    CompositeFlatFile flatFile1 = flatFileManager.getFlatFile(mq1);\n    Assert.assertNotNull(flatFile1);\n    Assert.assertEquals(200, flatFile1.getDispatchOffset());\n\n    flatFileManager.destroyCompositeFile(mq);\n    Assert.assertTrue(flatFile.isClosed());\n    Assert.assertNull(flatFileManager.getFlatFile(mq));\n    Assert.assertNull(metadataStore.getQueue(mq));\n\n    flatFileManager.destroy();\n    Assert.assertTrue(flatFile1.isClosed());\n    Assert.assertNull(flatFileManager.getFlatFile(mq1));\n    Assert.assertNull(metadataStore.getQueue(mq1));\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "IndexError('list index out of range')"
  },
  "62": {
    "commit_src": "017ad110475e8024585327b44f47e5e97aabc63b",
    "commit_tgt": "77e8e54b37c3fc3ea0beffc1ace6f5bf20af10d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/AckMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/BaseProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/mqclient/MQClientAPIExtTest.java"
    ],
    "refer_PR": "apache_rocketmq-7225",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.consumer.AckMessageActivityTest#testAckMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.AckMessageActivityTest#testAckMessage",
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.AckMessageActivityTest#testAckMessageInBatch"
    ],
    "test_src_code": "    @Test\n    public void testAckMessage() throws Throwable {\n        when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n            .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n        AckResult msg2AckResult = new AckResult();\n        msg2AckResult.setStatus(AckStatus.OK);\n        when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n            .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n        AckResult msg3AckResult = new AckResult();\n        msg3AckResult.setStatus(AckStatus.NO_EXIST);\n        when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n            .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n        AckMessageResponse response = this.ackMessageActivity.ackMessage(\n            createContext(),\n            AckMessageRequest.newBuilder()\n                .setTopic(Resource.newBuilder().setName(TOPIC).build())\n                .setGroup(Resource.newBuilder().setName(GROUP).build())\n                .addEntries(AckMessageEntry.newBuilder()\n                    .setMessageId(\"msg1\")\n                    .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                    .build())\n                .addEntries(AckMessageEntry.newBuilder()\n                    .setMessageId(\"msg2\")\n                    .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                    .build())\n                .addEntries(AckMessageEntry.newBuilder()\n                    .setMessageId(\"msg3\")\n                    .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                    .build())\n                .build()\n        ).get();\n\n        assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n        assertEquals(3, response.getEntriesCount());\n        assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n        assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n        assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n    }\n",
    "focal_path_src": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/AckMessageActivity.java#ackMessage"
    ],
    "focal_path_tgt": [
      "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/AckMessageActivity.java#ackMessage"
    ],
    "focal_src": [
      "    public CompletableFuture<AckMessageResponse> ackMessage(ProxyContext ctx, AckMessageRequest request) {\n        CompletableFuture<AckMessageResponse> future = new CompletableFuture<>();\n\n        try {\n            validateTopicAndConsumerGroup(request.getTopic(), request.getGroup());\n\n            CompletableFuture<AckMessageResultEntry>[] futures = new CompletableFuture[request.getEntriesCount()];\n            for (int i = 0; i < request.getEntriesCount(); i++) {\n                futures[i] = processAckMessage(ctx, request, request.getEntries(i));\n            }\n            CompletableFuture.allOf(futures).whenComplete((val, throwable) -> {\n                if (throwable != null) {\n                    future.completeExceptionally(throwable);\n                    return;\n                }\n\n                Set<Code> responseCodes = new HashSet<>();\n                List<AckMessageResultEntry> entryList = new ArrayList<>();\n                for (CompletableFuture<AckMessageResultEntry> entryFuture : futures) {\n                    AckMessageResultEntry entryResult = entryFuture.join();\n                    responseCodes.add(entryResult.getStatus().getCode());\n                    entryList.add(entryResult);\n                }\n                AckMessageResponse.Builder responseBuilder = AckMessageResponse.newBuilder()\n                    .addAllEntries(entryList);\n                if (responseCodes.size() > 1) {\n                    responseBuilder.setStatus(ResponseBuilder.getInstance().buildStatus(Code.MULTIPLE_RESULTS, Code.MULTIPLE_RESULTS.name()));\n                } else if (responseCodes.size() == 1) {\n                    Code code = responseCodes.stream().findAny().get();\n                    responseBuilder.setStatus(ResponseBuilder.getInstance().buildStatus(code, code.name()));\n                } else {\n                    responseBuilder.setStatus(ResponseBuilder.getInstance().buildStatus(Code.INTERNAL_SERVER_ERROR, \"ack message result is empty\"));\n                }\n                future.complete(responseBuilder.build());\n            });\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n"
    ],
    "focal_tgt": [
      "    public CompletableFuture<AckMessageResponse> ackMessage(ProxyContext ctx, AckMessageRequest request) {\n        CompletableFuture<AckMessageResponse> future = new CompletableFuture<>();\n\n        try {\n            validateTopicAndConsumerGroup(request.getTopic(), request.getGroup());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getTopic());\n            if (ConfigurationManager.getProxyConfig().isEnableBatchAck()) {\n                future = ackMessageInBatch(ctx, group, topic, request);\n            } else {\n                future = ackMessageOneByOne(ctx, group, topic, request);\n            }\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n"
    ],
    "test_id": 62,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testAckMessage() throws Throwable {\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n        .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n    AckResult msg2AckResult = new AckResult();\n    msg2AckResult.setStatus(AckStatus.OK);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n    AckResult msg3AckResult = new AckResult();\n    msg3AckResult.setStatus(AckStatus.NO_EXIST);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n    AckMessageResponse response = this.ackMessageActivity.ackMessage(\n        createContext(),\n        AckMessageRequest.newBuilder()\n            .setTopic(Resource.newBuilder().setName(TOPIC).build())\n            .setGroup(Resource.newBuilder().setName(GROUP).build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg1\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg2\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg3\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .build()\n    ).get();\n\n    assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n    assertEquals(3, response.getEntriesCount());\n    assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n    assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n    assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n}\n",
      "@Test\npublic void testAckMessage() throws Throwable {\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n        .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n    AckResult msg2AckResult = new AckResult();\n    msg2AckResult.setStatus(AckStatus.OK);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n    AckResult msg3AckResult = new AckResult();\n    msg3AckResult.setStatus(AckStatus.NO_EXIST);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n    AckMessageResponse response = this.ackMessageActivity.ackMessage(\n        createContext(),\n        AckMessageRequest.newBuilder()\n            .setTopic(Resource.newBuilder().setName(TOPIC).build())\n            .setGroup(Resource.newBuilder().setName(GROUP).build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg1\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg2\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg3\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .build()\n    ).get();\n\n    assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n    assertEquals(3, response.getEntriesCount());\n    assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n    assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n    assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n}\n",
      "@Test\npublic void testAckMessage() throws Throwable {\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n        .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n    AckResult msg2AckResult = new AckResult();\n    msg2AckResult.setStatus(AckStatus.OK);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n    AckResult msg3AckResult = new AckResult();\n    msg3AckResult.setStatus(AckStatus.NO_EXIST);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n    AckMessageResponse response = this.ackMessageActivity.ackMessage(\n        createContext(),\n        AckMessageRequest.newBuilder()\n            .setTopic(Resource.newBuilder().setName(TOPIC).build())\n            .setGroup(Resource.newBuilder().setName(GROUP).build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg1\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg2\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg3\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .build()\n    ).get();\n\n    assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n    assertEquals(3, response.getEntriesCount());\n    assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n    assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n    assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n}\n",
      "@Test\npublic void testAckMessage() throws Throwable {\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n        .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n    AckResult msg2AckResult = new AckResult();\n    msg2AckResult.setStatus(AckStatus.OK);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n    AckResult msg3AckResult = new AckResult();\n    msg3AckResult.setStatus(AckStatus.NO_EXIST);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n    AckMessageResponse response = this.ackMessageActivity.ackMessage(\n        createContext(),\n        AckMessageRequest.newBuilder()\n            .setTopic(Resource.newBuilder().setName(TOPIC).build())\n            .setGroup(Resource.newBuilder().setName(GROUP).build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg1\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg2\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg3\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .build()\n    ).get();\n\n    assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n    assertEquals(3, response.getEntriesCount());\n    assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n    assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n    assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n}\n",
      "@Test\npublic void testAckMessage() throws Throwable {\n    // Mock the behavior of the old methods\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n        .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n    AckResult msg2AckResult = new AckResult();\n    msg2AckResult.setStatus(AckStatus.OK);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n    AckResult msg3AckResult = new AckResult();\n    msg3AckResult.setStatus(AckStatus.NO_EXIST);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n    // Invoke the new ackMessage method\n    AckMessageResponse response = this.ackMessageActivity.ackMessage(\n        createContext(),\n        AckMessageRequest.newBuilder()\n            .setTopic(Resource.newBuilder().setName(TOPIC).build())\n            .setGroup(Resource.newBuilder().setName(GROUP).build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg1\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg2\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg3\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .build()\n    ).get();\n\n    // Assert the result\n    assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n    assertEquals(3, response.getEntriesCount());\n    assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n    assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n    assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testAckMessage() throws Throwable {\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n        .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n    AckResult msg2AckResult = new AckResult();\n    msg2AckResult.setStatus(AckStatus.OK);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n    AckResult msg3AckResult = new AckResult();\n    msg3AckResult.setStatus(AckStatus.NO_EXIST);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n    AckMessageResponse response = this.ackMessageActivity.ackMessage(\n        createContext(),\n        AckMessageRequest.newBuilder()\n            .setTopic(Resource.newBuilder().setName(TOPIC).build())\n            .setGroup(Resource.newBuilder().setName(GROUP).build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg1\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg2\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg3\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .build()\n    ).get();\n\n    assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n    assertEquals(3, response.getEntriesCount());\n    assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n    assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n    assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n}\n",
      "@Test\npublic void testAckMessage() throws Throwable {\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n        .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n    AckResult msg2AckResult = new AckResult();\n    msg2AckResult.setStatus(AckStatus.OK);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n    AckResult msg3AckResult = new AckResult();\n    msg3AckResult.setStatus(AckStatus.NO_EXIST);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n    AckMessageResponse response = this.ackMessageActivity.ackMessage(\n        createContext(),\n        AckMessageRequest.newBuilder()\n            .setTopic(Resource.newBuilder().setName(TOPIC).build())\n            .setGroup(Resource.newBuilder().setName(GROUP).build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg1\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg2\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg3\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .build()\n    ).get();\n\n    assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n    assertEquals(3, response.getEntriesCount());\n    assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n    assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n    assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n}\n",
      "@Test\npublic void testAckMessage() throws Throwable {\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n        .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n    AckResult msg2AckResult = new AckResult();\n    msg2AckResult.setStatus(AckStatus.OK);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n    AckResult msg3AckResult = new AckResult();\n    msg3AckResult.setStatus(AckStatus.NO_EXIST);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n    AckMessageResponse response = this.ackMessageActivity.ackMessage(\n        createContext(),\n        AckMessageRequest.newBuilder()\n            .setTopic(Resource.newBuilder().setName(TOPIC).build())\n            .setGroup(Resource.newBuilder().setName(GROUP).build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg1\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg2\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg3\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .build()\n    ).get();\n\n    assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n    assertEquals(3, response.getEntriesCount());\n    assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n    assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n    assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n}\n",
      "@Test\npublic void testAckMessage() throws Throwable {\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n        .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n    AckResult msg2AckResult = new AckResult();\n    msg2AckResult.setStatus(AckStatus.OK);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n    AckResult msg3AckResult = new AckResult();\n    msg3AckResult.setStatus(AckStatus.NO_EXIST);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n    AckMessageResponse response = this.ackMessageActivity.ackMessage(\n        createContext(),\n        AckMessageRequest.newBuilder()\n            .setTopic(Resource.newBuilder().setName(TOPIC).build())\n            .setGroup(Resource.newBuilder().setName(GROUP).build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg1\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg2\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg3\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .build()\n    ).get();\n\n    assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n    assertEquals(3, response.getEntriesCount());\n    assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n    assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n    assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n}\n",
      "@Test\npublic void testAckMessage() throws Throwable {\n    // Mock the behavior of the old methods\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n        .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n    AckResult msg2AckResult = new AckResult();\n    msg2AckResult.setStatus(AckStatus.OK);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n    AckResult msg3AckResult = new AckResult();\n    msg3AckResult.setStatus(AckStatus.NO_EXIST);\n    when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n        .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n    // Invoke the new ackMessage method\n    AckMessageResponse response = this.ackMessageActivity.ackMessage(\n        createContext(),\n        AckMessageRequest.newBuilder()\n            .setTopic(Resource.newBuilder().setName(TOPIC).build())\n            .setGroup(Resource.newBuilder().setName(GROUP).build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg1\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg2\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .addEntries(AckMessageEntry.newBuilder()\n                .setMessageId(\"msg3\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build())\n            .build()\n    ).get();\n\n    // Assert the result\n    assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n    assertEquals(3, response.getEntriesCount());\n    assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n    assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n    assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n}\n"
    ]
  },
  "63": {
    "commit_src": "bd0e9c09db9748f7f74a0c707579142dccf30afc",
    "commit_tgt": "c78061bf6ca5f35452510ec4107c46735c51c316",
    "changed_tests": [
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/TieredFlatFileTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/TieredIndexFileTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/MockFileSegmentInputStream.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentInputStreamTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/MemoryFileSegment.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/MemoryFileSegmentWithoutCheck.java"
    ],
    "refer_PR": "apache_rocketmq-7281",
    "test_src": ".org.apache.rocketmq.tieredstore.provider.TieredFileSegmentTest#testCommitFailed",
    "test_tgt": [
      ".org.apache.rocketmq.tieredstore.provider.TieredFileSegmentTest#testCommitFailedThenSuccess",
      ".org.apache.rocketmq.tieredstore.provider.TieredFileSegmentTest#testCommitFailed3Times"
    ],
    "test_src_code": "    @Test\n    public void testCommitFailed() {\n        long startTime = System.currentTimeMillis();\n        MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n        long lastSize = segment.getSize();\n        segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n        segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n        segment.blocker = new CompletableFuture<>();\n        new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                Assert.fail(e.getMessage());\n            }\n            ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n            buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n            segment.append(buffer, 0);\n            segment.blocker.complete(false);\n        }).start();\n\n        segment.commit();\n        segment.blocker.join();\n\n        segment.blocker = new CompletableFuture<>();\n        segment.blocker.complete(true);\n        segment.commit();\n\n        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n        ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n        Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n        ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n        ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n    }\n",
    "focal_path_src": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegment.java#append"
    ],
    "focal_path_tgt": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegment.java#append"
    ],
    "focal_src": [
      "    @SuppressWarnings(\"NonAtomicOperationOnVolatileField\")\n    public AppendResult append(ByteBuffer byteBuf, long timeStamp) {\n        if (closed) {\n            return AppendResult.FILE_CLOSED;\n        }\n        bufferLock.lock();\n        try {\n            if (full || codaBuffer != null) {\n                return AppendResult.FILE_FULL;\n            }\n\n            if (fileType == FileSegmentType.INDEX) {\n                minTimestamp = byteBuf.getLong(TieredIndexFile.INDEX_FILE_HEADER_BEGIN_TIME_STAMP_POSITION);\n                maxTimestamp = byteBuf.getLong(TieredIndexFile.INDEX_FILE_HEADER_END_TIME_STAMP_POSITION);\n                appendPosition += byteBuf.remaining();\n                uploadBufferList.add(byteBuf);\n                setFull();\n                return AppendResult.SUCCESS;\n            }\n\n            if (appendPosition + byteBuf.remaining() > maxSize) {\n                setFull();\n                return AppendResult.FILE_FULL;\n            }\n            if (uploadBufferList.size() > storeConfig.getTieredStoreGroupCommitCount()\n                || appendPosition - commitPosition > storeConfig.getTieredStoreGroupCommitSize()) {\n                commitAsync();\n            }\n            if (uploadBufferList.size() > storeConfig.getTieredStoreMaxGroupCommitCount()) {\n                logger.debug(\"TieredFileSegment#append: buffer full: file: {}, upload buffer size: {}\",\n                    getPath(), uploadBufferList.size());\n                return AppendResult.BUFFER_FULL;\n            }\n            if (timeStamp != Long.MAX_VALUE) {\n                maxTimestamp = timeStamp;\n                if (minTimestamp == Long.MAX_VALUE) {\n                    minTimestamp = timeStamp;\n                }\n            }\n            appendPosition += byteBuf.remaining();\n            uploadBufferList.add(byteBuf);\n            return AppendResult.SUCCESS;\n        } finally {\n            bufferLock.unlock();\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    @SuppressWarnings(\"NonAtomicOperationOnVolatileField\")\n    public AppendResult append(ByteBuffer byteBuf, long timestamp) {\n        if (closed) {\n            return AppendResult.FILE_CLOSED;\n        }\n\n        bufferLock.lock();\n        try {\n            if (full || codaBuffer != null) {\n                return AppendResult.FILE_FULL;\n            }\n\n            if (fileType == FileSegmentType.INDEX) {\n                minTimestamp = byteBuf.getLong(TieredIndexFile.INDEX_FILE_HEADER_BEGIN_TIME_STAMP_POSITION);\n                maxTimestamp = byteBuf.getLong(TieredIndexFile.INDEX_FILE_HEADER_END_TIME_STAMP_POSITION);\n                appendPosition += byteBuf.remaining();\n                // IndexFile is large and not change after compaction, no need deep copy\n                bufferList.add(byteBuf);\n                setFull();\n                return AppendResult.SUCCESS;\n            }\n\n            if (appendPosition + byteBuf.remaining() > maxSize) {\n                setFull();\n                return AppendResult.FILE_FULL;\n            }\n\n            if (bufferList.size() > storeConfig.getTieredStoreGroupCommitCount()\n                || appendPosition - commitPosition > storeConfig.getTieredStoreGroupCommitSize()) {\n                commitAsync();\n            }\n\n            if (bufferList.size() > storeConfig.getTieredStoreMaxGroupCommitCount()) {\n                logger.debug(\"File segment append buffer full, file: {}, buffer size: {}, pending bytes: {}\",\n                    getPath(), bufferList.size(), appendPosition - commitPosition);\n                return AppendResult.BUFFER_FULL;\n            }\n\n            if (timestamp != Long.MAX_VALUE) {\n                maxTimestamp = timestamp;\n                if (minTimestamp == Long.MAX_VALUE) {\n                    minTimestamp = timestamp;\n                }\n            }\n\n            appendPosition += byteBuf.remaining();\n\n            // deep copy buffer\n            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(byteBuf.remaining());\n            byteBuffer.put(byteBuf);\n            byteBuffer.flip();\n            byteBuf.rewind();\n\n            bufferList.add(byteBuffer);\n            return AppendResult.SUCCESS;\n        } finally {\n            bufferLock.unlock();\n        }\n    }\n"
    ],
    "test_id": 63,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testCommitFailed() {\n    long startTime = System.currentTimeMillis();\n    MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n    long lastSize = segment.getSize();\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n    segment.blocker = new CompletableFuture<>();\n    new Thread(() -> {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Assert.fail(e.getMessage());\n        }\n        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n        segment.append(buffer, 0);\n        segment.blocker.complete(false);\n    }).start();\n\n    segment.commit();\n    segment.blocker.join();\n\n    segment.blocker = new CompletableFuture<>();\n    segment.blocker.complete(true);\n    segment.commit();\n\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n    ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n    ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n    ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n}\n",
      "@Test\npublic void testCommitFailed() {\n    long startTime = System.currentTimeMillis();\n    MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n    long lastSize = segment.getSize();\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n    segment.blocker = new CompletableFuture<>();\n    new Thread(() -> {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Assert.fail(e.getMessage());\n        }\n        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n        segment.append(buffer, 0);\n        segment.blocker.complete(false);\n    }).start();\n\n    segment.commit();\n    segment.blocker.join();\n\n    segment.blocker = new CompletableFuture<>();\n    segment.blocker.complete(true);\n    segment.commit();\n\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n    ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n    ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n    ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n}\n",
      "@Test\npublic void testCommitFailed() {\n    long startTime = System.currentTimeMillis();\n    MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n    long lastSize = segment.getSize();\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n    segment.blocker = new CompletableFuture<>();\n    new Thread(() -> {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Assert.fail(e.getMessage());\n        }\n        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n        segment.append(buffer, 0);\n        segment.blocker.complete(false);\n    }).start();\n\n    segment.commit();\n    segment.blocker.join();\n\n    segment.blocker = new CompletableFuture<>();\n    segment.blocker.complete(true);\n    segment.commit();\n\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n    ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n    ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n    ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n}\n",
      "@Test\npublic void testCommitFailed() {\n    long startTime = System.currentTimeMillis();\n    MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n    long lastSize = segment.getSize();\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n    segment.blocker = new CompletableFuture<>();\n    new Thread(() -> {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Assert.fail(e.getMessage());\n        }\n        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n        segment.append(buffer, 0);\n        segment.blocker.complete(false);\n    }).start();\n\n    segment.commit();\n    segment.blocker.join();\n\n    segment.blocker = new CompletableFuture<>();\n    segment.blocker.complete(true);\n    segment.commit();\n\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n    ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n    ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n    ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n}\n",
      "@Test\npublic void testCommitFailed() {\n    long startTime = System.currentTimeMillis();\n    MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n    long lastSize = segment.getSize();\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n    segment.blocker = new CompletableFuture<>();\n    new Thread(() -> {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Assert.fail(e.getMessage());\n        }\n        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n        segment.append(buffer, 0);\n        segment.blocker.complete(false);\n    }).start();\n\n    segment.commit();\n    segment.blocker.join();\n\n    segment.blocker = new CompletableFuture<>();\n    segment.blocker.complete(true);\n    segment.commit();\n\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n    ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n    ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n    ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testCommitFailed() {\n    long startTime = System.currentTimeMillis();\n    MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n    long lastSize = segment.getSize();\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n    segment.blocker = new CompletableFuture<>();\n    new Thread(() -> {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Assert.fail(e.getMessage());\n        }\n        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n        segment.append(buffer, 0);\n        segment.blocker.complete(false);\n    }).start();\n\n    segment.commit();\n    segment.blocker.join();\n\n    segment.blocker = new CompletableFuture<>();\n    segment.blocker.complete(true);\n    segment.commit();\n\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n    ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n    ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n    ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n}\n",
      "@Test\npublic void testCommitFailed() {\n    long startTime = System.currentTimeMillis();\n    MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n    long lastSize = segment.getSize();\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n    segment.blocker = new CompletableFuture<>();\n    new Thread(() -> {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Assert.fail(e.getMessage());\n        }\n        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n        segment.append(buffer, 0);\n        segment.blocker.complete(false);\n    }).start();\n\n    segment.commit();\n    segment.blocker.join();\n\n    segment.blocker = new CompletableFuture<>();\n    segment.blocker.complete(true);\n    segment.commit();\n\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n    ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n    ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n    ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n}\n",
      "@Test\npublic void testCommitFailed() {\n    long startTime = System.currentTimeMillis();\n    MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n    long lastSize = segment.getSize();\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n    segment.blocker = new CompletableFuture<>();\n    new Thread(() -> {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Assert.fail(e.getMessage());\n        }\n        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n        segment.append(buffer, 0);\n        segment.blocker.complete(false);\n    }).start();\n\n    segment.commit();\n    segment.blocker.join();\n\n    segment.blocker = new CompletableFuture<>();\n    segment.blocker.complete(true);\n    segment.commit();\n\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n    ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n    ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n    ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n}\n",
      "@Test\npublic void testCommitFailed() {\n    long startTime = System.currentTimeMillis();\n    MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n    long lastSize = segment.getSize();\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n    segment.blocker = new CompletableFuture<>();\n    new Thread(() -> {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Assert.fail(e.getMessage());\n        }\n        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n        segment.append(buffer, 0);\n        segment.blocker.complete(false);\n    }).start();\n\n    segment.commit();\n    segment.blocker.join();\n\n    segment.blocker = new CompletableFuture<>();\n    segment.blocker.complete(true);\n    segment.commit();\n\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n    ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n    ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n    ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n}\n",
      "@Test\npublic void testCommitFailed() {\n    long startTime = System.currentTimeMillis();\n    MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(FileSegmentType.COMMIT_LOG);\n    long lastSize = segment.getSize();\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n    segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);\n\n    segment.blocker = new CompletableFuture<>();\n    new Thread(() -> {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Assert.fail(e.getMessage());\n        }\n        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);\n        segment.append(buffer, 0);\n        segment.blocker.complete(false);\n    }).start();\n\n    segment.commit();\n    segment.blocker.join();\n\n    segment.blocker = new CompletableFuture<>();\n    segment.blocker.complete(true);\n    segment.commit();\n\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());\n\n    ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));\n\n    ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));\n\n    ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);\n    Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));\n}\n"
    ]
  },
  "64": {
    "commit_src": "c36bb78e850129b9db40adc5b0e1b9bfd5c8fd2e",
    "commit_tgt": "84156084a4c5228e1d2fe21e068fff330bbc40d1",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/RemotingServerTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannel.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannelPromise.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstractTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingClientTest.java"
    ],
    "refer_PR": "apache_rocketmq-7322",
    "test_src": ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand"
    ],
    "test_src_code": "    @Test\n    public void testProcessResponseCommand() throws InterruptedException {\n        final Semaphore semaphore = new Semaphore(0);\n        ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n            @Override\n            public void operationComplete(final ResponseFuture responseFuture) {\n                assertThat(semaphore.availablePermits()).isEqualTo(0);\n            }\n        }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n        remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n\n        RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n        response.setOpaque(1);\n        remotingAbstract.processResponseCommand(null, response);\n\n        // Acquire the release permit after call back\n        semaphore.acquire(1);\n        assertThat(semaphore.availablePermits()).isEqualTo(0);\n    }\n",
    "focal_path_src": [
      "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand"
    ],
    "focal_path_tgt": [
      "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand"
    ],
    "focal_src": [
      "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, but not matched any request, \" + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n            log.warn(cmd.toString());\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, cmd={}, but not matched any request, address={}\", cmd, RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n    }\n"
    ],
    "test_id": 64,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testProcessResponseCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.put(1, responseFuture);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire();\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testProcessResponseCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.put(1, responseFuture);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire();\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n"
    ]
  },
  "65": {
    "commit_src": "c36bb78e850129b9db40adc5b0e1b9bfd5c8fd2e",
    "commit_tgt": "84156084a4c5228e1d2fe21e068fff330bbc40d1",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/RemotingServerTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannel.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannelPromise.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstractTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingClientTest.java"
    ],
    "refer_PR": "apache_rocketmq-7322",
    "test_src": ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand_RunCallBackInCurrentThread",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand_RunCallBackInCurrentThread"
    ],
    "test_src_code": "    @Test\n    public void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n        final Semaphore semaphore = new Semaphore(0);\n        ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n            @Override\n            public void operationComplete(final ResponseFuture responseFuture) {\n                assertThat(semaphore.availablePermits()).isEqualTo(0);\n            }\n        }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n        remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n        when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n        RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n        response.setOpaque(1);\n        remotingAbstract.processResponseCommand(null, response);\n\n        // Acquire the release permit after call back finished in current thread\n        semaphore.acquire(1);\n        assertThat(semaphore.availablePermits()).isEqualTo(0);\n    }\n",
    "focal_path_src": [
      "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand"
    ],
    "focal_path_tgt": [
      "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand"
    ],
    "focal_src": [
      "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, but not matched any request, \" + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n            log.warn(cmd.toString());\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, cmd={}, but not matched any request, address={}\", cmd, RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n    }\n"
    ],
    "test_id": 65,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back finished in current thread\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back finished in current thread\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back finished in current thread\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back finished in current thread\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back finished in current thread\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back finished in current thread\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back finished in current thread\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back finished in current thread\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back finished in current thread\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n        @Override\n        public void operationComplete(final ResponseFuture responseFuture) {\n            assertThat(semaphore.availablePermits()).isEqualTo(0);\n        }\n    }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back finished in current thread\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n"
    ]
  },
  "66": {
    "commit_src": "c36bb78e850129b9db40adc5b0e1b9bfd5c8fd2e",
    "commit_tgt": "84156084a4c5228e1d2fe21e068fff330bbc40d1",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/RemotingServerTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannel.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannelPromise.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstractTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingClientTest.java"
    ],
    "refer_PR": "apache_rocketmq-7322",
    "test_src": ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessRequestCommand",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessRequestCommand"
    ],
    "test_src_code": "    @Test\n    public void testProcessRequestCommand() throws InterruptedException {\n        final Semaphore semaphore = new Semaphore(0);\n        RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n        ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n            responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n        remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n        RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n        response.setOpaque(1);\n        remotingAbstract.processResponseCommand(null, response);\n\n        // Acquire the release permit after call back\n        semaphore.acquire(1);\n        assertThat(semaphore.availablePermits()).isEqualTo(0);\n    }\n",
    "focal_path_src": [
      "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand"
    ],
    "focal_path_tgt": [
      "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand"
    ],
    "focal_src": [
      "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, but not matched any request, \" + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n            log.warn(cmd.toString());\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, cmd={}, but not matched any request, address={}\", cmd, RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n    }\n"
    ],
    "test_id": 66,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testProcessRequestCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n        responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessRequestCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n        responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessRequestCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n        responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessRequestCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n        responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessRequestCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n        responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testProcessRequestCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n        responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessRequestCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n        responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessRequestCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n        responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessRequestCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n        responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n",
      "@Test\npublic void testProcessRequestCommand() throws InterruptedException {\n    final Semaphore semaphore = new Semaphore(0);\n    RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n    ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n        responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n    remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n    RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n    response.setOpaque(1);\n    remotingAbstract.processResponseCommand(null, response);\n\n    // Acquire the release permit after call back\n    semaphore.acquire(1);\n    assertThat(semaphore.availablePermits()).isEqualTo(0);\n}\n"
    ]
  },
  "67": {
    "commit_src": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "commit_tgt": "831fcc76cd7cd362bb6c136c287c624bb7eaf40a",
    "changed_tests": [
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java"
    ],
    "refer_PR": "apache_rocketmq-7365",
    "test_src": ".org.apache.rocketmq.tieredstore.TieredMessageStoreTest#testGetMessageAsync",
    "test_tgt": [
      ".org.apache.rocketmq.tieredstore.TieredMessageStoreTest#testGetMessageAsync"
    ],
    "test_src_code": "    @Test\n    public void testGetMessageAsync() {\n        mockCompositeFlatFile();\n        GetMessageResult result1 = new GetMessageResult();\n        result1.setStatus(GetMessageStatus.FOUND);\n        GetMessageResult result2 = new GetMessageResult();\n        result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n\n        when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));\n        when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        // TieredStorageLevel.FORCE\n        Properties properties = new Properties();\n        properties.setProperty(\"tieredStorageLevel\", \"3\");\n        configuration.update(properties);\n        when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);\n        Assert.assertSame(result2, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n    }\n",
    "focal_path_src": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/TieredMessageStore.java#getMessageAsync"
    ],
    "focal_path_tgt": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/TieredMessageStore.java#getMessageAsync"
    ],
    "focal_src": [
      "    @Override\n    public CompletableFuture<GetMessageResult> getMessageAsync(String group, String topic,\n        int queueId, long offset, int maxMsgNums, MessageFilter messageFilter) {\n\n        if (fetchFromCurrentStore(topic, queueId, offset, maxMsgNums)) {\n            logger.trace(\"GetMessageAsync from current store, topic: {}, queue: {}, offset: {}\", topic, queueId, offset);\n        } else {\n            logger.trace(\"GetMessageAsync from next store, topic: {}, queue: {}, offset: {}\", topic, queueId, offset);\n            return next.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter);\n        }\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        return fetcher\n            .getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter)\n            .thenApply(result -> {\n                Attributes latencyAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                    .put(TieredStoreMetricsConstant.LABEL_OPERATION, TieredStoreMetricsConstant.OPERATION_API_GET_MESSAGE)\n                    .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                    .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                    .build();\n                TieredStoreMetricsManager.apiLatency.record(stopwatch.elapsed(TimeUnit.MILLISECONDS), latencyAttributes);\n\n                if (result.getStatus() == GetMessageStatus.OFFSET_FOUND_NULL ||\n                    result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_ONE ||\n                    result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n\n                    if (next.checkInStoreByConsumeOffset(topic, queueId, offset)) {\n                        TieredStoreMetricsManager.fallbackTotal.add(1, latencyAttributes);\n                        logger.debug(\"GetMessageAsync not found, then back to next store, result: {}, \" +\n                                \"topic: {}, queue: {}, queue offset: {}, offset range: {}-{}\",\n                            result.getStatus(), topic, queueId, offset, result.getMinOffset(), result.getMaxOffset());\n                        return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                    }\n                }\n\n                // Fetch system topic data from the broker when using the force level.\n                if (result.getStatus() == GetMessageStatus.NO_MATCHED_LOGIC_QUEUE) {\n                    if (TieredStoreUtil.isSystemTopic(topic) || PopAckConstants.isStartWithRevivePrefix(topic)) {\n                        return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                    }\n                }\n\n                if (result.getStatus() != GetMessageStatus.FOUND &&\n                    result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_ONE &&\n                    result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                    logger.warn(\"GetMessageAsync not found and message is not in next store, result: {}, \" +\n                            \"topic: {}, queue: {}, queue offset: {}, offset range: {}-{}\",\n                        result.getStatus(), topic, queueId, offset, result.getMinOffset(), result.getMaxOffset());\n                }\n\n                if (result.getStatus() == GetMessageStatus.FOUND) {\n                    Attributes messagesOutAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                        .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                        .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                        .build();\n                    TieredStoreMetricsManager.messagesOutTotal.add(result.getMessageCount(), messagesOutAttributes);\n                }\n\n                // Fix min or max offset according next store at last\n                long minOffsetInQueue = next.getMinOffsetInQueue(topic, queueId);\n                if (minOffsetInQueue >= 0 && minOffsetInQueue < result.getMinOffset()) {\n                    result.setMinOffset(minOffsetInQueue);\n                }\n                long maxOffsetInQueue = next.getMaxOffsetInQueue(topic, queueId);\n                if (maxOffsetInQueue >= 0 && maxOffsetInQueue > result.getMaxOffset()) {\n                    result.setMaxOffset(maxOffsetInQueue);\n                }\n                return result;\n            }).exceptionally(e -> {\n                logger.error(\"GetMessageAsync from tiered store failed\", e);\n                return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n            });\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public CompletableFuture<GetMessageResult> getMessageAsync(String group, String topic,\n        int queueId, long offset, int maxMsgNums, MessageFilter messageFilter) {\n\n        // For system topic, force reading from local store\n        if (TieredStoreUtil.isSystemTopic(topic) || PopAckConstants.isStartWithRevivePrefix(topic)) {\n            return next.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter);\n        }\n\n        if (fetchFromCurrentStore(topic, queueId, offset, maxMsgNums)) {\n            logger.trace(\"GetMessageAsync from current store, topic: {}, queue: {}, offset: {}\", topic, queueId, offset);\n        } else {\n            logger.trace(\"GetMessageAsync from next store, topic: {}, queue: {}, offset: {}\", topic, queueId, offset);\n            return next.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter);\n        }\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        return fetcher\n            .getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter)\n            .thenApply(result -> {\n\n                Attributes latencyAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                    .put(TieredStoreMetricsConstant.LABEL_OPERATION, TieredStoreMetricsConstant.OPERATION_API_GET_MESSAGE)\n                    .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                    .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                    .build();\n                TieredStoreMetricsManager.apiLatency.record(stopwatch.elapsed(TimeUnit.MILLISECONDS), latencyAttributes);\n\n                if (result.getStatus() == GetMessageStatus.OFFSET_FOUND_NULL ||\n                    result.getStatus() == GetMessageStatus.NO_MATCHED_LOGIC_QUEUE) {\n\n                    if (next.checkInStoreByConsumeOffset(topic, queueId, offset)) {\n                        TieredStoreMetricsManager.fallbackTotal.add(1, latencyAttributes);\n                        logger.debug(\"GetMessageAsync not found, then back to next store, result: {}, \" +\n                                \"topic: {}, queue: {}, queue offset: {}, offset range: {}-{}\",\n                            result.getStatus(), topic, queueId, offset, result.getMinOffset(), result.getMaxOffset());\n                        return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                    }\n                }\n\n                if (result.getStatus() != GetMessageStatus.FOUND &&\n                    result.getStatus() != GetMessageStatus.NO_MATCHED_LOGIC_QUEUE &&\n                    result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_ONE &&\n                    result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                    logger.warn(\"GetMessageAsync not found and message is not in next store, result: {}, \" +\n                            \"topic: {}, queue: {}, queue offset: {}, offset range: {}-{}\",\n                        result.getStatus(), topic, queueId, offset, result.getMinOffset(), result.getMaxOffset());\n                }\n\n                if (result.getStatus() == GetMessageStatus.FOUND) {\n                    Attributes messagesOutAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                        .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                        .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                        .build();\n                    TieredStoreMetricsManager.messagesOutTotal.add(result.getMessageCount(), messagesOutAttributes);\n                }\n\n                // Fix min or max offset according next store at last\n                long minOffsetInQueue = next.getMinOffsetInQueue(topic, queueId);\n                if (minOffsetInQueue >= 0 && minOffsetInQueue < result.getMinOffset()) {\n                    result.setMinOffset(minOffsetInQueue);\n                }\n\n                // In general, the local cq offset is slightly greater than the commit offset in read message,\n                // so there is no need to update the maximum offset to the local cq offset here,\n                // otherwise it will cause repeated consumption after next begin offset over commit offset.\n\n                logger.trace(\"GetMessageAsync result, group: {}, topic: {}, queueId: {}, offset: {}, count:{}, {}\",\n                    group, topic, queueId, offset, maxMsgNums, result);\n\n                return result;\n            }).exceptionally(e -> {\n                logger.error(\"GetMessageAsync from tiered store failed\", e);\n                return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n            });\n    }\n"
    ],
    "test_id": 67,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testGetMessageAsync() {\n    mockCompositeFlatFile();\n    GetMessageResult result1 = new GetMessageResult();\n    result1.setStatus(GetMessageStatus.FOUND);\n    GetMessageResult result2 = new GetMessageResult();\n    result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n\n    when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));\n    when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    // TieredStorageLevel.FORCE\n    Properties properties = new Properties();\n    properties.setProperty(\"tieredStorageLevel\", \"3\");\n    configuration.update(properties);\n    when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);\n    Assert.assertSame(result2, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testGetMessageAsync() {\n    mockCompositeFlatFile();\n    GetMessageResult result1 = new GetMessageResult();\n    result1.setStatus(GetMessageStatus.FOUND);\n    GetMessageResult result2 = new GetMessageResult();\n    result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n\n    when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));\n    when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);\n    Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n    // TieredStorageLevel.FORCE\n    Properties properties = new Properties();\n    properties.setProperty(\"tieredStorageLevel\", \"3\");\n    configuration.update(properties);\n    when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);\n    Assert.assertSame(result2, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "OutOfMemoryError('CUDA out of memory. Tried to allocate 5.49 GiB. GPU 0 has a total capacty of 23.69 GiB of which 1.66 GiB is free. Process 1478252 has 22.02 GiB memory in use. Of the allocated memory 12.19 GiB is allocated by PyTorch, and 8.80 GiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF')"
  },
  "68": {
    "commit_src": "73b3fde83765e066541e3455cd1e6604292a9b7c",
    "commit_tgt": "88a9d939ce110381b3b418370d4711c0c214dc7f",
    "changed_tests": [
      "store/src/test/java/org/apache/rocketmq/store/timer/TimerMetricsTest.java"
    ],
    "refer_PR": "apache_rocketmq-7382",
    "test_src": ".org.apache.rocketmq.store.timer.TimerMetricsTest#testTimingCount",
    "test_tgt": [
      ".org.apache.rocketmq.store.timer.TimerMetricsTest#testTimingCount"
    ],
    "test_src_code": "    @Test\n    public void testTimingCount() {\n        String baseDir = StoreTestUtils.createBaseDir();\n\n        TimerMetrics first = new TimerMetrics(baseDir);\n        Assert.assertTrue(first.load());\n        first.addAndGet(\"AAA\", 1000);\n        first.addAndGet(\"BBB\", 2000);\n        Assert.assertEquals(1000, first.getTimingCount(\"AAA\"));\n        Assert.assertEquals(2000, first.getTimingCount(\"BBB\"));\n        long curr = System.currentTimeMillis();\n        Assert.assertTrue(first.getTopicPair(\"AAA\").getTimeStamp() > curr - 10);\n        Assert.assertTrue(first.getTopicPair(\"AAA\").getTimeStamp() <= curr);\n        first.persist();\n\n        TimerMetrics second = new TimerMetrics(baseDir);\n        Assert.assertTrue(second.load());\n        Assert.assertEquals(1000, second.getTimingCount(\"AAA\"));\n        Assert.assertEquals(2000, second.getTimingCount(\"BBB\"));\n        Assert.assertTrue(second.getTopicPair(\"BBB\").getTimeStamp() > curr - 100);\n        Assert.assertTrue(second.getTopicPair(\"BBB\").getTimeStamp() <= curr);\n        second.persist();\n        StoreTestUtils.deleteFile(baseDir);\n    }\n",
    "focal_path_src": [
      "store/src/main/java/org/apache/rocketmq/store/timer/TimerMetrics.java#addAndGet"
    ],
    "focal_path_tgt": [
      "store/src/main/java/org/apache/rocketmq/store/timer/TimerMetrics.java#addAndGet"
    ],
    "focal_src": [
      "    public long addAndGet(String topic, int value) {\n        Metric pair = getTopicPair(topic);\n        getDataVersion().nextVersion();\n        pair.setTimeStamp(System.currentTimeMillis());\n        return pair.getCount().addAndGet(value);\n    }\n"
    ],
    "focal_tgt": [
      "    public long addAndGet(MessageExt msg, int value) {\n        String topic = msg.getProperty(MessageConst.PROPERTY_REAL_TOPIC);\n        Metric pair = getTopicPair(topic);\n        getDataVersion().nextVersion();\n        pair.setTimeStamp(System.currentTimeMillis());\n        return pair.getCount().addAndGet(value);\n    }\n"
    ],
    "test_id": 68,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testTimingCount() {\n    String baseDir = StoreTestUtils.createBaseDir();\n\n    TimerMetrics first = new TimerMetrics(baseDir);\n    Assert.assertTrue(first.load());\n    first.addAndGet(\"AAA\", 1000);\n    first.addAndGet(\"BBB\", 2000);\n    Assert.assertEquals(1000, first.getTimingCount(\"AAA\"));\n    Assert.assertEquals(2000, first.getTimingCount(\"BBB\"));\n    long curr = System.currentTimeMillis();\n    Assert.assertTrue(first.getTopicPair(\"AAA\").getTimeStamp() > curr - 10);\n    Assert.assertTrue(first.getTopicPair(\"AAA\").getTimeStamp() <= curr);\n    first.persist();\n\n    TimerMetrics second = new TimerMetrics(baseDir);\n    Assert.assertTrue(second.load());\n    Assert.assertEquals(1000, second.getTimingCount(\"AAA\"));\n    Assert.assertEquals(2000, second.getTimingCount(\"BBB\"));\n    Assert.assertTrue(second.getTopicPair(\"BBB\").getTimeStamp() > curr - 100);\n    Assert.assertTrue(second.getTopicPair(\"BBB\").getTimeStamp() <= curr);\n    second.persist();\n    StoreTestUtils.deleteFile(baseDir);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testTimingCount() {\n    String baseDir = StoreTestUtils.createBaseDir();\n\n    TimerMetrics first = new TimerMetrics(baseDir);\n    Assert.assertTrue(first.load());\n    first.addAndGet(\"AAA\", 1000);\n    first.addAndGet(\"BBB\", 2000);\n    Assert.assertEquals(1000, first.getTimingCount(\"AAA\"));\n    Assert.assertEquals(2000, first.getTimingCount(\"BBB\"));\n    long curr = System.currentTimeMillis();\n    Assert.assertTrue(first.getTopicPair(\"AAA\").getTimeStamp() > curr - 10);\n    Assert.assertTrue(first.getTopicPair(\"AAA\").getTimeStamp() <= curr);\n    first.persist();\n\n    TimerMetrics second = new TimerMetrics(baseDir);\n    Assert.assertTrue(second.load());\n    Assert.assertEquals(1000, second.getTimingCount(\"AAA\"));\n    Assert.assertEquals(2000, second.getTimingCount(\"BBB\"));\n    Assert.assertTrue(second.getTopicPair(\"BBB\").getTimeStamp() > curr - 100);\n    Assert.assertTrue(second.getTopicPair(\"BBB\").getTimeStamp() <= curr);\n    second.persist();\n    StoreTestUtils.deleteFile(baseDir);\n}\n"
    ]
  },
  "69": {
    "commit_src": "a194e1eb9a12e08c43a0da65cd0a048ff849e04d",
    "commit_tgt": "56e886bf70669befd7b9e7380e68751fe67f05b2",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/UtilAllTest.java",
      "store/src/test/java/org/apache/rocketmq/store/timer/TimerMessageStoreTest.java"
    ],
    "refer_PR": "apache_rocketmq-7593",
    "test_src": ".org.apache.rocketmq.common.UtilAllTest#testCleanBuffer",
    "test_tgt": [
      ".org.apache.rocketmq.common.UtilAllTest#testCleanBuffer"
    ],
    "test_src_code": "    @Test\n    public void testCleanBuffer() {\n        UtilAll.cleanBuffer(null);\n        UtilAll.cleanBuffer(ByteBuffer.allocate(10));\n        UtilAll.cleanBuffer(ByteBuffer.allocate(0));\n    }\n",
    "focal_path_src": [
      "common/src/main/java/org/apache/rocketmq/common/UtilAll.java#cleanBuffer"
    ],
    "focal_path_tgt": [
      "common/src/main/java/org/apache/rocketmq/common/UtilAll.java#cleanBuffer"
    ],
    "focal_src": [
      "    public static void cleanBuffer(final ByteBuffer buffer) {\n        if (null == buffer) {\n            return;\n        }\n        PlatformDependent.freeDirectBuffer(buffer);\n    }\n"
    ],
    "focal_tgt": [
      "    /**\n     * Free direct-buffer's memory actively.\n     * @param buffer Direct buffer to free.\n     */\n    public static void cleanBuffer(final ByteBuffer buffer) {\n        if (null == buffer) {\n            return;\n        }\n\n        if (!buffer.isDirect()) {\n            return;\n        }\n\n        PlatformDependent.freeDirectBuffer(buffer);\n    }\n"
    ],
    "test_id": 69,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testCleanBuffer() {\n    ByteBuffer directBuffer = ByteBuffer.allocateDirect(10);\n    UtilAll.cleanBuffer(directBuffer);\n    assertTrue(directBuffer.isDirect() == false);\n\n    UtilAll.cleanBuffer(null);\n    UtilAll.cleanBuffer(ByteBuffer.allocate(10));\n    UtilAll.cleanBuffer(ByteBuffer.allocate(0));\n\n    directBuffer = ByteBuffer.allocateDirect(10);\n    UtilAll.cleanBuffer(directBuffer);\n    assertTrue(directBuffer.isDirect() == false);\n}\n",
      "@Test\npublic void testCleanBuffer() {\n    // Test with null buffer\n    UtilAll.cleanBuffer(null);\n\n    // Test with non-empty direct buffer\n    ByteBuffer nonEmptyBuffer = ByteBuffer.allocateDirect(10);\n    UtilAll.cleanBuffer(nonEmptyBuffer);\n    assertTrue(nonEmptyBuffer.isDirect()); // Should still be a direct buffer\n\n    // Test with empty direct buffer\n    ByteBuffer emptyBuffer = ByteBuffer.allocateDirect(0);\n    UtilAll.cleanBuffer(emptyBuffer);\n    assertTrue(emptyBuffer.isDirect()); // Should still be a direct buffer\n\n    // Add more test cases as needed\n}\n",
      "@Test\npublic void testCleanBuffer() {\n    UtilAll.cleanBuffer(null);\n    UtilAll.cleanBuffer(ByteBuffer.allocateDirect(10));\n    UtilAll.cleanBuffer(ByteBuffer.allocateDirect(0));\n}\n",
      "@Test\npublic void testCleanBuffer() {\n    ByteBuffer buffer1 = null;\n    ByteBuffer buffer2 = ByteBuffer.allocate(10);\n    ByteBuffer buffer3 = ByteBuffer.allocateDirect(0);\n\n    UtilAll.cleanBuffer(buffer1);\n    UtilAll.cleanBuffer(buffer2);\n    UtilAll.cleanBuffer(buffer3);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testCleanBuffer() {\n    ByteBuffer directBuffer = ByteBuffer.allocateDirect(10);\n    UtilAll.cleanBuffer(directBuffer);\n    assertTrue(directBuffer.isDirect() == false);\n\n    UtilAll.cleanBuffer(null);\n    UtilAll.cleanBuffer(ByteBuffer.allocate(10));\n    UtilAll.cleanBuffer(ByteBuffer.allocate(0));\n\n    directBuffer = ByteBuffer.allocateDirect(10);\n    UtilAll.cleanBuffer(directBuffer);\n    assertTrue(directBuffer.isDirect() == false);\n    // Testing the case where the buffer is not direct\n    ByteBuffer heapBuffer = ByteBuffer.allocate(10);\n    UtilAll.cleanBuffer(heapBuffer);\n    assertTrue(heapBuffer.isDirect() == false);\n\n    // Testing the case where the buffer is direct but not allocated\n    ByteBuffer unallocatedDirectBuffer = ByteBuffer.allocateDirect(10);\n    unallocatedDirectBuffer.clear();\n    UtilAll.cleanBuffer(unallocatedDirectBuffer);\n    assertTrue(unallocatedDirectBuffer.isDirect() == false);\n}\n",
      "@Test\npublic void testCleanBuffer() {\n    UtilAll.cleanBuffer(null);\n    UtilAll.cleanBuffer(ByteBuffer.allocateDirect(10));\n    UtilAll.cleanBuffer(ByteBuffer.allocateDirect(0));\n    // Testing for non-direct buffer\n    ByteBuffer heapBuffer = ByteBuffer.allocate(10);\n    UtilAll.cleanBuffer(heapBuffer);\n\n    // Testing for direct buffer with zero capacity\n    ByteBuffer zeroCapacityBuffer = ByteBuffer.allocateDirect(0);\n    UtilAll.cleanBuffer(zeroCapacityBuffer);\n}\n"
    ]
  },
  "70": {
    "commit_src": "50a92a2474e4c29dcf2753d8d68332011af71265",
    "commit_tgt": "8e585d8767bc24ab21217498daaea12d76cfd8ca",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/KeyBuilderTest.java"
    ],
    "refer_PR": "apache_rocketmq-7655",
    "test_src": ".org.apache.rocketmq.common.KeyBuilderTest#parseNormalTopic",
    "test_tgt": [
      ".org.apache.rocketmq.common.KeyBuilderTest#testBuildPopRetryTopic",
      ".org.apache.rocketmq.common.KeyBuilderTest#testBuildPopRetryTopicV1",
      ".org.apache.rocketmq.common.KeyBuilderTest#testParseGroup",
      ".org.apache.rocketmq.common.KeyBuilderTest#testIsPopRetryTopicV2"
    ],
    "test_src_code": "    @Test\n    public void parseNormalTopic() {\n        String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n        assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n        String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n        assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1, group)).isEqualTo(topic);\n    }\n",
    "focal_path_src": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#parseNormalTopic"
    ],
    "focal_path_tgt": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#parseNormalTopic"
    ],
    "focal_src": [
      "    public static String parseNormalTopic(String retryTopic) {\n        if (isPopRetryTopicV2(retryTopic)) {\n            String[] result = retryTopic.split(POP_RETRY_SEPARATOR_V2);\n            if (result.length == 2) {\n                return result[1];\n            }\n        }\n        return retryTopic;\n    }\n"
    ],
    "focal_tgt": [
      "    public static String parseNormalTopic(String retryTopic) {\n        if (isPopRetryTopicV2(retryTopic)) {\n            String[] result = retryTopic.split(POP_RETRY_REGEX_SEPARATOR_V2);\n            if (result.length == 2) {\n                return result[1];\n            }\n        }\n        return retryTopic;\n    }\n"
    ],
    "test_id": 70,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void parseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1)).isEqualTo(topic);\n}\n",
      "@Test\npublic void parseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1)).isEqualTo(topic);\n}\n",
      "@Test\npublic void parseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1)).isEqualTo(topic);\n    String nonPopRetryTopic = \"some non-pop retry topic\";\n    assertThat(KeyBuilder.parseNormalTopic(nonPopRetryTopic)).isEqualTo(nonPopRetryTopic);\n}\n",
      "@Test\npublic void parseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1)).isEqualTo(topic);\n}\n",
      "@Test\npublic void parseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1)).isEqualTo(topic);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void parseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1)).isEqualTo(topic);\n    // Test with a normal topic\n    String normalTopic = \"normal_topic\";\n    assertThat(KeyBuilder.parseNormalTopic(normalTopic)).isEqualTo(normalTopic);\n\n    // Test with a null topic\n    String nullTopic = null;\n    assertThat(KeyBuilder.parseNormalTopic(nullTopic)).isNull();\n\n    // Test with an empty topic\n    String emptyTopic = \"\";\n    assertThat(KeyBuilder.parseNormalTopic(emptyTopic)).isEmpty();\n}\n",
      "@Test\npublic void parseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1)).isEqualTo(topic);\n    // Test with a normal topic\n    String normalTopic = \"normal_topic\";\n    assertThat(KeyBuilder.parseNormalTopic(normalTopic)).isEqualTo(normalTopic);\n\n    // Test with a null topic\n    String nullTopic = null;\n    assertThat(KeyBuilder.parseNormalTopic(nullTopic)).isNull();\n\n    // Test with an empty topic\n    String emptyTopic = \"\";\n    assertThat(KeyBuilder.parseNormalTopic(emptyTopic)).isEmpty();\n}\n",
      "@Test\npublic void parseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1)).isEqualTo(topic);\n    String nonPopRetryTopic = \"some non-pop retry topic\";\n    assertThat(KeyBuilder.parseNormalTopic(nonPopRetryTopic)).isEqualTo(nonPopRetryTopic);\n    // Test with null\n    assertThat(KeyBuilder.parseNormalTopic(null)).isEqualTo(null);\n\n    // Test with empty string\n    assertThat(KeyBuilder.parseNormalTopic(\"\")).isEqualTo(\"\");\n\n    // Test with a string that is not a pop retry topic\n    String nonPopRetryTopic2 = \"non-pop-retry-topic\";\n    assertThat(KeyBuilder.parseNormalTopic(nonPopRetryTopic2)).isEqualTo(nonPopRetryTopic2);\n}\n",
      "@Test\npublic void parseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1)).isEqualTo(topic);\n    // Test with a normal topic\n    String normalTopic = \"normal_topic\";\n    assertThat(KeyBuilder.parseNormalTopic(normalTopic)).isEqualTo(normalTopic);\n\n    // Test with a null topic\n    String nullTopic = null;\n    assertThat(KeyBuilder.parseNormalTopic(nullTopic)).isNull();\n\n    // Test with an empty topic\n    String emptyTopic = \"\";\n    assertThat(KeyBuilder.parseNormalTopic(emptyTopic)).isEmpty();\n}\n",
      "@Test\npublic void parseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1)).isEqualTo(topic);\n    // Test with a normal topic\n    String normalTopic = \"normal_topic\";\n    assertThat(KeyBuilder.parseNormalTopic(normalTopic)).isEqualTo(normalTopic);\n\n    // Test with a null topic\n    String nullTopic = null;\n    assertThat(KeyBuilder.parseNormalTopic(nullTopic)).isNull();\n\n    // Test with an empty topic\n    String emptyTopic = \"\";\n    assertThat(KeyBuilder.parseNormalTopic(emptyTopic)).isEmpty();\n}\n"
    ]
  },
  "71": {
    "commit_src": "50a92a2474e4c29dcf2753d8d68332011af71265",
    "commit_tgt": "8e585d8767bc24ab21217498daaea12d76cfd8ca",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/KeyBuilderTest.java"
    ],
    "refer_PR": "apache_rocketmq-7655",
    "test_src": ".org.apache.rocketmq.common.KeyBuilderTest#testParseNormalTopic",
    "test_tgt": [
      ".org.apache.rocketmq.common.KeyBuilderTest#testBuildPopRetryTopic",
      ".org.apache.rocketmq.common.KeyBuilderTest#testBuildPopRetryTopicV1",
      ".org.apache.rocketmq.common.KeyBuilderTest#testParseNormalTopic",
      ".org.apache.rocketmq.common.KeyBuilderTest#testParseGroup",
      ".org.apache.rocketmq.common.KeyBuilderTest#testIsPopRetryTopicV2"
    ],
    "test_src_code": "    @Test\n    public void testParseNormalTopic() {\n        String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n        assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    }\n",
    "focal_path_src": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#parseNormalTopic"
    ],
    "focal_path_tgt": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#parseNormalTopic"
    ],
    "focal_src": [
      "    public static String parseNormalTopic(String retryTopic) {\n        if (isPopRetryTopicV2(retryTopic)) {\n            String[] result = retryTopic.split(POP_RETRY_SEPARATOR_V2);\n            if (result.length == 2) {\n                return result[1];\n            }\n        }\n        return retryTopic;\n    }\n"
    ],
    "focal_tgt": [
      "    public static String parseNormalTopic(String retryTopic) {\n        if (isPopRetryTopicV2(retryTopic)) {\n            String[] result = retryTopic.split(POP_RETRY_REGEX_SEPARATOR_V2);\n            if (result.length == 2) {\n                return result[1];\n            }\n        }\n        return retryTopic;\n    }\n"
    ],
    "test_id": 71,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    String normalTopic = KeyBuilder.parseNormalTopic(popRetryTopic);\n    assertThat(normalTopic).isEqualTo(topic);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n}\n"
    ]
  },
  "72": {
    "commit_src": "50a92a2474e4c29dcf2753d8d68332011af71265",
    "commit_tgt": "8e585d8767bc24ab21217498daaea12d76cfd8ca",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/KeyBuilderTest.java"
    ],
    "refer_PR": "apache_rocketmq-7655",
    "test_src": ".org.apache.rocketmq.common.KeyBuilderTest#parseGroup",
    "test_tgt": [
      ".org.apache.rocketmq.common.KeyBuilderTest#testBuildPopRetryTopic",
      ".org.apache.rocketmq.common.KeyBuilderTest#testBuildPopRetryTopicV1",
      ".org.apache.rocketmq.common.KeyBuilderTest#testParseGroup",
      ".org.apache.rocketmq.common.KeyBuilderTest#testIsPopRetryTopicV2"
    ],
    "test_src_code": "    @Test\n    public void parseGroup() {\n        String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n        assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n    }\n",
    "focal_path_src": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#parseGroup"
    ],
    "focal_path_tgt": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#parseGroup"
    ],
    "focal_src": [
      "    public static String parseGroup(String retryTopic) {\n        if (isPopRetryTopicV2(retryTopic)) {\n            String[] result = retryTopic.split(POP_RETRY_SEPARATOR_V2);\n            if (result.length == 2) {\n                return result[0].substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n            }\n        }\n        return retryTopic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n    }\n"
    ],
    "focal_tgt": [
      "    public static String parseGroup(String retryTopic) {\n        if (isPopRetryTopicV2(retryTopic)) {\n            String[] result = retryTopic.split(POP_RETRY_REGEX_SEPARATOR_V2);\n            if (result.length == 2) {\n                return result[0].substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n            }\n        }\n        return retryTopic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n    }\n"
    ],
    "test_id": 72,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void parseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void parseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void parseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    String retryGroup = KeyBuilder.parseGroup(popRetryTopic);\n    assertThat(retryGroup).isEqualTo(group);\n\n    String simpleRetryTopic = topic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n    assertThat(KeyBuilder.parseGroup(simpleRetryTopic)).isEqualTo(simpleRetryTopic);\n}\n",
      "@Test\npublic void parseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void parseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void parseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    String retryGroup = KeyBuilder.parseGroup(popRetryTopic);\n    assertThat(retryGroup).isEqualTo(group);\n\n    String simpleRetryTopic = topic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n    assertThat(KeyBuilder.parseGroup(simpleRetryTopic)).isEqualTo(simpleRetryTopic);\n    // Test with null\n    assertThat(KeyBuilder.parseGroup(null)).isNull();\n\n    // Test with empty string\n    assertThat(KeyBuilder.parseGroup(\"\")).isEmpty();\n\n    // Test with a topic that is not a retry topic\n    String nonRetryTopic = \"non_retry_topic\";\n    assertThat(KeyBuilder.parseGroup(nonRetryTopic)).isEqualTo(nonRetryTopic);\n}\n",
      "@Test\npublic void parseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n    // Testing the case where retryTopic is not a pop retry topic\n    String nonPopRetryTopic = \"non_pop_retry_topic\";\n    assertThat(KeyBuilder.parseGroup(nonPopRetryTopic)).isEqualTo(nonPopRetryTopic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length()));\n\n    // Testing the case where retryTopic is a pop retry topic but does not have the expected format\n    String popRetryTopicWrongFormat = \"pop_retry_topic_without_group\";\n    assertThat(KeyBuilder.parseGroup(popRetryTopicWrongFormat)).isEqualTo(popRetryTopicWrongFormat.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length()));\n}\n",
      "@Test\npublic void parseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n    // Testing the case where retryTopic is not a pop retry topic\n    String nonPopRetryTopic = \"non_pop_retry_topic\";\n    assertThat(KeyBuilder.parseGroup(nonPopRetryTopic)).isEqualTo(nonPopRetryTopic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length()));\n\n    // Testing the case where retryTopic is a pop retry topic but does not have the expected format\n    String popRetryTopicWrongFormat = \"pop_retry_topic_without_group\";\n    assertThat(KeyBuilder.parseGroup(popRetryTopicWrongFormat)).isEqualTo(popRetryTopicWrongFormat.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length()));\n}\n"
    ]
  },
  "73": {
    "commit_src": "50a92a2474e4c29dcf2753d8d68332011af71265",
    "commit_tgt": "8e585d8767bc24ab21217498daaea12d76cfd8ca",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/KeyBuilderTest.java"
    ],
    "refer_PR": "apache_rocketmq-7655",
    "test_src": ".org.apache.rocketmq.common.KeyBuilderTest#isPopRetryTopicV2",
    "test_tgt": [
      ".org.apache.rocketmq.common.KeyBuilderTest#testBuildPopRetryTopic",
      ".org.apache.rocketmq.common.KeyBuilderTest#testBuildPopRetryTopicV1",
      ".org.apache.rocketmq.common.KeyBuilderTest#testParseGroup",
      ".org.apache.rocketmq.common.KeyBuilderTest#testIsPopRetryTopicV2"
    ],
    "test_src_code": "    @Test\n    public void isPopRetryTopicV2() {\n        String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n        assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n        String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n        assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n    }\n",
    "focal_path_src": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#isPopRetryTopicV2"
    ],
    "focal_path_tgt": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#isPopRetryTopicV2"
    ],
    "focal_src": [
      "    public static boolean isPopRetryTopicV2(String retryTopic) {\n        return retryTopic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX) && retryTopic.contains(POP_RETRY_SEPARATOR_V2);\n    }\n"
    ],
    "focal_tgt": [
      "    public static boolean isPopRetryTopicV2(String retryTopic) {\n        return retryTopic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX) && retryTopic.contains(String.valueOf(POP_RETRY_SEPARATOR_V2));\n    }\n"
    ],
    "test_id": 73,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void isPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void isPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void isPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void isPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n    // additional test cases\n    String invalidPopRetryTopic = \"invalid_topic\";\n    assertThat(KeyBuilder.isPopRetryTopicV2(invalidPopRetryTopic)).isEqualTo(false);\n    String nullPopRetryTopic = null;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nullPopRetryTopic)).isEqualTo(false);\n}\n",
      "@Test\npublic void isPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n    String nonPopRetryTopic = \"test_topic\";\n    assertThat(KeyBuilder.isPopRetryTopicV2(nonPopRetryTopic)).isEqualTo(false);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void isPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n    // Testing the case where retryTopic is null\n    String nullRetryTopic = null;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nullRetryTopic)).isEqualTo(false);\n\n    // Testing the case where retryTopic does not start with RETRY_GROUP_TOPIC_PREFIX\n    String nonPrefixedRetryTopic = \"non_prefix_\" + popRetryTopic;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nonPrefixedRetryTopic)).isEqualTo(false);\n\n    // Testing the case where retryTopic does not contain POP_RETRY_SEPARATOR_V2\n    String nonSeparatedRetryTopic = \"non_separator_\" + popRetryTopic;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nonSeparatedRetryTopic)).isEqualTo(false);\n}\n",
      "@Test\npublic void isPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n    // Testing the case where retryTopic is null\n    String nullRetryTopic = null;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nullRetryTopic)).isEqualTo(false);\n\n    // Testing the case where retryTopic does not start with RETRY_GROUP_TOPIC_PREFIX\n    String nonPrefixedRetryTopic = \"non_prefix_\" + popRetryTopic;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nonPrefixedRetryTopic)).isEqualTo(false);\n\n    // Testing the case where retryTopic does not contain POP_RETRY_SEPARATOR_V2\n    String nonSeparatedRetryTopic = \"non_separator_\" + popRetryTopic;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nonSeparatedRetryTopic)).isEqualTo(false);\n}\n",
      "@Test\npublic void isPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n    // Testing the case where retryTopic is null\n    String nullRetryTopic = null;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nullRetryTopic)).isEqualTo(false);\n\n    // Testing the case where retryTopic does not start with RETRY_GROUP_TOPIC_PREFIX\n    String nonPrefixedRetryTopic = \"non_prefix_\" + popRetryTopic;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nonPrefixedRetryTopic)).isEqualTo(false);\n\n    // Testing the case where retryTopic does not contain POP_RETRY_SEPARATOR_V2\n    String nonSeparatedRetryTopic = \"non_separator_\" + popRetryTopic;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nonSeparatedRetryTopic)).isEqualTo(false);\n}\n",
      "@Test\npublic void isPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n    // additional test cases\n    String invalidPopRetryTopic = \"invalid_topic\";\n    assertThat(KeyBuilder.isPopRetryTopicV2(invalidPopRetryTopic)).isEqualTo(false);\n    String nullPopRetryTopic = null;\n    assertThat(KeyBuilder.isPopRetryTopicV2(nullPopRetryTopic)).isEqualTo(false);\n}\n",
      "@Test\npublic void isPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n    String nonPopRetryTopic = \"test_topic\";\n    assertThat(KeyBuilder.isPopRetryTopicV2(nonPopRetryTopic)).isEqualTo(false);\n}\n"
    ]
  },
  "74": {
    "commit_src": "3f99b1e96bedb0dc6854c92b2f753cdf9fa68197",
    "commit_tgt": "8a36471a19aea4a9052a2ad4508c9ed75ad0fe0d",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/KeyBuilderTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/LocalMessageServiceTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/header/ExtraInfoUtilTest.java",
      "test/src/test/java/org/apache/rocketmq/test/container/PopSlaveActingMasterIT.java"
    ],
    "refer_PR": "apache_rocketmq-7734",
    "test_src": ".org.apache.rocketmq.common.KeyBuilderTest#testBuildPopRetryTopic",
    "test_tgt": [
      ".org.apache.rocketmq.common.KeyBuilderTest#testBuildPopRetryTopic"
    ],
    "test_src_code": "    @Test\n    public void testBuildPopRetryTopic() {\n        assertThat(KeyBuilder.buildPopRetryTopic(topic, group)).isEqualTo(MixAll.RETRY_GROUP_TOPIC_PREFIX + group + \"+\" + topic);\n    }\n",
    "focal_path_src": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic"
    ],
    "focal_path_tgt": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic",
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic"
    ],
    "focal_src": [
      "    public static String buildPopRetryTopic(String topic, String cid) {\n        return MixAll.RETRY_GROUP_TOPIC_PREFIX + cid + POP_RETRY_SEPARATOR_V2 + topic;\n    }\n"
    ],
    "focal_tgt": [
      "    public static String buildPopRetryTopic(String topic, String cid, boolean enableRetryV2) {\n        if (enableRetryV2) {\n            return buildPopRetryTopicV2(topic, cid);\n        }\n        return buildPopRetryTopicV1(topic, cid);\n    }\n",
      "    public static String buildPopRetryTopic(String topic, String cid) {\n        return MixAll.RETRY_GROUP_TOPIC_PREFIX + cid + POP_RETRY_SEPARATOR_V1 + topic;\n    }\n"
    ],
    "test_id": 74,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testBuildPopRetryTopic() {\n    // Testing with enableRetryV2 = true\n    assertThat(KeyBuilder.buildPopRetryTopic(topic, group, true)).isEqualTo(MixAll.RETRY_GROUP_TOPIC_PREFIX + group + \"+\" + topic);\n\n    // Testing with enableRetryV2 = false\n    assertThat(KeyBuilder.buildPopRetryTopic(topic, group, false)).isEqualTo(MixAll.RETRY_GROUP_TOPIC_PREFIX + group + \"+\" + topic);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testBuildPopRetryTopic() {\n    // Testing with enableRetryV2 = true\n    assertThat(KeyBuilder.buildPopRetryTopic(topic, group, true)).isEqualTo(MixAll.RETRY_GROUP_TOPIC_PREFIX + group + \"+\" + topic);\n\n    // Testing with enableRetryV2 = false\n    assertThat(KeyBuilder.buildPopRetryTopic(topic, group, false)).isEqualTo(MixAll.RETRY_GROUP_TOPIC_PREFIX + group + \"+\" + topic);\n}\n"
    ]
  },
  "75": {
    "commit_src": "3f99b1e96bedb0dc6854c92b2f753cdf9fa68197",
    "commit_tgt": "8a36471a19aea4a9052a2ad4508c9ed75ad0fe0d",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/KeyBuilderTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/LocalMessageServiceTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/header/ExtraInfoUtilTest.java",
      "test/src/test/java/org/apache/rocketmq/test/container/PopSlaveActingMasterIT.java"
    ],
    "refer_PR": "apache_rocketmq-7734",
    "test_src": ".org.apache.rocketmq.common.KeyBuilderTest#testParseNormalTopic",
    "test_tgt": [
      ".org.apache.rocketmq.common.KeyBuilderTest#testParseNormalTopic"
    ],
    "test_src_code": "    @Test\n    public void testParseNormalTopic() {\n        String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n        assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n        String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n        assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1, group)).isEqualTo(topic);\n\n        popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n        assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n    }\n",
    "focal_path_src": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic"
    ],
    "focal_path_tgt": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic",
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic"
    ],
    "focal_src": [
      "    public static String buildPopRetryTopic(String topic, String cid) {\n        return MixAll.RETRY_GROUP_TOPIC_PREFIX + cid + POP_RETRY_SEPARATOR_V2 + topic;\n    }\n"
    ],
    "focal_tgt": [
      "    public static String buildPopRetryTopic(String topic, String cid, boolean enableRetryV2) {\n        if (enableRetryV2) {\n            return buildPopRetryTopicV2(topic, cid);\n        }\n        return buildPopRetryTopicV1(topic, cid);\n    }\n",
      "    public static String buildPopRetryTopic(String topic, String cid) {\n        return MixAll.RETRY_GROUP_TOPIC_PREFIX + cid + POP_RETRY_SEPARATOR_V1 + topic;\n    }\n"
    ],
    "test_id": 75,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    // Test the updated version of the production code\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    // Test the old version of the production code\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    // Test the updated version of the production code\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    // Test the old version of the production code\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n}\n",
      "@Test\npublic void testParseNormalTopic() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic, group)).isEqualTo(topic);\n\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopicV1, group)).isEqualTo(topic);\n\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseNormalTopic(popRetryTopic)).isEqualTo(topic);\n}\n"
    ]
  },
  "76": {
    "commit_src": "3f99b1e96bedb0dc6854c92b2f753cdf9fa68197",
    "commit_tgt": "8a36471a19aea4a9052a2ad4508c9ed75ad0fe0d",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/KeyBuilderTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/LocalMessageServiceTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/header/ExtraInfoUtilTest.java",
      "test/src/test/java/org/apache/rocketmq/test/container/PopSlaveActingMasterIT.java"
    ],
    "refer_PR": "apache_rocketmq-7734",
    "test_src": ".org.apache.rocketmq.common.KeyBuilderTest#testParseGroup",
    "test_tgt": [
      ".org.apache.rocketmq.common.KeyBuilderTest#testParseGroup"
    ],
    "test_src_code": "    @Test\n    public void testParseGroup() {\n        String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n        assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n    }\n",
    "focal_path_src": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic"
    ],
    "focal_path_tgt": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic",
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic"
    ],
    "focal_src": [
      "    public static String buildPopRetryTopic(String topic, String cid) {\n        return MixAll.RETRY_GROUP_TOPIC_PREFIX + cid + POP_RETRY_SEPARATOR_V2 + topic;\n    }\n"
    ],
    "focal_tgt": [
      "    public static String buildPopRetryTopic(String topic, String cid, boolean enableRetryV2) {\n        if (enableRetryV2) {\n            return buildPopRetryTopicV2(topic, cid);\n        }\n        return buildPopRetryTopicV1(topic, cid);\n    }\n",
      "    public static String buildPopRetryTopic(String topic, String cid) {\n        return MixAll.RETRY_GROUP_TOPIC_PREFIX + cid + POP_RETRY_SEPARATOR_V1 + topic;\n    }\n"
    ],
    "test_id": 76,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testParseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void testParseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void testParseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void testParseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void testParseGroup() {\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group);\n    String popRetryTopicV2 = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseGroup(popRetryTopicV1)).isEqualTo(group);\n    assertThat(KeyBuilder.parseGroup(popRetryTopicV2)).isEqualTo(group);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testParseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void testParseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void testParseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void testParseGroup() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n    popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseGroup(popRetryTopic)).isEqualTo(group);\n}\n",
      "@Test\npublic void testParseGroup() {\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group);\n    String popRetryTopicV2 = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.parseGroup(popRetryTopicV1)).isEqualTo(group);\n    assertThat(KeyBuilder.parseGroup(popRetryTopicV2)).isEqualTo(group);\n    // Testing the uncovered line\n    String popRetryTopicV1NoRetry = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.parseGroup(popRetryTopicV1NoRetry)).isEqualTo(group);\n}\n"
    ]
  },
  "77": {
    "commit_src": "3f99b1e96bedb0dc6854c92b2f753cdf9fa68197",
    "commit_tgt": "8a36471a19aea4a9052a2ad4508c9ed75ad0fe0d",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/KeyBuilderTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/LocalMessageServiceTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/header/ExtraInfoUtilTest.java",
      "test/src/test/java/org/apache/rocketmq/test/container/PopSlaveActingMasterIT.java"
    ],
    "refer_PR": "apache_rocketmq-7734",
    "test_src": ".org.apache.rocketmq.common.KeyBuilderTest#testIsPopRetryTopicV2",
    "test_tgt": [
      ".org.apache.rocketmq.common.KeyBuilderTest#testIsPopRetryTopicV2"
    ],
    "test_src_code": "    @Test\n    public void testIsPopRetryTopicV2() {\n        String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n        assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n        String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n        assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n    }\n",
    "focal_path_src": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic"
    ],
    "focal_path_tgt": [
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic",
      "common/src/main/java/org/apache/rocketmq/common/KeyBuilder.java#buildPopRetryTopic"
    ],
    "focal_src": [
      "    public static String buildPopRetryTopic(String topic, String cid) {\n        return MixAll.RETRY_GROUP_TOPIC_PREFIX + cid + POP_RETRY_SEPARATOR_V2 + topic;\n    }\n"
    ],
    "focal_tgt": [
      "    public static String buildPopRetryTopic(String topic, String cid, boolean enableRetryV2) {\n        if (enableRetryV2) {\n            return buildPopRetryTopicV2(topic, cid);\n        }\n        return buildPopRetryTopicV1(topic, cid);\n    }\n",
      "    public static String buildPopRetryTopic(String topic, String cid) {\n        return MixAll.RETRY_GROUP_TOPIC_PREFIX + cid + POP_RETRY_SEPARATOR_V1 + topic;\n    }\n"
    ],
    "test_id": 77,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testIsPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void testIsPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void testIsPopRetryTopicV2() {\n    String popRetryTopicV2 = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV2)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void testIsPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void testIsPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testIsPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void testIsPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void testIsPopRetryTopicV2() {\n    String popRetryTopicV2 = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV2)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void testIsPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n",
      "@Test\npublic void testIsPopRetryTopicV2() {\n    String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group, true);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isEqualTo(true);\n    String popRetryTopicV1 = KeyBuilder.buildPopRetryTopic(topic, group, false);\n    assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isEqualTo(false);\n}\n"
    ]
  },
  "78": {
    "commit_src": "6d7513425c2aeb17e527be9d0d98d47f7251927d",
    "commit_tgt": "5262358140bcf7b283754a71dd16c2a5c6dbf821",
    "changed_tests": [
      "client/src/test/java/org/apache/rocketmq/client/rpchook/NamespaceRpcHookTest.java"
    ],
    "refer_PR": "apache_rocketmq-7769",
    "test_src": ".org.apache.rocketmq.client.rpchook.NamespaceRpcHookTest#testDoBeforeRequestWithNamespace",
    "test_tgt": [
      ".org.apache.rocketmq.client.rpchook.NamespaceRpcHookTest#testDoBeforeRequestWithNamespace"
    ],
    "test_src_code": "    @Test\n    public void testDoBeforeRequestWithNamespace() {\n        clientConfig = new ClientConfig();\n        clientConfig.setNamespaceV2(namespace);\n        namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n        PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n        namespaceRpcHook.doBeforeRequest(\"\", request);\n        assertThat(pullMessageRequestHeader.getNamespaced()).isTrue();\n        assertThat(pullMessageRequestHeader.getNamespace()).isEqualTo(namespace);\n    }\n",
    "focal_path_src": [
      "client/src/main/java/org/apache/rocketmq/client/rpchook/NamespaceRpcHook.java#doBeforeRequest"
    ],
    "focal_path_tgt": [
      "client/src/main/java/org/apache/rocketmq/client/rpchook/NamespaceRpcHook.java#doBeforeRequest"
    ],
    "focal_src": [
      "    @Override\n    public void doBeforeRequest(String remoteAddr, RemotingCommand request) {\n        CommandCustomHeader customHeader = request.readCustomHeader();\n        if (customHeader instanceof RpcRequestHeader) {\n            RpcRequestHeader requestHeader = (RpcRequestHeader) customHeader;\n            if (StringUtils.isNotEmpty(clientConfig.getNamespaceV2())) {\n                requestHeader.setNamespaced(true);\n                requestHeader.setNamespace(clientConfig.getNamespaceV2());\n            }\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public void doBeforeRequest(String remoteAddr, RemotingCommand request) {\n        if (StringUtils.isNotEmpty(clientConfig.getNamespaceV2())) {\n            request.addExtField(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD, \"true\");\n            request.addExtField(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD, clientConfig.getNamespaceV2());\n        }\n    }\n"
    ],
    "test_id": 78,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testDoBeforeRequestWithNamespace() {\n    clientConfig = new ClientConfig();\n    clientConfig.setNamespaceV2(namespace);\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isEqualTo(\"true\");\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isEqualTo(namespace);\n}\n",
      "@Test\npublic void testDoBeforeRequestWithNamespace() {\n    clientConfig = new ClientConfig();\n    clientConfig.setNamespaceV2(namespace);\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, new PullMessageRequestHeader());\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n\n    // Assuming the new version of the production code modifies the RemotingCommand directly,\n    // we can't directly assert the values in the header. Instead, we assert the extended fields in the RemotingCommand.\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isEqualTo(\"true\");\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isEqualTo(namespace);\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testDoBeforeRequestWithNamespace() {\n    clientConfig = new ClientConfig();\n    clientConfig.setNamespaceV2(namespace);\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isEqualTo(\"true\");\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isEqualTo(namespace);\n    // Testing the case where namespace is not set\n    clientConfig = new ClientConfig();\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isNull();\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isNull();\n}\n",
      "@Test\npublic void testDoBeforeRequestWithNamespace() {\n    clientConfig = new ClientConfig();\n    clientConfig.setNamespaceV2(namespace);\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, new PullMessageRequestHeader());\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n\n    // Assuming the new version of the production code modifies the RemotingCommand directly,\n    // we can't directly assert the values in the header. Instead, we assert the extended fields in the RemotingCommand.\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isEqualTo(\"true\");\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isEqualTo(namespace);\n    // Testing the case where namespace is not set\n    clientConfig = new ClientConfig();\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, new PullMessageRequestHeader());\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n\n    // In this case, the namespace fields should not be present in the request\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isNull();\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isNull();\n}\n"
    ]
  },
  "79": {
    "commit_src": "6d7513425c2aeb17e527be9d0d98d47f7251927d",
    "commit_tgt": "5262358140bcf7b283754a71dd16c2a5c6dbf821",
    "changed_tests": [
      "client/src/test/java/org/apache/rocketmq/client/rpchook/NamespaceRpcHookTest.java"
    ],
    "refer_PR": "apache_rocketmq-7769",
    "test_src": ".org.apache.rocketmq.client.rpchook.NamespaceRpcHookTest#testDoBeforeRequestWithoutNamespace",
    "test_tgt": [
      ".org.apache.rocketmq.client.rpchook.NamespaceRpcHookTest#testDoBeforeRequestWithoutNamespace"
    ],
    "test_src_code": "    @Test\n    public void testDoBeforeRequestWithoutNamespace() {\n        clientConfig = new ClientConfig();\n        namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n        PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n        namespaceRpcHook.doBeforeRequest(\"\", request);\n        assertThat(pullMessageRequestHeader.getNamespaced()).isNull();\n        assertThat(pullMessageRequestHeader.getNamespace()).isNull();\n    }\n",
    "focal_path_src": [
      "client/src/main/java/org/apache/rocketmq/client/rpchook/NamespaceRpcHook.java#doBeforeRequest"
    ],
    "focal_path_tgt": [
      "client/src/main/java/org/apache/rocketmq/client/rpchook/NamespaceRpcHook.java#doBeforeRequest"
    ],
    "focal_src": [
      "    @Override\n    public void doBeforeRequest(String remoteAddr, RemotingCommand request) {\n        CommandCustomHeader customHeader = request.readCustomHeader();\n        if (customHeader instanceof RpcRequestHeader) {\n            RpcRequestHeader requestHeader = (RpcRequestHeader) customHeader;\n            if (StringUtils.isNotEmpty(clientConfig.getNamespaceV2())) {\n                requestHeader.setNamespaced(true);\n                requestHeader.setNamespace(clientConfig.getNamespaceV2());\n            }\n        }\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public void doBeforeRequest(String remoteAddr, RemotingCommand request) {\n        if (StringUtils.isNotEmpty(clientConfig.getNamespaceV2())) {\n            request.addExtField(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD, \"true\");\n            request.addExtField(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD, clientConfig.getNamespaceV2());\n        }\n    }\n"
    ],
    "test_id": 79,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "@Test\npublic void testDoBeforeRequestWithoutNamespace() {\n    clientConfig = new ClientConfig();\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isNull();\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isNull();\n}\n",
      "@Test\npublic void testDoBeforeRequestWithoutNamespace() {\n    clientConfig = new ClientConfig();\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(pullMessageRequestHeader.getNamespaced()).isNull();\n    assertThat(pullMessageRequestHeader.getNamespace()).isNull();\n}\n",
      "@Test\npublic void testDoBeforeRequestWithoutNamespace() {\n    clientConfig = new ClientConfig();\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, null);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isNull();\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isNull();\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "@Test\npublic void testDoBeforeRequestWithoutNamespace() {\n    clientConfig = new ClientConfig();\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isNull();\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isNull();\n    // Testing the covered line\n    clientConfig.setNamespaceV2(\"testNamespace\");\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isEqualTo(\"true\");\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isEqualTo(\"testNamespace\");\n}\n",
      "@Test\npublic void testDoBeforeRequestWithoutNamespace() {\n    clientConfig = new ClientConfig();\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(pullMessageRequestHeader.getNamespaced()).isNull();\n    assertThat(pullMessageRequestHeader.getNamespace()).isNull();\n    // Testing the uncovered lines\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isNull();\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isNull();\n}\n",
      "@Test\npublic void testDoBeforeRequestWithoutNamespace() {\n    clientConfig = new ClientConfig();\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, null);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isNull();\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isNull();\n    // Add more test cases to cover the uncovered lines and branches\n    clientConfig.setNamespaceV2(\"testNamespace\");\n    namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n    request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, null);\n    namespaceRpcHook.doBeforeRequest(\"\", request);\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isEqualTo(\"true\");\n    assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isEqualTo(\"testNamespace\");\n}\n"
    ]
  },
  "80": {
    "commit_src": "d1cc7428daade1c23046ca776d8bb945a74edf88",
    "commit_tgt": "b6efbb11ca599cdf0c0899479d1221d9cc65eeea",
    "changed_tests": [
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/core/MessageStoreFetcherImplTest.java",
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/FlatMessageFileTest.java"
    ],
    "refer_PR": "apache_rocketmq-7962",
    "test_src": ".org.apache.rocketmq.tieredstore.file.FlatMessageFileTest#testBinarySearchInQueueByTime",
    "test_tgt": [
      ".org.apache.rocketmq.tieredstore.file.FlatMessageFileTest#testBinarySearchInQueueByTime"
    ],
    "test_src_code": "    @Test\n    public void testBinarySearchInQueueByTime() {\n\n        // replace provider, need new factory again\n        storeConfig.setTieredBackendServiceProvider(PosixFileSegment.class.getName());\n        flatFileFactory = new FlatFileFactory(metadataStore, storeConfig);\n\n        // inject store time: 0, +100, +100, +100, +200\n        MessageQueue mq = new MessageQueue(\"TopicTest\", \"BrokerName\", 1);\n        FlatMessageFile flatFile = new FlatMessageFile(flatFileFactory, MessageStoreUtil.toFilePath(mq));\n        flatFile.initOffset(50);\n        long timestamp1 = 1000;\n        ByteBuffer buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 50);\n        buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp1);\n        flatFile.appendCommitLog(buffer);\n\n        long timestamp2 = timestamp1 + 100;\n        buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 51);\n        buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp2);\n        flatFile.appendCommitLog(buffer);\n        buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 52);\n        buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp2);\n        flatFile.appendCommitLog(buffer);\n        buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 53);\n        buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp2);\n        flatFile.appendCommitLog(buffer);\n\n        long timestamp3 = timestamp2 + 100;\n        buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n        buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 54);\n        buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp3);\n        flatFile.appendCommitLog(buffer);\n\n        // append message to consume queue\n        flatFile.consumeQueue.initOffset(50 * ConsumeQueue.CQ_STORE_UNIT_SIZE);\n\n        for (int i = 0; i < 5; i++) {\n            AppendResult appendResult = flatFile.appendConsumeQueue(new DispatchRequest(\n                mq.getTopic(), mq.getQueueId(), MessageFormatUtilTest.MSG_LEN * i,\n                MessageFormatUtilTest.MSG_LEN, 0, timestamp1, 50 + i,\n                \"\", \"\", 0, 0, null));\n            Assert.assertEquals(AppendResult.SUCCESS, appendResult);\n        }\n\n        // commit message will increase max consume queue offset\n        Assert.assertTrue(flatFile.commitAsync().join());\n\n        Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3 + 1, BoundaryType.UPPER).join().longValue());\n        Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3, BoundaryType.UPPER).join().longValue());\n\n        Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1 - 1, BoundaryType.LOWER).join().longValue());\n        Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1, BoundaryType.LOWER).join().longValue());\n\n        Assert.assertEquals(51, flatFile.getQueueOffsetByTimeAsync(timestamp1 + 1, BoundaryType.LOWER).join().longValue());\n        Assert.assertEquals(51, flatFile.getQueueOffsetByTimeAsync(timestamp2, BoundaryType.LOWER).join().longValue());\n        Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp2 + 1, BoundaryType.LOWER).join().longValue());\n        Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3, BoundaryType.LOWER).join().longValue());\n\n        Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1, BoundaryType.UPPER).join().longValue());\n        Assert.assertEquals(51, flatFile.getQueueOffsetByTimeAsync(timestamp1 + 1, BoundaryType.UPPER).join().longValue());\n        Assert.assertEquals(53, flatFile.getQueueOffsetByTimeAsync(timestamp2, BoundaryType.UPPER).join().longValue());\n        Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp2 + 1, BoundaryType.UPPER).join().longValue());\n\n        Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1 - 1, BoundaryType.UPPER).join().longValue());\n        Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3 + 1, BoundaryType.LOWER).join().longValue());\n\n        flatFile.destroy();\n    }\n",
    "focal_path_src": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatMessageFile.java#getQueueOffsetByTimeAsync"
    ],
    "focal_path_tgt": [
      "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatMessageFile.java#getQueueOffsetByTimeAsync"
    ],
    "focal_src": [
      "    @Override\n    public CompletableFuture<Long> getQueueOffsetByTimeAsync(long timestamp, BoundaryType boundaryType) {\n        long cqMin = getConsumeQueueMinOffset();\n        long cqMax = getConsumeQueueCommitOffset() - 1;\n        if (cqMax == -1 || cqMax < cqMin) {\n            return CompletableFuture.completedFuture(cqMin);\n        }\n\n        long minOffset = cqMin;\n        long maxOffset = cqMax;\n        List<String> queryLog = new ArrayList<>();\n        while (minOffset < maxOffset) {\n            long middle = minOffset + (maxOffset - minOffset) / 2;\n            ByteBuffer buffer = this.getMessageAsync(middle).join();\n            long storeTime = MessageFormatUtil.getStoreTimeStamp(buffer);\n            queryLog.add(String.format(\n                \"(range=%d-%d, middle=%d, timestamp=%d)\", minOffset, maxOffset, middle, storeTime));\n            if (storeTime == timestamp) {\n                minOffset = middle;\n                break;\n            } else if (storeTime < timestamp) {\n                minOffset = middle + 1;\n            } else {\n                maxOffset = middle - 1;\n            }\n        }\n\n        long offset = minOffset;\n        while (true) {\n            long next = boundaryType == BoundaryType.LOWER ? offset - 1 : offset + 1;\n            if (next < cqMin || next > cqMax) {\n                break;\n            }\n            ByteBuffer buffer = this.getMessageAsync(next).join();\n            long storeTime = MessageFormatUtil.getStoreTimeStamp(buffer);\n            if (storeTime == timestamp) {\n                offset = next;\n                continue;\n            }\n            break;\n        }\n\n        log.info(\"FlatMessageFile getQueueOffsetByTimeAsync, filePath={}, timestamp={}, result={}, log={}\",\n            filePath, timestamp, offset, JSON.toJSONString(queryLog));\n        return CompletableFuture.completedFuture(offset);\n    }\n"
    ],
    "focal_tgt": [
      "    @Override\n    public CompletableFuture<Long> getQueueOffsetByTimeAsync(long timestamp, BoundaryType boundaryType) {\n        long cqMin = getConsumeQueueMinOffset();\n        long cqMax = getConsumeQueueCommitOffset() - 1;\n        if (cqMax == -1 || cqMax < cqMin) {\n            return CompletableFuture.completedFuture(cqMin);\n        }\n\n        ByteBuffer buffer = getMessageAsync(cqMax).join();\n        long storeTime = MessageFormatUtil.getStoreTimeStamp(buffer);\n        if (storeTime < timestamp) {\n            log.info(\"FlatMessageFile getQueueOffsetByTimeAsync, exceeded maximum time, \" +\n                \"filePath={}, timestamp={}, result={}\", filePath, timestamp, cqMax + 1);\n            return CompletableFuture.completedFuture(cqMax + 1);\n        }\n\n        buffer = getMessageAsync(cqMin).join();\n        storeTime = MessageFormatUtil.getStoreTimeStamp(buffer);\n        if (storeTime > timestamp) {\n            log.info(\"FlatMessageFile getQueueOffsetByTimeAsync, less than minimum time, \" +\n                \"filePath={}, timestamp={}, result={}\", filePath, timestamp, cqMin);\n            return CompletableFuture.completedFuture(cqMin);\n        }\n\n        // binary search lower bound index in a sorted array\n        long minOffset = cqMin;\n        long maxOffset = cqMax;\n        List<String> queryLog = new ArrayList<>();\n        while (minOffset < maxOffset) {\n            long middle = minOffset + (maxOffset - minOffset) / 2;\n            buffer = this.getMessageAsync(middle).join();\n            storeTime = MessageFormatUtil.getStoreTimeStamp(buffer);\n            queryLog.add(String.format(\"(range=%d-%d, middle=%d, timestamp=%d, diff=%dms)\",\n                minOffset, maxOffset, middle, storeTime, timestamp - storeTime));\n            if (storeTime < timestamp) {\n                minOffset = middle + 1;\n            } else {\n                maxOffset = middle;\n            }\n        }\n\n        long offset = minOffset;\n        if (boundaryType == BoundaryType.UPPER) {\n            while (true) {\n                long next = offset + 1;\n                if (next > cqMax) {\n                    break;\n                }\n                buffer = this.getMessageAsync(next).join();\n                storeTime = MessageFormatUtil.getStoreTimeStamp(buffer);\n                if (storeTime == timestamp) {\n                    offset = next;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        log.info(\"FlatMessageFile getQueueOffsetByTimeAsync, filePath={}, timestamp={}, result={}, log={}\",\n            filePath, timestamp, offset, JSON.toJSONString(queryLog));\n        return CompletableFuture.completedFuture(offset);\n    }\n"
    ],
    "test_id": 80,
    "identify_result_deepseek-coder": true,
    "test_fix_deepseek-coder": [
      "// Fail to generate test fix. This is original test code.\n@Test\npublic void testBinarySearchInQueueByTime() {\n\n    // replace provider, need new factory again\n    storeConfig.setTieredBackendServiceProvider(PosixFileSegment.class.getName());\n    flatFileFactory = new FlatFileFactory(metadataStore, storeConfig);\n\n    // inject store time: 0, +100, +100, +100, +200\n    MessageQueue mq = new MessageQueue(\"TopicTest\", \"BrokerName\", 1);\n    FlatMessageFile flatFile = new FlatMessageFile(flatFileFactory, MessageStoreUtil.toFilePath(mq));\n    flatFile.initOffset(50);\n    long timestamp1 = 1000;\n    ByteBuffer buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n    buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 50);\n    buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp1);\n    flatFile.appendCommitLog(buffer);\n\n    long timestamp2 = timestamp1 + 100;\n    buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n    buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 51);\n    buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp2);\n    flatFile.appendCommitLog(buffer);\n    buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n    buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 52);\n    buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp2);\n    flatFile.appendCommitLog(buffer);\n    buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n    buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 53);\n    buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp2);\n    flatFile.appendCommitLog(buffer);\n\n    long timestamp3 = timestamp2 + 100;\n    buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n    buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 54);\n    buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp3);\n    flatFile.appendCommitLog(buffer);\n\n    // append message to consume queue\n    flatFile.consumeQueue.initOffset(50 * ConsumeQueue.CQ_STORE_UNIT_SIZE);\n\n    for (int i = 0; i < 5; i++) {\n        AppendResult appendResult = flatFile.appendConsumeQueue(new DispatchRequest(\n            mq.getTopic(), mq.getQueueId(), MessageFormatUtilTest.MSG_LEN * i,\n            MessageFormatUtilTest.MSG_LEN, 0, timestamp1, 50 + i,\n            \"\", \"\", 0, 0, null));\n        Assert.assertEquals(AppendResult.SUCCESS, appendResult);\n    }\n\n    // commit message will increase max consume queue offset\n    Assert.assertTrue(flatFile.commitAsync().join());\n\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3 + 1, BoundaryType.UPPER).join().longValue());\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3, BoundaryType.UPPER).join().longValue());\n\n    Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1 - 1, BoundaryType.LOWER).join().longValue());\n    Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1, BoundaryType.LOWER).join().longValue());\n\n    Assert.assertEquals(51, flatFile.getQueueOffsetByTimeAsync(timestamp1 + 1, BoundaryType.LOWER).join().longValue());\n    Assert.assertEquals(51, flatFile.getQueueOffsetByTimeAsync(timestamp2, BoundaryType.LOWER).join().longValue());\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp2 + 1, BoundaryType.LOWER).join().longValue());\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3, BoundaryType.LOWER).join().longValue());\n\n    Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1, BoundaryType.UPPER).join().longValue());\n    Assert.assertEquals(51, flatFile.getQueueOffsetByTimeAsync(timestamp1 + 1, BoundaryType.UPPER).join().longValue());\n    Assert.assertEquals(53, flatFile.getQueueOffsetByTimeAsync(timestamp2, BoundaryType.UPPER).join().longValue());\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp2 + 1, BoundaryType.UPPER).join().longValue());\n\n    Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1 - 1, BoundaryType.UPPER).join().longValue());\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3 + 1, BoundaryType.LOWER).join().longValue());\n\n    flatFile.destroy();\n}\n"
    ],
    "test_enhance_deepseek-coder": [
      "// Fail to generate test enhance. This is original test code.\n@Test\npublic void testBinarySearchInQueueByTime() {\n\n    // replace provider, need new factory again\n    storeConfig.setTieredBackendServiceProvider(PosixFileSegment.class.getName());\n    flatFileFactory = new FlatFileFactory(metadataStore, storeConfig);\n\n    // inject store time: 0, +100, +100, +100, +200\n    MessageQueue mq = new MessageQueue(\"TopicTest\", \"BrokerName\", 1);\n    FlatMessageFile flatFile = new FlatMessageFile(flatFileFactory, MessageStoreUtil.toFilePath(mq));\n    flatFile.initOffset(50);\n    long timestamp1 = 1000;\n    ByteBuffer buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n    buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 50);\n    buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp1);\n    flatFile.appendCommitLog(buffer);\n\n    long timestamp2 = timestamp1 + 100;\n    buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n    buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 51);\n    buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp2);\n    flatFile.appendCommitLog(buffer);\n    buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n    buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 52);\n    buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp2);\n    flatFile.appendCommitLog(buffer);\n    buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n    buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 53);\n    buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp2);\n    flatFile.appendCommitLog(buffer);\n\n    long timestamp3 = timestamp2 + 100;\n    buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n    buffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, 54);\n    buffer.putLong(MessageFormatUtil.STORE_TIMESTAMP_POSITION, timestamp3);\n    flatFile.appendCommitLog(buffer);\n\n    // append message to consume queue\n    flatFile.consumeQueue.initOffset(50 * ConsumeQueue.CQ_STORE_UNIT_SIZE);\n\n    for (int i = 0; i < 5; i++) {\n        AppendResult appendResult = flatFile.appendConsumeQueue(new DispatchRequest(\n            mq.getTopic(), mq.getQueueId(), MessageFormatUtilTest.MSG_LEN * i,\n            MessageFormatUtilTest.MSG_LEN, 0, timestamp1, 50 + i,\n            \"\", \"\", 0, 0, null));\n        Assert.assertEquals(AppendResult.SUCCESS, appendResult);\n    }\n\n    // commit message will increase max consume queue offset\n    Assert.assertTrue(flatFile.commitAsync().join());\n\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3 + 1, BoundaryType.UPPER).join().longValue());\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3, BoundaryType.UPPER).join().longValue());\n\n    Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1 - 1, BoundaryType.LOWER).join().longValue());\n    Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1, BoundaryType.LOWER).join().longValue());\n\n    Assert.assertEquals(51, flatFile.getQueueOffsetByTimeAsync(timestamp1 + 1, BoundaryType.LOWER).join().longValue());\n    Assert.assertEquals(51, flatFile.getQueueOffsetByTimeAsync(timestamp2, BoundaryType.LOWER).join().longValue());\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp2 + 1, BoundaryType.LOWER).join().longValue());\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3, BoundaryType.LOWER).join().longValue());\n\n    Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1, BoundaryType.UPPER).join().longValue());\n    Assert.assertEquals(51, flatFile.getQueueOffsetByTimeAsync(timestamp1 + 1, BoundaryType.UPPER).join().longValue());\n    Assert.assertEquals(53, flatFile.getQueueOffsetByTimeAsync(timestamp2, BoundaryType.UPPER).join().longValue());\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp2 + 1, BoundaryType.UPPER).join().longValue());\n\n    Assert.assertEquals(50, flatFile.getQueueOffsetByTimeAsync(timestamp1 - 1, BoundaryType.UPPER).join().longValue());\n    Assert.assertEquals(54, flatFile.getQueueOffsetByTimeAsync(timestamp3 + 1, BoundaryType.LOWER).join().longValue());\n\n    flatFile.destroy();\n}\n"
    ],
    "exception_while_gen_deepseek-coder": "OutOfMemoryError('CUDA out of memory. Tried to allocate 4.61 GiB. GPU 0 has a total capacty of 23.69 GiB of which 1.66 GiB is free. Process 1478252 has 22.02 GiB memory in use. Of the allocated memory 10.78 GiB is allocated by PyTorch, and 10.21 GiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF')"
  }
}