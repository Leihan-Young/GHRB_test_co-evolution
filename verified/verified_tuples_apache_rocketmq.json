{
  "1": {
    "commit_src": "03ffc45a8b93844b692b7a834cf28b922015de3a",
    "commit_tgt": "4af193e3253a8b7e15e8447ae00d6df079599919",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImplTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageUtilTest.java",
      "test/src/test/java/org/apache/rocketmq/test/container/ContainerIntegrationTestBase.java",
      "test/src/test/java/org/apache/rocketmq/test/container/TransactionListenerImpl.java",
      "test/src/test/java/org/apache/rocketmq/test/container/TransactionMessageIT.java"
    ],
    "refer_PR": "apache_rocketmq-5062",
    "test_src": ".org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImplTest#testCheck_withDiscard",
    "test_tgt": [
      ".org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImplTest#testCheck_withDiscard"
    ],
    "test_src_code": "    @Test\n    public void testCheck_withDiscard() {\n        when(bridge.fetchMessageQueues(TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC)).thenReturn(createMessageQueueSet(TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC));\n        when(bridge.getHalfMessage(0, 0, 1)).thenReturn(createDiscardPullResult(TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC, 5, \"hellp\", 1));\n        when(bridge.getHalfMessage(0, 1, 1)).thenReturn(createPullResult(TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC, 6, \"hellp\", 0));\n        when(bridge.getOpMessage(anyInt(), anyLong(), anyInt())).thenReturn(createOpPulResult(TopicValidator.RMQ_SYS_TRANS_OP_HALF_TOPIC, 1, \"10\", 1));\n        long timeOut = this.brokerController.getBrokerConfig().getTransactionTimeOut();\n        int checkMax = this.brokerController.getBrokerConfig().getTransactionCheckMax();\n        final AtomicInteger checkMessage = new AtomicInteger(0);\n        doAnswer(new Answer() {\n            @Override\n            public Object answer(InvocationOnMock invocation) {\n                checkMessage.addAndGet(1);\n                return null;\n            }\n        }).when(listener).resolveDiscardMsg(any(MessageExt.class));\n        queueTransactionMsgService.check(timeOut, checkMax, listener);\n        assertThat(checkMessage.get()).isEqualTo(1);\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImpl.java#check",
    "focal_src": "    @Override\n    public void check(long transactionTimeout, int transactionCheckMax,\n        AbstractTransactionalMessageCheckListener listener) {\n        try {\n            String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;\n            Set<MessageQueue> msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);\n            if (msgQueues == null || msgQueues.size() == 0) {\n                log.warn(\"The queue of topic is empty :\" + topic);\n                return;\n            }\n            log.debug(\"Check topic={}, queues={}\", topic, msgQueues);\n            for (MessageQueue messageQueue : msgQueues) {\n                long startTime = System.currentTimeMillis();\n                MessageQueue opQueue = getOpQueue(messageQueue);\n                long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);\n                long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);\n                log.info(\"Before check, the queue={} msgOffset={} opOffset={}\", messageQueue, halfOffset, opOffset);\n                if (halfOffset < 0 || opOffset < 0) {\n                    log.error(\"MessageQueue: {} illegal offset read: {}, op offset: {},skip this queue\", messageQueue,\n                        halfOffset, opOffset);\n                    continue;\n                }\n\n                List<Long> doneOpOffset = new ArrayList<>();\n                HashMap<Long, Long> removeMap = new HashMap<>();\n                PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);\n                if (null == pullResult) {\n                    log.error(\"The queue={} check msgOffset={} with opOffset={} failed, pullResult is null\",\n                        messageQueue, halfOffset, opOffset);\n                    continue;\n                }\n                // single thread\n                int getMessageNullCount = 1;\n                long newOffset = halfOffset;\n                long i = halfOffset;\n                while (true) {\n                    if (System.currentTimeMillis() - startTime > MAX_PROCESS_TIME_LIMIT) {\n                        log.info(\"Queue={} process time reach max={}\", messageQueue, MAX_PROCESS_TIME_LIMIT);\n                        break;\n                    }\n                    if (removeMap.containsKey(i)) {\n                        log.debug(\"Half offset {} has been committed/rolled back\", i);\n                        Long removedOpOffset = removeMap.remove(i);\n                        doneOpOffset.add(removedOpOffset);\n                    } else {\n                        GetResult getResult = getHalfMsg(messageQueue, i);\n                        MessageExt msgExt = getResult.getMsg();\n                        if (msgExt == null) {\n                            if (getMessageNullCount++ > MAX_RETRY_COUNT_WHEN_HALF_NULL) {\n                                break;\n                            }\n                            if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) {\n                                log.debug(\"No new msg, the miss offset={} in={}, continue check={}, pull result={}\", i,\n                                    messageQueue, getMessageNullCount, getResult.getPullResult());\n                                break;\n                            } else {\n                                log.info(\"Illegal offset, the miss offset={} in={}, continue check={}, pull result={}\",\n                                    i, messageQueue, getMessageNullCount, getResult.getPullResult());\n                                i = getResult.getPullResult().getNextBeginOffset();\n                                newOffset = i;\n                                continue;\n                            }\n                        }\n\n                        if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {\n                            listener.resolveDiscardMsg(msgExt);\n                            newOffset = i + 1;\n                            i++;\n                            continue;\n                        }\n                        if (msgExt.getStoreTimestamp() >= startTime) {\n                            log.debug(\"Fresh stored. the miss offset={}, check it later, store={}\", i,\n                                new Date(msgExt.getStoreTimestamp()));\n                            break;\n                        }\n\n                        long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();\n                        long checkImmunityTime = transactionTimeout;\n                        String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS);\n                        if (null != checkImmunityTimeStr) {\n                            checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);\n                            if (valueOfCurrentMinusBorn < checkImmunityTime) {\n                                if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) {\n                                    newOffset = i + 1;\n                                    i++;\n                                    continue;\n                                }\n                            }\n                        } else {\n                            if (0 <= valueOfCurrentMinusBorn && valueOfCurrentMinusBorn < checkImmunityTime) {\n                                log.debug(\"New arrived, the miss offset={}, check it later checkImmunity={}, born={}\", i,\n                                    checkImmunityTime, new Date(msgExt.getBornTimestamp()));\n                                break;\n                            }\n                        }\n                        List<MessageExt> opMsg = pullResult.getMsgFoundList();\n                        boolean isNeedCheck = opMsg == null && valueOfCurrentMinusBorn > checkImmunityTime\n                            || opMsg != null && opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout\n                            || valueOfCurrentMinusBorn <= -1;\n\n                        if (isNeedCheck) {\n                            if (!putBackHalfMsgQueue(msgExt, i)) {\n                                continue;\n                            }\n                            listener.resolveHalfMsg(msgExt);\n                        } else {\n                            pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);\n                            log.debug(\"The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}\", i,\n                                messageQueue, pullResult);\n                            continue;\n                        }\n                    }\n                    newOffset = i + 1;\n                    i++;\n                }\n                if (newOffset != halfOffset) {\n                    transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);\n                }\n                long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);\n                if (newOpOffset != opOffset) {\n                    transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);\n                }\n            }\n        } catch (Throwable e) {\n            log.error(\"Check error\", e);\n        }\n\n    }\n",
    "focal_tgt": "    @Override\n    public void check(long transactionTimeout, int transactionCheckMax,\n        AbstractTransactionalMessageCheckListener listener) {\n        try {\n            String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;\n            Set<MessageQueue> msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);\n            if (msgQueues == null || msgQueues.size() == 0) {\n                log.warn(\"The queue of topic is empty :\" + topic);\n                return;\n            }\n            log.debug(\"Check topic={}, queues={}\", topic, msgQueues);\n            for (MessageQueue messageQueue : msgQueues) {\n                long startTime = System.currentTimeMillis();\n                MessageQueue opQueue = getOpQueue(messageQueue);\n                long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);\n                long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);\n                log.info(\"Before check, the queue={} msgOffset={} opOffset={}\", messageQueue, halfOffset, opOffset);\n                if (halfOffset < 0 || opOffset < 0) {\n                    log.error(\"MessageQueue: {} illegal offset read: {}, op offset: {},skip this queue\", messageQueue,\n                        halfOffset, opOffset);\n                    continue;\n                }\n\n                List<Long> doneOpOffset = new ArrayList<>();\n                HashMap<Long, Long> removeMap = new HashMap<>();\n                PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);\n                if (null == pullResult) {\n                    log.error(\"The queue={} check msgOffset={} with opOffset={} failed, pullResult is null\",\n                        messageQueue, halfOffset, opOffset);\n                    continue;\n                }\n                // single thread\n                int getMessageNullCount = 1;\n                long newOffset = halfOffset;\n                long i = halfOffset;\n                int escapeFailCnt = 0;\n                while (true) {\n                    if (System.currentTimeMillis() - startTime > MAX_PROCESS_TIME_LIMIT) {\n                        log.info(\"Queue={} process time reach max={}\", messageQueue, MAX_PROCESS_TIME_LIMIT);\n                        break;\n                    }\n                    if (removeMap.containsKey(i)) {\n                        log.debug(\"Half offset {} has been committed/rolled back\", i);\n                        Long removedOpOffset = removeMap.remove(i);\n                        doneOpOffset.add(removedOpOffset);\n                    } else {\n                        GetResult getResult = getHalfMsg(messageQueue, i);\n                        MessageExt msgExt = getResult.getMsg();\n                        if (msgExt == null) {\n                            if (getMessageNullCount++ > MAX_RETRY_COUNT_WHEN_HALF_NULL) {\n                                break;\n                            }\n                            if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) {\n                                log.debug(\"No new msg, the miss offset={} in={}, continue check={}, pull result={}\", i,\n                                    messageQueue, getMessageNullCount, getResult.getPullResult());\n                                break;\n                            } else {\n                                log.info(\"Illegal offset, the miss offset={} in={}, continue check={}, pull result={}\",\n                                    i, messageQueue, getMessageNullCount, getResult.getPullResult());\n                                i = getResult.getPullResult().getNextBeginOffset();\n                                newOffset = i;\n                                continue;\n                            }\n                        }\n\n                        if (this.transactionalMessageBridge.getBrokerController().getBrokerConfig().isEnableSlaveActingMaster()\n                            && this.transactionalMessageBridge.getBrokerController().getMinBrokerIdInGroup()\n                            == this.transactionalMessageBridge.getBrokerController().getBrokerIdentity().getBrokerId()\n                            && BrokerRole.SLAVE.equals(this.transactionalMessageBridge.getBrokerController().getMessageStoreConfig().getBrokerRole())\n                        ) {\n                            final MessageExtBrokerInner msgInner = this.transactionalMessageBridge.renewHalfMessageInner(msgExt);\n                            final boolean isSuccess = this.transactionalMessageBridge.escapeMessage(msgInner);\n\n                            if (isSuccess) {\n                                escapeFailCnt = 0;\n                                newOffset = i + 1;\n                                i++;\n                            } else {\n                                log.warn(\"Escaping transactional message failed {} times! msgId(offsetId)={}, UNIQ_KEY(transactionId)={}\",\n                                    escapeFailCnt + 1,\n                                    msgExt.getMsgId(),\n                                    msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));\n                                if (escapeFailCnt < MAX_RETRY_TIMES_FOR_ESCAPE) {\n                                    escapeFailCnt++;\n                                    Thread.sleep(100L * (2 ^ escapeFailCnt));\n                                } else {\n                                    escapeFailCnt = 0;\n                                    newOffset = i + 1;\n                                    i++;\n                                }\n                            }\n                            continue;\n                        }\n\n                        if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {\n                            listener.resolveDiscardMsg(msgExt);\n                            newOffset = i + 1;\n                            i++;\n                            continue;\n                        }\n                        if (msgExt.getStoreTimestamp() >= startTime) {\n                            log.debug(\"Fresh stored. the miss offset={}, check it later, store={}\", i,\n                                new Date(msgExt.getStoreTimestamp()));\n                            break;\n                        }\n\n                        long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();\n                        long checkImmunityTime = transactionTimeout;\n                        String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS);\n                        if (null != checkImmunityTimeStr) {\n                            checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);\n                            if (valueOfCurrentMinusBorn < checkImmunityTime) {\n                                if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) {\n                                    newOffset = i + 1;\n                                    i++;\n                                    continue;\n                                }\n                            }\n                        } else {\n                            if (0 <= valueOfCurrentMinusBorn && valueOfCurrentMinusBorn < checkImmunityTime) {\n                                log.debug(\"New arrived, the miss offset={}, check it later checkImmunity={}, born={}\", i,\n                                    checkImmunityTime, new Date(msgExt.getBornTimestamp()));\n                                break;\n                            }\n                        }\n                        List<MessageExt> opMsg = pullResult.getMsgFoundList();\n                        boolean isNeedCheck = opMsg == null && valueOfCurrentMinusBorn > checkImmunityTime\n                            || opMsg != null && opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout\n                            || valueOfCurrentMinusBorn <= -1;\n\n                        if (isNeedCheck) {\n                            if (!putBackHalfMsgQueue(msgExt, i)) {\n                                continue;\n                            }\n                            listener.resolveHalfMsg(msgExt);\n                        } else {\n                            pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);\n                            log.debug(\"The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}\", i,\n                                messageQueue, pullResult);\n                            continue;\n                        }\n                    }\n                    newOffset = i + 1;\n                    i++;\n                }\n                if (newOffset != halfOffset) {\n                    transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);\n                }\n                long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);\n                if (newOpOffset != opOffset) {\n                    transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);\n                }\n            }\n        } catch (Throwable e) {\n            log.error(\"Check error\", e);\n        }\n\n    }\n",
    "test_id": 1
  },
  "2": {
    "commit_src": "a7c1d49454ce405fc651f95d036571d91bd8c9e0",
    "commit_tgt": "d54f8cb1eba99b0c83131ccbce193ad64380d0ef",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/failover/EscapeBridgeTest.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopNormally.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopBigMessageIT.java"
    ],
    "refer_PR": "apache_rocketmq-5403",
    "test_src": ".org.apache.rocketmq.broker.failover.EscapeBridgeTest#getMessageTest",
    "test_tgt": [
      ".org.apache.rocketmq.broker.failover.EscapeBridgeTest#getMessageTest"
    ],
    "test_src_code": "    @Test\n    public void getMessageTest() {\n        when(brokerController.peekMasterBroker()).thenReturn(brokerController);\n        when(brokerController.getMessageStoreByBrokerName(any())).thenReturn(defaultMessageStore);\n        Assertions.assertThatCode(() -> escapeBridge.putMessage(messageExtBrokerInner)).doesNotThrowAnyException();\n\n        Assertions.assertThatCode(() -> escapeBridge.getMessage(TEST_TOPIC, 0, DEFAULT_QUEUE_ID, BROKER_NAME)).doesNotThrowAnyException();\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/failover/EscapeBridge.java#getMessage",
    "focal_src": "    public MessageExt getMessage(String topic, long offset, int queueId, String brokerName) {\n        MessageStore messageStore = brokerController.getMessageStoreByBrokerName(brokerName);\n        if (messageStore != null) {\n            final GetMessageResult getMessageTmpResult = messageStore.getMessage(innerConsumerGroupName, topic, queueId, offset, 1, null);\n            if (getMessageTmpResult == null) {\n                LOG.warn(\"getMessageResult is null , innerConsumerGroupName {}, topic {}, offset {}, queueId {}\", innerConsumerGroupName, topic, offset, queueId);\n                return null;\n            }\n            List<MessageExt> list = decodeMsgList(getMessageTmpResult);\n            if (list == null || list.isEmpty()) {\n                LOG.warn(\"Can not get msg , topic {}, offset {}, queueId {}, result is {}\", topic, offset, queueId, getMessageTmpResult);\n                return null;\n            } else {\n                return list.get(0);\n            }\n        } else {\n            return getMessageFromRemote(topic, offset, queueId, brokerName);\n        }\n    }\n",
    "focal_tgt": "    public MessageExt getMessage(String topic, long offset, int queueId, String brokerName, boolean deCompressBody) {\n        MessageStore messageStore = brokerController.getMessageStoreByBrokerName(brokerName);\n        if (messageStore != null) {\n            final GetMessageResult getMessageTmpResult = messageStore.getMessage(innerConsumerGroupName, topic, queueId, offset, 1, null);\n            if (getMessageTmpResult == null) {\n                LOG.warn(\"getMessageResult is null , innerConsumerGroupName {}, topic {}, offset {}, queueId {}\", innerConsumerGroupName, topic, offset, queueId);\n                return null;\n            }\n            List<MessageExt> list = decodeMsgList(getMessageTmpResult, deCompressBody);\n            if (list == null || list.isEmpty()) {\n                LOG.warn(\"Can not get msg , topic {}, offset {}, queueId {}, result is {}\", topic, offset, queueId, getMessageTmpResult);\n                return null;\n            } else {\n                return list.get(0);\n            }\n        } else {\n            return getMessageFromRemote(topic, offset, queueId, brokerName);\n        }\n    }\n",
    "test_id": 2
  },
  "3": {
    "commit_src": "a7c1d49454ce405fc651f95d036571d91bd8c9e0",
    "commit_tgt": "d54f8cb1eba99b0c83131ccbce193ad64380d0ef",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/failover/EscapeBridgeTest.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopNormally.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopBigMessageIT.java"
    ],
    "refer_PR": "apache_rocketmq-5403",
    "test_src": ".org.apache.rocketmq.broker.failover.EscapeBridgeTest#decodeMsgListTest",
    "test_tgt": [
      ".org.apache.rocketmq.broker.failover.EscapeBridgeTest#decodeMsgListTest"
    ],
    "test_src_code": "    @Test\n    public void decodeMsgListTest() {\n        ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n        MappedFile mappedFile = new DefaultMappedFile();\n        SelectMappedBufferResult result = new SelectMappedBufferResult(0, byteBuffer, 10, mappedFile);\n\n        getMessageResult.addMessage(result);\n        Assertions.assertThatCode(() -> escapeBridge.decodeMsgList(getMessageResult)).doesNotThrowAnyException();\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/failover/EscapeBridge.java#decodeMsgList",
    "focal_src": "    protected List<MessageExt> decodeMsgList(GetMessageResult getMessageResult) {\n        List<MessageExt> foundList = new ArrayList<>();\n        try {\n            List<ByteBuffer> messageBufferList = getMessageResult.getMessageBufferList();\n            if (messageBufferList != null) {\n                for (int i = 0; i < messageBufferList.size(); i++) {\n                    ByteBuffer bb = messageBufferList.get(i);\n                    if (bb == null) {\n                        LOG.error(\"bb is null {}\", getMessageResult);\n                        continue;\n                    }\n                    MessageExt msgExt = MessageDecoder.decode(bb);\n                    if (msgExt == null) {\n                        LOG.error(\"decode msgExt is null {}\", getMessageResult);\n                        continue;\n                    }\n                    // use CQ offset, not offset in Message\n                    msgExt.setQueueOffset(getMessageResult.getMessageQueueOffset().get(i));\n                    foundList.add(msgExt);\n                }\n            }\n        } finally {\n            getMessageResult.release();\n        }\n\n        return foundList;\n    }\n",
    "focal_tgt": "    protected List<MessageExt> decodeMsgList(GetMessageResult getMessageResult, boolean deCompressBody) {\n        List<MessageExt> foundList = new ArrayList<>();\n        try {\n            List<ByteBuffer> messageBufferList = getMessageResult.getMessageBufferList();\n            if (messageBufferList != null) {\n                for (int i = 0; i < messageBufferList.size(); i++) {\n                    ByteBuffer bb = messageBufferList.get(i);\n                    if (bb == null) {\n                        LOG.error(\"bb is null {}\", getMessageResult);\n                        continue;\n                    }\n                    MessageExt msgExt = MessageDecoder.decode(bb, true, deCompressBody);\n                    if (msgExt == null) {\n                        LOG.error(\"decode msgExt is null {}\", getMessageResult);\n                        continue;\n                    }\n                    // use CQ offset, not offset in Message\n                    msgExt.setQueueOffset(getMessageResult.getMessageQueueOffset().get(i));\n                    foundList.add(msgExt);\n                }\n            }\n        } finally {\n            getMessageResult.release();\n        }\n\n        return foundList;\n    }\n",
    "test_id": 3
  },
  "4": {
    "commit_src": "48ed8980719c14fde8ce145e5d585c6c0852920f",
    "commit_tgt": "407d2738f2d8b20a8ea264c75dbfc876ecb8519e",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/NetworkUtilTest.java"
    ],
    "refer_PR": "apache_rocketmq-5513",
    "test_src": ".org.apache.rocketmq.common.NetworkUtilTest#testGetLocalAddress",
    "test_tgt": [
      ".org.apache.rocketmq.common.NetworkUtilTest#testGetLocalAddress"
    ],
    "test_src_code": "    @Test\n    public void testGetLocalAddress() throws Exception {\n        String localAddress = NetworkUtil.getLocalAddress();\n        assertThat(localAddress).isNotNull();\n        assertThat(localAddress.length()).isGreaterThan(0);\n    }\n",
    "focal_path": "common/src/main/java/org/apache/rocketmq/common/utils/NetworkUtil.java#getLocalAddress",
    "focal_src": "    public static String getLocalAddress() {\n        try {\n            // Traversal Network interface to get the first non-loopback and non-private address\n            Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n            ArrayList<String> ipv4Result = new ArrayList<>();\n            ArrayList<String> ipv6Result = new ArrayList<>();\n            while (enumeration.hasMoreElements()) {\n                final NetworkInterface networkInterface = enumeration.nextElement();\n                if (isBridge(networkInterface)) {\n                    continue;\n                }\n\n                final Enumeration<InetAddress> en = networkInterface.getInetAddresses();\n                while (en.hasMoreElements()) {\n                    final InetAddress address = en.nextElement();\n                    if (!address.isLoopbackAddress()) {\n                        if (address instanceof Inet6Address) {\n                            ipv6Result.add(normalizeHostAddress(address));\n                        } else {\n                            ipv4Result.add(normalizeHostAddress(address));\n                        }\n                    }\n                }\n            }\n\n            // prefer ipv4\n            if (!ipv4Result.isEmpty()) {\n                for (String ip : ipv4Result) {\n                    if (ip.startsWith(\"127.0\") || ip.startsWith(\"192.168\")) {\n                        continue;\n                    }\n\n                    return ip;\n                }\n\n                return ipv4Result.get(ipv4Result.size() - 1);\n            } else if (!ipv6Result.isEmpty()) {\n                return ipv6Result.get(0);\n            }\n            //If failed to find,fall back to localhost\n            final InetAddress localHost = InetAddress.getLocalHost();\n            return normalizeHostAddress(localHost);\n        } catch (Exception e) {\n            log.error(\"Failed to obtain local address\", e);\n        }\n\n        return null;\n    }\n",
    "focal_tgt": "    public static String getLocalAddress() {\n        try {\n            // Traversal Network interface to get the first non-loopback and non-private address\n            Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n            ArrayList<String> ipv4Result = new ArrayList<>();\n            ArrayList<String> ipv6Result = new ArrayList<>();\n            while (enumeration.hasMoreElements()) {\n                final NetworkInterface nif = enumeration.nextElement();\n                if (isBridge(nif) || nif.isVirtual() || nif.isPointToPoint() || !nif.isUp()) {\n                    continue;\n                }\n\n                final Enumeration<InetAddress> en = nif.getInetAddresses();\n                while (en.hasMoreElements()) {\n                    final InetAddress address = en.nextElement();\n                    if (!address.isLoopbackAddress()) {\n                        if (address instanceof Inet6Address) {\n                            ipv6Result.add(normalizeHostAddress(address));\n                        } else {\n                            ipv4Result.add(normalizeHostAddress(address));\n                        }\n                    }\n                }\n            }\n\n            // prefer ipv4\n            if (!ipv4Result.isEmpty()) {\n                for (String ip : ipv4Result) {\n                    if (ip.startsWith(\"127.0\") || ip.startsWith(\"192.168\")) {\n                        continue;\n                    }\n\n                    return ip;\n                }\n\n                return ipv4Result.get(ipv4Result.size() - 1);\n            } else if (!ipv6Result.isEmpty()) {\n                return ipv6Result.get(0);\n            }\n            //If failed to find,fall back to localhost\n            final InetAddress localHost = InetAddress.getLocalHost();\n            return normalizeHostAddress(localHost);\n        } catch (Exception e) {\n            log.error(\"Failed to obtain local address\", e);\n        }\n\n        return null;\n    }\n",
    "test_id": 4
  },
  "5": {
    "commit_src": "44072e62bdba8ef1111808046f06c081c766d4ae",
    "commit_tgt": "da5a5b62927d041ad858bc4dd973e1bf68abcb1b",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/RegisterBrokerBodyTest.java"
    ],
    "refer_PR": "apache_rocketmq-5539",
    "test_src": ".org.apache.rocketmq.remoting.protocol.RegisterBrokerBodyTest#test_encode_decode",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.protocol.RegisterBrokerBodyTest#test_encode_decode"
    ],
    "test_src_code": "    @Test\n    public void test_encode_decode() throws IOException {\n        RegisterBrokerBody registerBrokerBody = new RegisterBrokerBody();\n        TopicConfigAndMappingSerializeWrapper topicConfigSerializeWrapper = new TopicConfigAndMappingSerializeWrapper();\n        registerBrokerBody.setTopicConfigSerializeWrapper(topicConfigSerializeWrapper);\n\n        ConcurrentMap<String, TopicConfig> topicConfigTable = new ConcurrentHashMap<>();\n        for (int i = 0; i < 10000; i++) {\n            topicConfigTable.put(String.valueOf(i), new TopicConfig(String.valueOf(i)));\n        }\n\n        topicConfigSerializeWrapper.setTopicConfigTable(topicConfigTable);\n\n        byte[] compareEncode = registerBrokerBody.encode(true);\n        byte[] encode2 = registerBrokerBody.encode(false);\n        RegisterBrokerBody decodeRegisterBrokerBody = RegisterBrokerBody.decode(compareEncode, true);\n\n        assertEquals(registerBrokerBody.getTopicConfigSerializeWrapper().getTopicConfigTable().size(), decodeRegisterBrokerBody.getTopicConfigSerializeWrapper().getTopicConfigTable().size());\n\n    }\n",
    "focal_path": "remoting/src/main/java/org/apache/rocketmq/remoting/protocol/body/RegisterBrokerBody.java#decode",
    "focal_src": "    public static RegisterBrokerBody decode(byte[] data, boolean compressed) throws IOException {\n        if (!compressed) {\n            return RegisterBrokerBody.decode(data, RegisterBrokerBody.class);\n        }\n        long start = System.currentTimeMillis();\n        InflaterInputStream inflaterInputStream = new InflaterInputStream(new ByteArrayInputStream(data));\n        int dataVersionLength = readInt(inflaterInputStream);\n        byte[] dataVersionBytes = readBytes(inflaterInputStream, dataVersionLength);\n        DataVersion dataVersion = DataVersion.decode(dataVersionBytes, DataVersion.class);\n\n        RegisterBrokerBody registerBrokerBody = new RegisterBrokerBody();\n        registerBrokerBody.getTopicConfigSerializeWrapper().setDataVersion(dataVersion);\n        ConcurrentMap<String, TopicConfig> topicConfigTable = registerBrokerBody.getTopicConfigSerializeWrapper().getTopicConfigTable();\n\n        int topicConfigNumber = readInt(inflaterInputStream);\n        LOGGER.debug(\"{} topic configs to extract\", topicConfigNumber);\n\n        for (int i = 0; i < topicConfigNumber; i++) {\n            int topicConfigJsonLength = readInt(inflaterInputStream);\n\n            byte[] buffer = readBytes(inflaterInputStream, topicConfigJsonLength);\n            TopicConfig topicConfig = new TopicConfig();\n            String topicConfigJson = new String(buffer, MixAll.DEFAULT_CHARSET);\n            topicConfig.decode(topicConfigJson);\n            topicConfigTable.put(topicConfig.getTopicName(), topicConfig);\n        }\n\n        int filterServerListJsonLength = readInt(inflaterInputStream);\n\n        byte[] filterServerListBuffer = readBytes(inflaterInputStream, filterServerListJsonLength);\n        String filterServerListJson = new String(filterServerListBuffer, MixAll.DEFAULT_CHARSET);\n        List<String> filterServerList = new ArrayList<>();\n        try {\n            filterServerList = JSON.parseArray(filterServerListJson, String.class);\n        } catch (Exception e) {\n            LOGGER.error(\"Decompressing occur Exception {}\", filterServerListJson);\n        }\n\n        registerBrokerBody.setFilterServerList(filterServerList);\n\n        int topicQueueMappingNum =  readInt(inflaterInputStream);\n        Map<String/* topic */, TopicQueueMappingInfo> topicQueueMappingInfoMap = new ConcurrentHashMap<>();\n        for (int i = 0; i < topicQueueMappingNum; i++) {\n            int mappingJsonLen = readInt(inflaterInputStream);\n            byte[] buffer = readBytes(inflaterInputStream, mappingJsonLen);\n            TopicQueueMappingInfo info = TopicQueueMappingInfo.decode(buffer, TopicQueueMappingInfo.class);\n            topicQueueMappingInfoMap.put(info.getTopic(), info);\n        }\n        registerBrokerBody.getTopicConfigSerializeWrapper().setTopicQueueMappingInfoMap(topicQueueMappingInfoMap);\n\n        long interval = System.currentTimeMillis() - start;\n        if (interval > 50) {\n            LOGGER.info(\"Decompressing takes {}ms\", interval);\n        }\n        return registerBrokerBody;\n    }\n",
    "focal_tgt": "    public static RegisterBrokerBody decode(byte[] data, boolean compressed, MQVersion.Version brokerVersion) throws IOException {\n        if (!compressed) {\n            return RegisterBrokerBody.decode(data, RegisterBrokerBody.class);\n        }\n        long start = System.currentTimeMillis();\n        InflaterInputStream inflaterInputStream = new InflaterInputStream(new ByteArrayInputStream(data));\n        int dataVersionLength = readInt(inflaterInputStream);\n        byte[] dataVersionBytes = readBytes(inflaterInputStream, dataVersionLength);\n        DataVersion dataVersion = DataVersion.decode(dataVersionBytes, DataVersion.class);\n\n        RegisterBrokerBody registerBrokerBody = new RegisterBrokerBody();\n        registerBrokerBody.getTopicConfigSerializeWrapper().setDataVersion(dataVersion);\n        ConcurrentMap<String, TopicConfig> topicConfigTable = registerBrokerBody.getTopicConfigSerializeWrapper().getTopicConfigTable();\n\n        int topicConfigNumber = readInt(inflaterInputStream);\n        LOGGER.debug(\"{} topic configs to extract\", topicConfigNumber);\n\n        for (int i = 0; i < topicConfigNumber; i++) {\n            int topicConfigJsonLength = readInt(inflaterInputStream);\n\n            byte[] buffer = readBytes(inflaterInputStream, topicConfigJsonLength);\n            TopicConfig topicConfig = new TopicConfig();\n            String topicConfigJson = new String(buffer, MixAll.DEFAULT_CHARSET);\n            topicConfig.decode(topicConfigJson);\n            topicConfigTable.put(topicConfig.getTopicName(), topicConfig);\n        }\n\n        int filterServerListJsonLength = readInt(inflaterInputStream);\n\n        byte[] filterServerListBuffer = readBytes(inflaterInputStream, filterServerListJsonLength);\n        String filterServerListJson = new String(filterServerListBuffer, MixAll.DEFAULT_CHARSET);\n        List<String> filterServerList = new ArrayList<>();\n        try {\n            filterServerList = JSON.parseArray(filterServerListJson, String.class);\n        } catch (Exception e) {\n            LOGGER.error(\"Decompressing occur Exception {}\", filterServerListJson);\n        }\n\n        registerBrokerBody.setFilterServerList(filterServerList);\n\n        if (brokerVersion.ordinal() >= MQVersion.Version.V5_0_0.ordinal()) {\n            int topicQueueMappingNum = readInt(inflaterInputStream);\n            Map<String/* topic */, TopicQueueMappingInfo> topicQueueMappingInfoMap = new ConcurrentHashMap<>();\n            for (int i = 0; i < topicQueueMappingNum; i++) {\n                int mappingJsonLen = readInt(inflaterInputStream);\n                byte[] buffer = readBytes(inflaterInputStream, mappingJsonLen);\n                TopicQueueMappingInfo info = TopicQueueMappingInfo.decode(buffer, TopicQueueMappingInfo.class);\n                topicQueueMappingInfoMap.put(info.getTopic(), info);\n            }\n            registerBrokerBody.getTopicConfigSerializeWrapper().setTopicQueueMappingInfoMap(topicQueueMappingInfoMap);\n        }\n\n        long interval = System.currentTimeMillis() - start;\n        if (interval > 50) {\n            LOGGER.info(\"Decompressing takes {}ms\", interval);\n        }\n        return registerBrokerBody;\n    }\n",
    "test_id": 5
  },
  "6": {
    "commit_src": "59acc7d3554d61f046233fc00308b07b7a7b39fb",
    "commit_tgt": "e5fadc7db7c4a5c098e5f912a19fd71cba3dde3d",
    "changed_tests": [
      "client/src/test/java/org/apache/rocketmq/client/consumer/DefaultLitePullConsumerTest.java"
    ],
    "refer_PR": "apache_rocketmq-5640",
    "test_src": ".org.apache.rocketmq.client.consumer.DefaultLitePullConsumerTest#testConsumerCommitSyncWithMQOffset",
    "test_tgt": [
      ".org.apache.rocketmq.client.consumer.DefaultLitePullConsumerTest#testConsumerCommitSyncWithMQOffset"
    ],
    "test_src_code": "    @Test\n    public void testConsumerCommitSyncWithMQOffset() throws Exception {\n        DefaultLitePullConsumer litePullConsumer = createNotStartLitePullConsumer();\n        RemoteBrokerOffsetStore store = new RemoteBrokerOffsetStore(mQClientFactory, consumerGroup);\n        litePullConsumer.setOffsetStore(store);\n        litePullConsumer.start();\n        initDefaultLitePullConsumer(litePullConsumer);\n\n        //replace with real offsetStore.\n        Field offsetStore = litePullConsumerImpl.getClass().getDeclaredField(\"offsetStore\");\n        offsetStore.setAccessible(true);\n        offsetStore.set(litePullConsumerImpl, store);\n\n        MessageQueue messageQueue = createMessageQueue();\n        HashSet<MessageQueue> set = new HashSet<>();\n        set.add(messageQueue);\n\n        //mock assign and reset offset\n        litePullConsumer.assign(set);\n        litePullConsumer.seek(messageQueue, 0);\n        await().atMost(Duration.ofSeconds(5)).untilAsserted(() -> assertThat(litePullConsumer.committed(messageQueue)).isEqualTo(0));\n        //commit offset 1\n        Map<MessageQueue, Long> commitOffset = new HashMap<>();\n        commitOffset.put(messageQueue, 1L);\n        litePullConsumer.commitSync(commitOffset, true);\n\n        assertThat(litePullConsumer.committed(messageQueue)).isEqualTo(1);\n    }\n",
    "focal_path": "client/src/main/java/org/apache/rocketmq/client/consumer/DefaultLitePullConsumer.java#commitSync",
    "focal_src": "    @Override\n    public void commitSync() {\n        this.defaultLitePullConsumerImpl.commitAll();\n    }\n",
    "focal_tgt": "    @Deprecated\n    @Override\n    public void commitSync() {\n        this.defaultLitePullConsumerImpl.commitAll();\n    }\n",
    "test_id": 6
  },
  "7": {
    "commit_src": "0533816d42961d0ba0ea012a115261ea71dd30c4",
    "commit_tgt": "5894332918e7158d6ff4cc35b126a1b82a1f6b0c",
    "changed_tests": [
      "tools/src/test/java/org/apache/rocketmq/tools/command/broker/BrokerStatusSubCommandTest.java"
    ],
    "refer_PR": "apache_rocketmq-5818",
    "test_src": ".org.apache.rocketmq.tools.command.broker.BrokerStatusSubCommandTest#testExecute",
    "test_tgt": [
      ".org.apache.rocketmq.tools.command.broker.BrokerStatusSubCommandTest#testExecute"
    ],
    "test_src_code": "    @Test\n    public void testExecute() throws SubCommandException {\n        BrokerStatusSubCommand cmd = new BrokerStatusSubCommand();\n        Options options = ServerUtil.buildCommandlineOptions(new Options());\n        String[] subargs = new String[] {\"-b 127.0.0.1:\" + listenPort(), \"-c default-cluster\"};\n        final CommandLine commandLine =\n            ServerUtil.parseCmdLine(\"mqadmin \" + cmd.commandName(), subargs,\n                cmd.buildCommandlineOptions(options), new DefaultParser());\n\n        cmd.execute(commandLine, options, null);\n    }\n",
    "focal_path": "tools/src/main/java/org/apache/rocketmq/tools/command/broker/BrokerStatusSubCommand.java#buildCommandlineOptions",
    "focal_src": "    @Override\n    public Options buildCommandlineOptions(Options options) {\n        Option opt = new Option(\"b\", \"brokerAddr\", true, \"Broker address\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"c\", \"clusterName\", true, \"which cluster\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        return options;\n    }\n",
    "focal_tgt": "    @Override\n    public Options buildCommandlineOptions(Options options) {\n        OptionGroup optionGroup = new OptionGroup();\n        Option opt = new Option(\"b\", \"brokerAddr\", true, \"Broker address\");\n        optionGroup.addOption(opt);\n\n        opt = new Option(\"c\", \"clusterName\", true, \"which cluster\");\n        optionGroup.addOption(opt);\n\n        optionGroup.setRequired(true);\n        options.addOptionGroup(optionGroup);\n\n        return options;\n    }\n",
    "test_id": 7
  },
  "8": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_TopicNotExist",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_TopicNotExist",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "test_src_code": "    @Test\n    public void testProcessRequest_TopicNotExist() throws RemotingCommandException {\n        brokerController.getTopicConfigManager().getTopicConfigTable().remove(topic);\n        final RemotingCommand request = createPopMsgCommand();\n        RemotingCommand response = popMessageProcessor.processRequest(handlerContext, request);\n        assertThat(response).isNotNull();\n        assertThat(response.getCode()).isEqualTo(ResponseCode.TOPIC_NOT_EXIST);\n        assertThat(response.getRemark()).contains(\"topic[\" + topic + \"] not exist\");\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest",
    "focal_src": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "focal_tgt": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "test_id": 8
  },
  "9": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_Found",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_Found",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "test_src_code": "    @Test\n    public void testProcessRequest_Found() throws RemotingCommandException, InterruptedException {\n        GetMessageResult getMessageResult = createGetMessageResult(1);\n        when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n        final RemotingCommand request = createPopMsgCommand();\n        popMessageProcessor.processRequest(handlerContext, request);\n        RemotingCommand response = embeddedChannel.readOutbound();\n        assertThat(response).isNotNull();\n        assertThat(response.getCode()).isEqualTo(ResponseCode.SUCCESS);\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest",
    "focal_src": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "focal_tgt": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "test_id": 9
  },
  "10": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_MsgWasRemoving",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_MsgWasRemoving",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "test_src_code": "    @Test\n    public void testProcessRequest_MsgWasRemoving() throws RemotingCommandException {\n        GetMessageResult getMessageResult = createGetMessageResult(1);\n        getMessageResult.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n        when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n        final RemotingCommand request = createPopMsgCommand();\n        popMessageProcessor.processRequest(handlerContext, request);\n        RemotingCommand response = embeddedChannel.readOutbound();\n        assertThat(response).isNotNull();\n        assertThat(response.getCode()).isEqualTo(ResponseCode.SUCCESS);\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest",
    "focal_src": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "focal_tgt": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "test_id": 10
  },
  "11": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_NoMsgInQueue",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_NoMsgInQueue",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "test_src_code": "    @Test\n    public void testProcessRequest_NoMsgInQueue() throws RemotingCommandException {\n        GetMessageResult getMessageResult = createGetMessageResult(0);\n        getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n        when(messageStore.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(getMessageResult));\n\n        final RemotingCommand request = createPopMsgCommand();\n        RemotingCommand response = popMessageProcessor.processRequest(handlerContext, request);\n        assertThat(response).isNull();\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest",
    "focal_src": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "focal_tgt": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "test_id": 11
  },
  "12": {
    "commit_src": "b00c82caccea8d8a23614c1854885d0a187e159e",
    "commit_tgt": "dcf7ccdd9ba92c22a44cde4c1df36c4d1ef6a172",
    "changed_tests": [
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java"
    ],
    "refer_PR": "apache_rocketmq-6651",
    "test_src": ".org.apache.rocketmq.tieredstore.TieredMessageStoreTest#testGetMessageAsync",
    "test_tgt": [
      ".org.apache.rocketmq.tieredstore.TieredMessageStoreTest#testGetMessageAsync"
    ],
    "test_src_code": "    @Test\n    public void testGetMessageAsync() {\n        mockContainer();\n        GetMessageResult result1 = new GetMessageResult();\n        result1.setStatus(GetMessageStatus.FOUND);\n        GetMessageResult result2 = new GetMessageResult();\n        result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);\n\n        when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));\n        when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);\n        Assert.assertSame(result1, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n\n        // TieredStorageLevel.FORCE\n        Properties properties = new Properties();\n        properties.setProperty(\"tieredStorageLevel\", \"3\");\n        configuration.update(properties);\n        when(nextStore.checkInDiskByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);\n        Assert.assertSame(result2, store.getMessage(\"group\", mq.getTopic(), mq.getQueueId(), 0, 0, null));\n    }\n",
    "focal_path": "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/TieredMessageStore.java#getMessageAsync",
    "focal_src": "    @Override\n    public CompletableFuture<GetMessageResult> getMessageAsync(String group, String topic,\n        int queueId, long offset, int maxMsgNums, MessageFilter messageFilter) {\n        if (viaTieredStorage(topic, queueId, offset, maxMsgNums)) {\n            Stopwatch stopwatch = Stopwatch.createStarted();\n            return fetcher.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter)\n                .thenApply(result -> {\n                    Attributes latencyAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                        .put(TieredStoreMetricsConstant.LABEL_OPERATION, TieredStoreMetricsConstant.OPERATION_API_GET_MESSAGE)\n                        .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                        .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                        .build();\n                    TieredStoreMetricsManager.apiLatency.record(stopwatch.elapsed(TimeUnit.MILLISECONDS), latencyAttributes);\n\n                    if (result.getStatus() == GetMessageStatus.OFFSET_FOUND_NULL ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_ONE ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        if (next.checkInDiskByConsumeOffset(topic, queueId, offset)) {\n                            logger.debug(\"TieredMessageStore#getMessageAsync: not found message, try to get message from next store: topic: {}, queue: {}, queue offset: {}, tiered store result: {}, min offset: {}, max offset: {}\",\n                                topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                            TieredStoreMetricsManager.fallbackTotal.add(1, latencyAttributes);\n                            return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                        }\n                    }\n                    if (result.getStatus() != GetMessageStatus.FOUND &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_ONE &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        logger.warn(\"TieredMessageStore#getMessageAsync: not found message, and message is not in next store: topic: {}, queue: {}, queue offset: {}, result: {}, min offset: {}, max offset: {}\",\n                            topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                    }\n                    if (result.getStatus() == GetMessageStatus.FOUND) {\n                        Attributes messagesOutAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                            .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                            .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                            .build();\n                        TieredStoreMetricsManager.messagesOutTotal.add(result.getMessageCount(), messagesOutAttributes);\n                    }\n\n                    // fix min or max offset using next store\n                    long minOffsetInQueue = next.getMinOffsetInQueue(topic, queueId);\n                    if (minOffsetInQueue >= 0 && minOffsetInQueue < result.getMinOffset()) {\n                        result.setMinOffset(minOffsetInQueue);\n                    }\n                    long maxOffsetInQueue = next.getMaxOffsetInQueue(topic, queueId);\n                    if (maxOffsetInQueue >= 0 && maxOffsetInQueue > result.getMaxOffset()) {\n                        result.setMaxOffset(maxOffsetInQueue);\n                    }\n                    return result;\n                }).exceptionally(e -> {\n                    logger.error(\"TieredMessageStore#getMessageAsync: get message from tiered store failed: \", e);\n                    return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                });\n        }\n        return next.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter);\n    }\n",
    "focal_tgt": "    @Override\n    public CompletableFuture<GetMessageResult> getMessageAsync(String group, String topic,\n        int queueId, long offset, int maxMsgNums, MessageFilter messageFilter) {\n        if (viaTieredStorage(topic, queueId, offset, maxMsgNums)) {\n            Stopwatch stopwatch = Stopwatch.createStarted();\n            return fetcher.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter)\n                .thenApply(result -> {\n                    Attributes latencyAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                        .put(TieredStoreMetricsConstant.LABEL_OPERATION, TieredStoreMetricsConstant.OPERATION_API_GET_MESSAGE)\n                        .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                        .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                        .build();\n                    TieredStoreMetricsManager.apiLatency.record(stopwatch.elapsed(TimeUnit.MILLISECONDS), latencyAttributes);\n\n                    if (result.getStatus() == GetMessageStatus.OFFSET_FOUND_NULL ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_ONE ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        if (next.checkInStoreByConsumeOffset(topic, queueId, offset)) {\n                            logger.debug(\"TieredMessageStore#getMessageAsync: not found message, try to get message from next store: topic: {}, queue: {}, queue offset: {}, tiered store result: {}, min offset: {}, max offset: {}\",\n                                topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                            TieredStoreMetricsManager.fallbackTotal.add(1, latencyAttributes);\n                            return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                        }\n                    }\n                    if (result.getStatus() != GetMessageStatus.FOUND &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_ONE &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        logger.warn(\"TieredMessageStore#getMessageAsync: not found message, and message is not in next store: topic: {}, queue: {}, queue offset: {}, result: {}, min offset: {}, max offset: {}\",\n                            topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                    }\n                    if (result.getStatus() == GetMessageStatus.FOUND) {\n                        Attributes messagesOutAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                            .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                            .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                            .build();\n                        TieredStoreMetricsManager.messagesOutTotal.add(result.getMessageCount(), messagesOutAttributes);\n                    }\n\n                    // fix min or max offset using next store\n                    long minOffsetInQueue = next.getMinOffsetInQueue(topic, queueId);\n                    if (minOffsetInQueue >= 0 && minOffsetInQueue < result.getMinOffset()) {\n                        result.setMinOffset(minOffsetInQueue);\n                    }\n                    long maxOffsetInQueue = next.getMaxOffsetInQueue(topic, queueId);\n                    if (maxOffsetInQueue >= 0 && maxOffsetInQueue > result.getMaxOffset()) {\n                        result.setMaxOffset(maxOffsetInQueue);\n                    }\n                    return result;\n                }).exceptionally(e -> {\n                    logger.error(\"TieredMessageStore#getMessageAsync: get message from tiered store failed: \", e);\n                    return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                });\n        }\n        return next.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter);\n    }\n",
    "test_id": 12
  },
  "13": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenNoAck",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenNoAck"
    ],
    "test_src_code": "    @Test\n    public void testConsumeMessageThenNoAck() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        await().atLeast(Duration.ofSeconds(2)).atMost(Duration.ofSeconds(4)).until(notified::get);\n        assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 13
  },
  "14": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenAck",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenAck"
    ],
    "test_src_code": "    @Test\n    public void testConsumeMessageThenAck() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        consumerOrderInfoManager.commitAndNext(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1,\n            popTime\n        );\n        await().atMost(Duration.ofSeconds(1)).until(notified::get);\n        assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 14
  },
  "15": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleLonger",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleLonger"
    ],
    "test_src_code": "    @Test\n    public void testConsumeTheChangeInvisibleLonger() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        consumerOrderInfoManager.updateNextVisibleTime(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1,\n            popTime,\n            popTime + 5000\n        );\n        await().atLeast(Duration.ofSeconds(4)).atMost(Duration.ofSeconds(6)).until(notified::get);\n        assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 15
  },
  "16": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleShorter",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleShorter"
    ],
    "test_src_code": "    @Test\n    public void testConsumeTheChangeInvisibleShorter() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        consumerOrderInfoManager.updateNextVisibleTime(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1,\n            popTime,\n            popTime + 1000\n        );\n        await().atLeast(Duration.ofMillis(500)).atMost(Duration.ofSeconds(2)).until(notified::get);\n        assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 16
  },
  "17": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testRecover",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testRecover"
    ],
    "test_src_code": "    @Test\n    public void testRecover() {\n        ConsumerOrderInfoManager savedConsumerOrderInfoManager = new ConsumerOrderInfoManager();\n        savedConsumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        String encodedData = savedConsumerOrderInfoManager.encode();\n\n        consumerOrderInfoManager.decode(encodedData);\n        await().atLeast(Duration.ofSeconds(2)).atMost(Duration.ofSeconds(4)).until(notified::get);\n        assertTrue(consumerOrderInfoManager.getConsumerOrderInfoLockManager().getTimeoutMap().isEmpty());\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 17
  },
  "18": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testCommitAndNext",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testCommitAndNext",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testCommitAndNext() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        assertEncodeAndDecode();\n        assertEquals(-2, consumerOrderInfoManager.commitAndNext(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1L,\n            popTime - 10\n        ));\n        assertEncodeAndDecode();\n        assertTrue(consumerOrderInfoManager.checkBlock(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            TimeUnit.SECONDS.toMillis(3)\n        ));\n\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1L,\n            popTime\n        ));\n        assertEncodeAndDecode();\n        assertFalse(consumerOrderInfoManager.checkBlock(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            TimeUnit.SECONDS.toMillis(3)\n        ));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 18
  },
  "19": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testCommitAndNext",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testCommitAndNext",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testCommitAndNext() {\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            3000,\n            Lists.newArrayList(1L),\n            new StringBuilder()\n        );\n        assertEncodeAndDecode();\n        assertEquals(-2, consumerOrderInfoManager.commitAndNext(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1L,\n            popTime - 10\n        ));\n        assertEncodeAndDecode();\n        assertTrue(consumerOrderInfoManager.checkBlock(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            TimeUnit.SECONDS.toMillis(3)\n        ));\n\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            1L,\n            popTime\n        ));\n        assertEncodeAndDecode();\n        assertFalse(consumerOrderInfoManager.checkBlock(\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            TimeUnit.SECONDS.toMillis(3)\n        ));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#checkBlock",
    "focal_src": "    public boolean checkBlock(String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(invisibleTime);\n    }\n",
    "focal_tgt": "    public boolean checkBlock(String attemptId, String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(attemptId, invisibleTime);\n    }\n",
    "test_id": 19
  },
  "20": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCount",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCount",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testConsumedCount() {\n        {\n            // consume three new messages\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(1L, 2L, 3L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(1, orderInfoMap.size());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        }\n\n        {\n            // reconsume same messages\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(1L, 2L, 3L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(4, orderInfoMap.size());\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            for (int i = 1; i <= 3; i++) {\n                assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, i)).intValue());\n            }\n        }\n\n        {\n            // reconsume last two message\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(2L, 3L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(3, orderInfoMap.size());\n            assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            for (int i = 2; i <= 3; i++) {\n                assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, i)).intValue());\n            }\n        }\n\n        {\n            // consume a new message and reconsume last message\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(3L, 4L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(2, orderInfoMap.size());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            assertEquals(3, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 3)).intValue());\n        }\n\n        {\n            // consume two new messages\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(5L, 6L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(1, orderInfoMap.size());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        }\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 20
  },
  "21": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCountForMultiQueue",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCountForMultiQueue",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testConsumedCountForMultiQueue() {\n        {\n            // consume two new messages\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(0L),\n                orderInfoBuilder\n            );\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_1,\n                popTime,\n                3000,\n                Lists.newArrayList(0L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(2, orderInfoMap.size());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n        }\n        {\n            // reconsume two message\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(0L),\n                orderInfoBuilder\n            );\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_1,\n                popTime,\n                3000,\n                Lists.newArrayList(0L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(4, orderInfoMap.size());\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n            assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n        }\n        {\n            // reconsume with a new message\n            StringBuilder orderInfoBuilder = new StringBuilder();\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                3000,\n                Lists.newArrayList(0L, 1L),\n                orderInfoBuilder\n            );\n            consumerOrderInfoManager.update(\n                false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_1,\n                popTime,\n                3000,\n                Lists.newArrayList(0L),\n                orderInfoBuilder\n            );\n            assertEncodeAndDecode();\n            Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n            assertEquals(4, orderInfoMap.size());\n            assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n            assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_1)).intValue());\n            assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 0L)).intValue());\n            assertNull(orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 1L)));\n            assertEquals(2, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_1, 0L)).intValue());\n        }\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 21
  },
  "22": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testUpdateNextVisibleTime",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testUpdateNextVisibleTime",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testUpdateNextVisibleTime() {\n        long invisibleTime = 3000;\n\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(1L, 2L, 3L),\n            orderInfoBuilder\n        );\n\n        consumerOrderInfoManager.updateNextVisibleTime(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime, System.currentTimeMillis() + invisibleTime);\n        assertEncodeAndDecode();\n\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 1L, popTime));\n        assertEncodeAndDecode();\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 3L, popTime));\n        assertEncodeAndDecode();\n\n        await().atMost(Duration.ofSeconds(invisibleTime + 1)).until(() -> !consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n\n        orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(\n            false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            orderInfoBuilder\n        );\n\n        consumerOrderInfoManager.updateNextVisibleTime(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime, System.currentTimeMillis() + invisibleTime);\n        assertEncodeAndDecode();\n\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 3L, popTime));\n        assertEncodeAndDecode();\n        assertEquals(2, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 4L, popTime));\n        assertEncodeAndDecode();\n        assertTrue(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n\n        assertEquals(5L, consumerOrderInfoManager.commitAndNext(TOPIC, GROUP, QUEUE_ID_0, 2L, popTime));\n        assertEncodeAndDecode();\n        assertFalse(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, invisibleTime));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 22
  },
  "23": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testAutoCleanAndEncode",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testAutoCleanAndEncode",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testAutoCleanAndEncode() {\n        BrokerConfig brokerConfig = new BrokerConfig();\n        BrokerController brokerController = mock(BrokerController.class);\n        TopicConfigManager topicConfigManager = mock(TopicConfigManager.class);\n        when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n        when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n\n        SubscriptionGroupManager subscriptionGroupManager = mock(SubscriptionGroupManager.class);\n        when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n        ConcurrentMap<String, SubscriptionGroupConfig> subscriptionGroupConfigConcurrentMap = new ConcurrentHashMap<>();\n        subscriptionGroupConfigConcurrentMap.put(GROUP, new SubscriptionGroupConfig());\n        when(subscriptionGroupManager.getSubscriptionGroupTable()).thenReturn(subscriptionGroupConfigConcurrentMap);\n\n        TopicConfig topicConfig = new TopicConfig(TOPIC);\n        when(topicConfigManager.selectTopicConfig(eq(TOPIC))).thenReturn(topicConfig);\n\n        ConsumerOrderInfoManager consumerOrderInfoManager = new ConsumerOrderInfoManager(brokerController);\n\n        {\n            consumerOrderInfoManager.update(false,\n                \"errTopic\",\n                \"errGroup\",\n                QUEUE_ID_0,\n                popTime,\n                1,\n                Lists.newArrayList(2L, 3L, 4L),\n                new StringBuilder());\n\n            consumerOrderInfoManager.autoClean();\n            assertEquals(0, consumerOrderInfoManager.getTable().size());\n        }\n        {\n            consumerOrderInfoManager.update(false,\n                TOPIC,\n                \"errGroup\",\n                QUEUE_ID_0,\n                popTime,\n                1,\n                Lists.newArrayList(2L, 3L, 4L),\n                new StringBuilder());\n\n            consumerOrderInfoManager.autoClean();\n            assertEquals(0, consumerOrderInfoManager.getTable().size());\n        }\n        {\n            topicConfig.setReadQueueNums(0);\n            consumerOrderInfoManager.update(false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                1,\n                Lists.newArrayList(2L, 3L, 4L),\n                new StringBuilder());\n\n            await().atMost(Duration.ofSeconds(1)).until(() -> {\n                consumerOrderInfoManager.autoClean();\n                return consumerOrderInfoManager.getTable().size() == 0;\n            });\n        }\n        {\n            topicConfig.setReadQueueNums(8);\n            consumerOrderInfoManager.update(false,\n                TOPIC,\n                GROUP,\n                QUEUE_ID_0,\n                popTime,\n                1,\n                Lists.newArrayList(2L, 3L, 4L),\n                new StringBuilder());\n\n            consumerOrderInfoManager.autoClean();\n            assertEquals(1, consumerOrderInfoManager.getTable().size());\n            for (ConcurrentHashMap<Integer, ConsumerOrderInfoManager.OrderInfo> orderInfoMap : consumerOrderInfoManager.getTable().values()) {\n                assertEquals(1, orderInfoMap.size());\n                assertNotNull(orderInfoMap.get(QUEUE_ID_0));\n                break;\n            }\n        }\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 23
  },
  "24": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testLoadFromOldVersionOrderInfoData",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testLoadFromOldVersionOrderInfoData",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testLoadFromOldVersionOrderInfoData() {\n        consumerOrderInfoManager.update(false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n        ConsumerOrderInfoManager.OrderInfo orderInfo = consumerOrderInfoManager.getTable().values().stream().findFirst()\n            .get().get(QUEUE_ID_0);\n\n        orderInfo.setInvisibleTime(null);\n        orderInfo.setOffsetConsumedCount(null);\n        orderInfo.setOffsetNextVisibleTime(null);\n\n        String dataEncoded = consumerOrderInfoManager.encode();\n\n        consumerOrderInfoManager.decode(dataEncoded);\n        assertTrue(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, 3000));\n\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(3L, 4L, 5L),\n            orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(3, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 3)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 4)).intValue());\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 24
  },
  "25": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testLoadFromOldVersionOrderInfoData",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testLoadFromOldVersionOrderInfoData",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "test_src_code": "    @Test\n    public void testLoadFromOldVersionOrderInfoData() {\n        consumerOrderInfoManager.update(false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(2L, 3L, 4L),\n            new StringBuilder());\n        ConsumerOrderInfoManager.OrderInfo orderInfo = consumerOrderInfoManager.getTable().values().stream().findFirst()\n            .get().get(QUEUE_ID_0);\n\n        orderInfo.setInvisibleTime(null);\n        orderInfo.setOffsetConsumedCount(null);\n        orderInfo.setOffsetNextVisibleTime(null);\n\n        String dataEncoded = consumerOrderInfoManager.encode();\n\n        consumerOrderInfoManager.decode(dataEncoded);\n        assertTrue(consumerOrderInfoManager.checkBlock(TOPIC, GROUP, QUEUE_ID_0, 3000));\n\n        StringBuilder orderInfoBuilder = new StringBuilder();\n        consumerOrderInfoManager.update(false,\n            TOPIC,\n            GROUP,\n            QUEUE_ID_0,\n            popTime,\n            1,\n            Lists.newArrayList(3L, 4L, 5L),\n            orderInfoBuilder);\n        assertEncodeAndDecode();\n        Map<String, Integer> orderInfoMap = ExtraInfoUtil.parseOrderCountInfo(orderInfoBuilder.toString());\n        assertEquals(3, orderInfoMap.size());\n        assertEquals(0, orderInfoMap.get(ExtraInfoUtil.getStartOffsetInfoMapKey(TOPIC, QUEUE_ID_0)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 3)).intValue());\n        assertEquals(1, orderInfoMap.get(ExtraInfoUtil.getQueueOffsetMapKey(TOPIC, QUEUE_ID_0, 4)).intValue());\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#checkBlock",
    "focal_src": "    public boolean checkBlock(String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(invisibleTime);\n    }\n",
    "focal_tgt": "    public boolean checkBlock(String attemptId, String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(attemptId, invisibleTime);\n    }\n",
    "test_id": 25
  },
  "26": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresent",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresent"
    ],
    "test_src_code": "    @Test\n    public void testGetWhenComputeIfPresent() {\n        String handle1 = createHandle();\n        String handle2 = createHandle();\n        AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n        receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n        CountDownLatch latch = new CountDownLatch(2);\n        Thread getThread = new Thread(() -> {\n            try {\n                latch.countDown();\n                latch.await();\n                getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n            } catch (Exception ignored) {\n            }\n        }, \"getThread\");\n        Thread computeThread = new Thread(() -> {\n            try {\n                receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                    } catch (Exception ignored) {\n                    }\n                    messageReceiptHandle.updateReceiptHandle(handle2);\n                    return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n                });\n            } catch (Exception ignored) {\n            }\n        }, \"computeThread\");\n        getThread.start();\n        computeThread.start();\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> getHandleRef.get() != null);\n        assertEquals(handle2, getHandleRef.get().getReceiptHandleStr());\n        assertFalse(receiptHandleGroup.isEmpty());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent",
    "focal_src": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "focal_tgt": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "test_id": 26
  },
  "27": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresentReturnNull",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresentReturnNull"
    ],
    "test_src_code": "    @Test\n    public void testGetWhenComputeIfPresentReturnNull() {\n        String handle1 = createHandle();\n        AtomicBoolean getCalled = new AtomicBoolean(false);\n        AtomicReference<MessageReceiptHandle> getHandleRef = new AtomicReference<>();\n\n        receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n        CountDownLatch latch = new CountDownLatch(2);\n        Thread getThread = new Thread(() -> {\n            try {\n                latch.countDown();\n                latch.await();\n                getHandleRef.set(receiptHandleGroup.get(msgID, handle1));\n                getCalled.set(true);\n            } catch (Exception ignored) {\n            }\n        }, \"getThread\");\n        Thread computeThread = new Thread(() -> {\n            try {\n                receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                    } catch (Exception ignored) {\n                    }\n                    return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n                });\n            } catch (Exception ignored) {\n            }\n        }, \"computeThread\");\n        getThread.start();\n        computeThread.start();\n\n        await().atMost(Duration.ofSeconds(1)).until(getCalled::get);\n        assertNull(getHandleRef.get());\n        assertTrue(receiptHandleGroup.isEmpty());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent",
    "focal_src": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "focal_tgt": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "test_id": 27
  },
  "28": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresent",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresent"
    ],
    "test_src_code": "    @Test\n    public void testRemoveWhenComputeIfPresent() {\n        String handle1 = createHandle();\n        String handle2 = createHandle();\n        AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n        receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n        CountDownLatch latch = new CountDownLatch(2);\n        Thread removeThread = new Thread(() -> {\n            try {\n                latch.countDown();\n                latch.await();\n                removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n            } catch (Exception ignored) {\n            }\n        }, \"removeThread\");\n        Thread computeThread = new Thread(() -> {\n            try {\n                receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                    } catch (Exception ignored) {\n                    }\n                    messageReceiptHandle.updateReceiptHandle(handle2);\n                    return FutureUtils.addExecutor(CompletableFuture.completedFuture(messageReceiptHandle), Executors.newCachedThreadPool());\n                });\n            } catch (Exception ignored) {\n            }\n        }, \"computeThread\");\n        removeThread.start();\n        computeThread.start();\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> removeHandleRef.get() != null);\n        assertEquals(handle2, removeHandleRef.get().getReceiptHandleStr());\n        assertTrue(receiptHandleGroup.isEmpty());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent",
    "focal_src": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "focal_tgt": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "test_id": 28
  },
  "29": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresentReturnNull",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresentReturnNull"
    ],
    "test_src_code": "    @Test\n    public void testRemoveWhenComputeIfPresentReturnNull() {\n        String handle1 = createHandle();\n        AtomicBoolean removeCalled = new AtomicBoolean(false);\n        AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n\n        receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n        CountDownLatch latch = new CountDownLatch(2);\n        Thread removeThread = new Thread(() -> {\n            try {\n                latch.countDown();\n                latch.await();\n                removeHandleRef.set(receiptHandleGroup.remove(msgID, handle1));\n                removeCalled.set(true);\n            } catch (Exception ignored) {\n            }\n        }, \"removeThread\");\n        Thread computeThread = new Thread(() -> {\n            try {\n                receiptHandleGroup.computeIfPresent(msgID, handle1, messageReceiptHandle -> {\n                    try {\n                        latch.countDown();\n                        latch.await();\n                    } catch (Exception ignored) {\n                    }\n                    return FutureUtils.addExecutor(CompletableFuture.completedFuture(null), Executors.newCachedThreadPool());\n                });\n            } catch (Exception ignored) {\n            }\n        }, \"computeThread\");\n        removeThread.start();\n        computeThread.start();\n\n        await().atMost(Duration.ofSeconds(1)).until(removeCalled::get);\n        assertNull(removeHandleRef.get());\n        assertTrue(receiptHandleGroup.isEmpty());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent",
    "focal_src": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "focal_tgt": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "test_id": 29
  },
  "30": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveMultiThread",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveMultiThread"
    ],
    "test_src_code": "    @Test\n    public void testRemoveMultiThread() {\n        String handle1 = createHandle();\n        AtomicReference<MessageReceiptHandle> removeHandleRef = new AtomicReference<>();\n        AtomicInteger count = new AtomicInteger();\n\n        receiptHandleGroup.put(msgID, handle1, createMessageReceiptHandle(handle1, msgID));\n        int threadNum = Math.max(Runtime.getRuntime().availableProcessors(), 3);\n        CountDownLatch latch = new CountDownLatch(threadNum);\n        for (int i = 0; i < threadNum; i++) {\n            Thread thread = new Thread(() -> {\n                try {\n                    latch.countDown();\n                    latch.await();\n                    MessageReceiptHandle handle = receiptHandleGroup.remove(msgID, handle1);\n                    if (handle != null) {\n                        removeHandleRef.set(handle);\n                        count.incrementAndGet();\n                    }\n                } catch (Exception ignored) {\n                }\n            });\n            thread.start();\n        }\n\n        await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> assertEquals(1, count.get()));\n        assertEquals(handle1, removeHandleRef.get().getReceiptHandleStr());\n        assertTrue(receiptHandleGroup.isEmpty());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#remove",
    "focal_src": "    public MessageReceiptHandle remove(String msgID, String handle) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to remove and get handle failed\");\n            }\n            try {\n                if (!handleData.needRemove) {\n                    handleData.needRemove = true;\n                    res.set(handleData.messageReceiptHandle);\n                }\n                return null;\n            } finally {\n                handleData.unlock();\n            }\n        });\n        removeHandleMapKeyIfNeed(msgID);\n        return res.get();\n    }\n",
    "focal_tgt": "    public MessageReceiptHandle remove(String msgID, String handle) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to remove and get handle failed\");\n            }\n            try {\n                if (!handleData.needRemove) {\n                    handleData.needRemove = true;\n                    res.set(handleData.messageReceiptHandle);\n                }\n                return null;\n            } finally {\n                handleData.unlock();\n            }\n        });\n        removeHandleMapKeyIfNeed(msgID);\n        return res.get();\n    }\n",
    "test_id": 30
  },
  "31": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessagePollingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessagePollingTime"
    ],
    "test_src_code": "    @Test\n    public void testReceiveMessagePollingTime() {\n        StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n        ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n        doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n        ArgumentCaptor<Long> pollTimeCaptor = ArgumentCaptor.forClass(Long.class);\n        when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder()\n            .setRequestTimeout(Durations.fromSeconds(3))\n            .build());\n        when(this.messagingProcessor.popMessage(any(), any(), anyString(), anyString(), anyInt(), anyLong(),\n            pollTimeCaptor.capture(), anyInt(), any(), anyBoolean(), any(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new PopResult(PopStatus.NO_NEW_MSG, Collections.emptyList())));\n\n\n        ProxyContext context = createContext();\n        context.setRemainingMs(1L);\n        this.receiveMessageActivity.receiveMessage(\n            context,\n            ReceiveMessageRequest.newBuilder()\n                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n                .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n                .setAutoRenew(true)\n                .setFilterExpression(FilterExpression.newBuilder()\n                    .setType(FilterType.TAG)\n                    .setExpression(\"*\")\n                    .build())\n                .build(),\n            receiveStreamObserver\n        );\n\n        assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n        assertEquals(0L, pollTimeCaptor.getValue().longValue());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java#receiveMessage",
    "focal_src": "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), receiptHandle, messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n",
    "focal_tgt": "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    request.getAttemptId(),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n",
    "test_id": 31
  },
  "32": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessage"
    ],
    "test_src_code": "    @Test\n    public void testReceiveMessage() {\n        StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n        ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n        doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n        when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder().getDefaultInstanceForType());\n\n        PopResult popResult = new PopResult(PopStatus.NO_NEW_MSG, new ArrayList<>());\n        when(this.messagingProcessor.popMessage(\n            any(),\n            any(),\n            anyString(),\n            anyString(),\n            anyInt(),\n            anyLong(),\n            anyLong(),\n            anyInt(),\n            any(),\n            anyBoolean(),\n            any(),\n            anyLong())).thenReturn(CompletableFuture.completedFuture(popResult));\n\n        this.receiveMessageActivity.receiveMessage(\n            createContext(),\n            ReceiveMessageRequest.newBuilder()\n                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n                .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n                .setAutoRenew(true)\n                .setFilterExpression(FilterExpression.newBuilder()\n                    .setType(FilterType.TAG)\n                    .setExpression(\"*\")\n                    .build())\n                .build(),\n            receiveStreamObserver\n        );\n        assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java#receiveMessage",
    "focal_src": "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), receiptHandle, messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n",
    "focal_tgt": "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    request.getAttemptId(),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n",
    "test_id": 32
  },
  "33": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ConsumerProcessorTest#testPopMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ConsumerProcessorTest#testPopMessage"
    ],
    "test_src_code": "    @Test\n    public void testPopMessage() throws Throwable {\n        final String tag = \"tag\";\n        final long invisibleTime = Duration.ofSeconds(15).toMillis();\n        ArgumentCaptor<AddressableMessageQueue> messageQueueArgumentCaptor = ArgumentCaptor.forClass(AddressableMessageQueue.class);\n        ArgumentCaptor<PopMessageRequestHeader> requestHeaderArgumentCaptor = ArgumentCaptor.forClass(PopMessageRequestHeader.class);\n\n        List<MessageExt> messageExtList = new ArrayList<>();\n        messageExtList.add(createMessageExt(TOPIC, \"noMatch\", 0, invisibleTime));\n        messageExtList.add(createMessageExt(TOPIC, tag, 0, invisibleTime));\n        messageExtList.add(createMessageExt(TOPIC, tag, 1, invisibleTime));\n        PopResult innerPopResult = new PopResult(PopStatus.FOUND, messageExtList);\n        when(this.messageService.popMessage(any(), messageQueueArgumentCaptor.capture(), requestHeaderArgumentCaptor.capture(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(innerPopResult));\n\n        when(this.topicRouteService.getCurrentMessageQueueView(any(), anyString()))\n            .thenReturn(mock(MessageQueueView.class));\n\n        ArgumentCaptor<String> ackMessageIdArgumentCaptor = ArgumentCaptor.forClass(String.class);\n        when(this.messagingProcessor.ackMessage(any(), any(), ackMessageIdArgumentCaptor.capture(), anyString(), anyString(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(mock(AckResult.class)));\n\n        ArgumentCaptor<String> toDLQMessageIdArgumentCaptor = ArgumentCaptor.forClass(String.class);\n        when(this.messagingProcessor.forwardMessageToDeadLetterQueue(any(), any(), toDLQMessageIdArgumentCaptor.capture(), anyString(), anyString(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(mock(RemotingCommand.class)));\n\n        AddressableMessageQueue messageQueue = mock(AddressableMessageQueue.class);\n        PopResult popResult = this.consumerProcessor.popMessage(\n            createContext(),\n            (ctx, messageQueueView) -> messageQueue,\n            CONSUMER_GROUP,\n            TOPIC,\n            60,\n            invisibleTime,\n            Duration.ofSeconds(3).toMillis(),\n            ConsumeInitMode.MAX,\n            FilterAPI.build(TOPIC, tag, ExpressionType.TAG),\n            false,\n            (ctx, consumerGroup, subscriptionData, messageExt) -> {\n                if (!messageExt.getTags().equals(tag)) {\n                    return PopMessageResultFilter.FilterResult.NO_MATCH;\n                }\n                if (messageExt.getReconsumeTimes() > 0) {\n                    return PopMessageResultFilter.FilterResult.TO_DLQ;\n                }\n                return PopMessageResultFilter.FilterResult.MATCH;\n            },\n            Duration.ofSeconds(3).toMillis()\n        ).get();\n\n        assertSame(messageQueue, messageQueueArgumentCaptor.getValue());\n        assertEquals(CONSUMER_GROUP, requestHeaderArgumentCaptor.getValue().getConsumerGroup());\n        assertEquals(TOPIC, requestHeaderArgumentCaptor.getValue().getTopic());\n        assertEquals(ProxyUtils.MAX_MSG_NUMS_FOR_POP_REQUEST, requestHeaderArgumentCaptor.getValue().getMaxMsgNums());\n        assertEquals(tag, requestHeaderArgumentCaptor.getValue().getExp());\n        assertEquals(ExpressionType.TAG, requestHeaderArgumentCaptor.getValue().getExpType());\n\n        assertEquals(PopStatus.FOUND, popResult.getPopStatus());\n        assertEquals(1, popResult.getMsgFoundList().size());\n        assertEquals(messageExtList.get(1), popResult.getMsgFoundList().get(0));\n\n        assertEquals(messageExtList.get(0).getMsgId(), ackMessageIdArgumentCaptor.getValue());\n        assertEquals(messageExtList.get(2).getMsgId(), toDLQMessageIdArgumentCaptor.getValue());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ConsumerProcessor.java#popMessage",
    "focal_src": "    public CompletableFuture<PopResult> popMessage(\n        ProxyContext ctx,\n        QueueSelector queueSelector,\n        String consumerGroup,\n        String topic,\n        int maxMsgNums,\n        long invisibleTime,\n        long pollTime,\n        int initMode,\n        SubscriptionData subscriptionData,\n        boolean fifo,\n        PopMessageResultFilter popMessageResultFilter,\n        long timeoutMillis\n    ) {\n        CompletableFuture<PopResult> future = new CompletableFuture<>();\n        try {\n            AddressableMessageQueue messageQueue = queueSelector.select(ctx, this.serviceManager.getTopicRouteService().getCurrentMessageQueueView(ctx, topic));\n            if (messageQueue == null) {\n                throw new ProxyException(ProxyExceptionCode.FORBIDDEN, \"no readable queue\");\n            }\n            return popMessage(ctx, messageQueue, consumerGroup, topic, maxMsgNums, invisibleTime, pollTime, initMode, subscriptionData, fifo, popMessageResultFilter, timeoutMillis);\n        }  catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n",
    "focal_tgt": "    public CompletableFuture<PopResult> popMessage(\n        ProxyContext ctx,\n        QueueSelector queueSelector,\n        String consumerGroup,\n        String topic,\n        int maxMsgNums,\n        long invisibleTime,\n        long pollTime,\n        int initMode,\n        SubscriptionData subscriptionData,\n        boolean fifo,\n        PopMessageResultFilter popMessageResultFilter,\n        String attemptId,\n        long timeoutMillis\n    ) {\n        CompletableFuture<PopResult> future = new CompletableFuture<>();\n        try {\n            AddressableMessageQueue messageQueue = queueSelector.select(ctx, this.serviceManager.getTopicRouteService().getCurrentMessageQueueView(ctx, topic));\n            if (messageQueue == null) {\n                throw new ProxyException(ProxyExceptionCode.FORBIDDEN, \"no readable queue\");\n            }\n            return popMessage(ctx, messageQueue, consumerGroup, topic, maxMsgNums, invisibleTime, pollTime, initMode,\n                subscriptionData, fifo, popMessageResultFilter, attemptId, timeoutMillis);\n        }  catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n",
    "test_id": 33
  },
  "34": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddReceiptHandle",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage"
    ],
    "test_src_code": "    @Test\n    public void testAddReceiptHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(new SubscriptionGroupConfig());\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills()));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 34
  },
  "35": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandle() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        long newInvisibleTime = 18000L;\n\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        String newReceiptHandle = newReceiptHandleClass.encode();\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n        AtomicInteger times = new AtomicInteger(0);\n\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        ackResult.setExtraInfo(newReceiptHandle);\n\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n            .thenReturn(CompletableFuture.completedFuture(ackResult));\n        receiptHandleProcessor.scheduleRenewTask();\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n        receiptHandleProcessor.scheduleRenewTask();\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n        receiptHandleProcessor.scheduleRenewTask();\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 35
  },
  "36": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandle() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        long newInvisibleTime = 18000L;\n\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        String newReceiptHandle = newReceiptHandleClass.encode();\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n        AtomicInteger times = new AtomicInteger(0);\n\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        ackResult.setExtraInfo(newReceiptHandle);\n\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n            .thenReturn(CompletableFuture.completedFuture(ackResult));\n        receiptHandleProcessor.scheduleRenewTask();\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n        receiptHandleProcessor.scheduleRenewTask();\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n        receiptHandleProcessor.scheduleRenewTask();\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 36
  },
  "37": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandle() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        long newInvisibleTime = 18000L;\n\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        String newReceiptHandle = newReceiptHandleClass.encode();\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n        AtomicInteger times = new AtomicInteger(0);\n\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        ackResult.setExtraInfo(newReceiptHandle);\n\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n            .thenReturn(CompletableFuture.completedFuture(ackResult));\n        receiptHandleProcessor.scheduleRenewTask();\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n        receiptHandleProcessor.scheduleRenewTask();\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n        receiptHandleProcessor.scheduleRenewTask();\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 37
  },
  "38": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandle() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        long newInvisibleTime = 18000L;\n\n        ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build();\n        String newReceiptHandle = newReceiptHandleClass.encode();\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n        AtomicInteger times = new AtomicInteger(0);\n\n        AckResult ackResult = new AckResult();\n        ackResult.setStatus(AckStatus.OK);\n        ackResult.setExtraInfo(newReceiptHandle);\n\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get()))))\n            .thenReturn(CompletableFuture.completedFuture(ackResult));\n        receiptHandleProcessor.scheduleRenewTask();\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == INVISIBLE_TIME), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.get())));\n        receiptHandleProcessor.scheduleRenewTask();\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.argThat(r -> r.getInvisibleTime() == newInvisibleTime), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.incrementAndGet())));\n        receiptHandleProcessor.scheduleRenewTask();\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 38
  },
  "39": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes"
    ],
    "test_src_code": "    @Test\n    public void testRenewExceedMaxRenewTimes() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n            .thenReturn(ackResultFuture);\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        Mockito.verify(messagingProcessor, Mockito.times(3))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 39
  },
  "40": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes"
    ],
    "test_src_code": "    @Test\n    public void testRenewExceedMaxRenewTimes() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n            .thenReturn(ackResultFuture);\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        Mockito.verify(messagingProcessor, Mockito.times(3))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 40
  },
  "41": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes"
    ],
    "test_src_code": "    @Test\n    public void testRenewExceedMaxRenewTimes() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n            .thenReturn(ackResultFuture);\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        Mockito.verify(messagingProcessor, Mockito.times(3))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 41
  },
  "42": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes"
    ],
    "test_src_code": "    @Test\n    public void testRenewExceedMaxRenewTimes() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes()))))\n            .thenReturn(ackResultFuture);\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        Mockito.verify(messagingProcessor, Mockito.times(3))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(messageReceiptHandle.getRenewTimes())));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 42
  },
  "43": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle"
    ],
    "test_src_code": "    @Test\n    public void testRenewWithInvalidHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n            .thenReturn(ackResultFuture);\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 43
  },
  "44": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle"
    ],
    "test_src_code": "    @Test\n    public void testRenewWithInvalidHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n            .thenReturn(ackResultFuture);\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 44
  },
  "45": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle"
    ],
    "test_src_code": "    @Test\n    public void testRenewWithInvalidHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n            .thenReturn(ackResultFuture);\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 45
  },
  "46": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle"
    ],
    "test_src_code": "    @Test\n    public void testRenewWithInvalidHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n        ackResultFuture.completeExceptionally(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"error\"));\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n            Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getDefaultInvisibleTimeMills())))\n            .thenReturn(ackResultFuture);\n\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 46
  },
  "47": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK"
    ],
    "test_src_code": "    @Test\n    public void testRenewWithErrorThenOK() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        AtomicInteger count = new AtomicInteger(0);\n        List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n        {\n            CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n            ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n        }\n        {\n            long newInvisibleTime = 2000L;\n            ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n                .startOffset(0L)\n                .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n                .invisibleTime(newInvisibleTime)\n                .reviveQueueId(1)\n                .topicType(ReceiptHandle.NORMAL_TOPIC)\n                .brokerName(BROKER_NAME)\n                .queueId(QUEUE_ID)\n                .offset(OFFSET)\n                .commitLogOffset(0L)\n                .build();\n            String newReceiptHandle = newReceiptHandleClass.encode();\n            AckResult ackResult = new AckResult();\n            ackResult.setStatus(AckStatus.OK);\n            ackResult.setExtraInfo(newReceiptHandle);\n            futureList.add(CompletableFuture.completedFuture(ackResult));\n        }\n        {\n            CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n            ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n        }\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n        AtomicInteger times = new AtomicInteger(0);\n        for (int i = 0; i < 6; i++) {\n            Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n                return futureList.get(count.getAndIncrement());\n            }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                    Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n        }\n\n        await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        assertEquals(6, count.get());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 47
  },
  "48": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK"
    ],
    "test_src_code": "    @Test\n    public void testRenewWithErrorThenOK() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        AtomicInteger count = new AtomicInteger(0);\n        List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n        {\n            CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n            ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n        }\n        {\n            long newInvisibleTime = 2000L;\n            ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n                .startOffset(0L)\n                .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n                .invisibleTime(newInvisibleTime)\n                .reviveQueueId(1)\n                .topicType(ReceiptHandle.NORMAL_TOPIC)\n                .brokerName(BROKER_NAME)\n                .queueId(QUEUE_ID)\n                .offset(OFFSET)\n                .commitLogOffset(0L)\n                .build();\n            String newReceiptHandle = newReceiptHandleClass.encode();\n            AckResult ackResult = new AckResult();\n            ackResult.setStatus(AckStatus.OK);\n            ackResult.setExtraInfo(newReceiptHandle);\n            futureList.add(CompletableFuture.completedFuture(ackResult));\n        }\n        {\n            CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n            ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n        }\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n        AtomicInteger times = new AtomicInteger(0);\n        for (int i = 0; i < 6; i++) {\n            Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n                return futureList.get(count.getAndIncrement());\n            }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                    Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n        }\n\n        await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        assertEquals(6, count.get());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 48
  },
  "49": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK"
    ],
    "test_src_code": "    @Test\n    public void testRenewWithErrorThenOK() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        AtomicInteger count = new AtomicInteger(0);\n        List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n        {\n            CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n            ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n        }\n        {\n            long newInvisibleTime = 2000L;\n            ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n                .startOffset(0L)\n                .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n                .invisibleTime(newInvisibleTime)\n                .reviveQueueId(1)\n                .topicType(ReceiptHandle.NORMAL_TOPIC)\n                .brokerName(BROKER_NAME)\n                .queueId(QUEUE_ID)\n                .offset(OFFSET)\n                .commitLogOffset(0L)\n                .build();\n            String newReceiptHandle = newReceiptHandleClass.encode();\n            AckResult ackResult = new AckResult();\n            ackResult.setStatus(AckStatus.OK);\n            ackResult.setExtraInfo(newReceiptHandle);\n            futureList.add(CompletableFuture.completedFuture(ackResult));\n        }\n        {\n            CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n            ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n        }\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n        AtomicInteger times = new AtomicInteger(0);\n        for (int i = 0; i < 6; i++) {\n            Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n                return futureList.get(count.getAndIncrement());\n            }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                    Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n        }\n\n        await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        assertEquals(6, count.get());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 49
  },
  "50": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK"
    ],
    "test_src_code": "    @Test\n    public void testRenewWithErrorThenOK() {\n        ProxyConfig config = ConfigurationManager.getProxyConfig();\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n\n        AtomicInteger count = new AtomicInteger(0);\n        List<CompletableFuture<AckResult>> futureList = new ArrayList<>();\n        {\n            CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n            ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n        }\n        {\n            long newInvisibleTime = 2000L;\n            ReceiptHandle newReceiptHandleClass = ReceiptHandle.builder()\n                .startOffset(0L)\n                .retrieveTime(System.currentTimeMillis() - newInvisibleTime + config.getRenewAheadTimeMillis() - 5)\n                .invisibleTime(newInvisibleTime)\n                .reviveQueueId(1)\n                .topicType(ReceiptHandle.NORMAL_TOPIC)\n                .brokerName(BROKER_NAME)\n                .queueId(QUEUE_ID)\n                .offset(OFFSET)\n                .commitLogOffset(0L)\n                .build();\n            String newReceiptHandle = newReceiptHandleClass.encode();\n            AckResult ackResult = new AckResult();\n            ackResult.setStatus(AckStatus.OK);\n            ackResult.setExtraInfo(newReceiptHandle);\n            futureList.add(CompletableFuture.completedFuture(ackResult));\n        }\n        {\n            CompletableFuture<AckResult> ackResultFuture = new CompletableFuture<>();\n            ackResultFuture.completeExceptionally(new MQClientException(0, \"error\"));\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n            futureList.add(ackResultFuture);\n        }\n\n        RetryPolicy retryPolicy = new RenewStrategyPolicy();\n        AtomicInteger times = new AtomicInteger(0);\n        for (int i = 0; i < 6; i++) {\n            Mockito.doAnswer((Answer<CompletableFuture<AckResult>>) mock -> {\n                return futureList.get(count.getAndIncrement());\n            }).when(messagingProcessor).changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                    Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(retryPolicy.nextDelayDuration(times.getAndIncrement())));\n        }\n\n        await().pollDelay(Duration.ZERO).pollInterval(Duration.ofMillis(10)).atMost(Duration.ofSeconds(10)).until(() -> {\n            receiptHandleProcessor.scheduleRenewTask();\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        assertEquals(6, count.get());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 50
  },
  "51": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenTimeout() {\n        long newInvisibleTime = 200L;\n        long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n        await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            assertTrue(receiptHandleGroup.isEmpty());\n        });\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 51
  },
  "52": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenTimeout() {\n        long newInvisibleTime = 200L;\n        long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n        await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            assertTrue(receiptHandleGroup.isEmpty());\n        });\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 52
  },
  "53": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenTimeout() {\n        long newInvisibleTime = 200L;\n        long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n        await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            assertTrue(receiptHandleGroup.isEmpty());\n        });\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 53
  },
  "54": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenTimeout() {\n        long newInvisibleTime = 200L;\n        long maxRenewMs = ConfigurationManager.getProxyConfig().getRenewMaxTimeMillis();\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis() - maxRenewMs)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(groupConfig.getGroupRetryPolicy().getRetryPolicy().nextDelayDuration(RECONSUME_TIMES)));\n\n        await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {\n            ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n            assertTrue(receiptHandleGroup.isEmpty());\n        });\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 54
  },
  "55": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenTimeoutWithNoSubscription() {\n        long newInvisibleTime = 0L;\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(0)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(null);\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n        receiptHandleProcessor.scheduleRenewTask();\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 55
  },
  "56": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenTimeoutWithNoSubscription() {\n        long newInvisibleTime = 0L;\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(0)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(null);\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n        receiptHandleProcessor.scheduleRenewTask();\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 56
  },
  "57": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenTimeoutWithNoSubscription() {\n        long newInvisibleTime = 0L;\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(0)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(null);\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n        receiptHandleProcessor.scheduleRenewTask();\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 57
  },
  "58": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenTimeoutWithNoSubscription() {\n        long newInvisibleTime = 0L;\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(0)\n            .invisibleTime(newInvisibleTime)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(null);\n        Mockito.when(messagingProcessor.changeInvisibleTime(Mockito.any(), Mockito.any(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new AckResult()));\n        receiptHandleProcessor.scheduleRenewTask();\n        await().atMost(Duration.ofSeconds(1)).until(() -> {\n            try {\n                ReceiptHandleGroup receiptHandleGroup = receiptHandleProcessor.receiptHandleGroupMap.values().stream().findFirst().get();\n                return receiptHandleGroup.isEmpty();\n            } catch (Exception e) {\n                return false;\n            }\n        });\n\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 58
  },
  "59": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenNotArrivingTime() {\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis())\n            .invisibleTime(INVISIBLE_TIME)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 59
  },
  "60": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenNotArrivingTime() {\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis())\n            .invisibleTime(INVISIBLE_TIME)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 60
  },
  "61": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenNotArrivingTime() {\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis())\n            .invisibleTime(INVISIBLE_TIME)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 61
  },
  "62": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime"
    ],
    "test_src_code": "    @Test\n    public void testRenewReceiptHandleWhenNotArrivingTime() {\n        String newReceiptHandle = ReceiptHandle.builder()\n            .startOffset(0L)\n            .retrieveTime(System.currentTimeMillis())\n            .invisibleTime(INVISIBLE_TIME)\n            .reviveQueueId(1)\n            .topicType(ReceiptHandle.NORMAL_TOPIC)\n            .brokerName(BROKER_NAME)\n            .queueId(QUEUE_ID)\n            .offset(OFFSET)\n            .commitLogOffset(0L)\n            .build().encode();\n        messageReceiptHandle = new MessageReceiptHandle(GROUP, TOPIC, QUEUE_ID, newReceiptHandle, MESSAGE_ID, OFFSET,\n            RECONSUME_TIMES);\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, newReceiptHandle, messageReceiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        Mockito.when(messagingProcessor.findConsumerChannel(Mockito.any(), Mockito.eq(GROUP), Mockito.eq(channel))).thenReturn(Mockito.mock(ClientChannelInfo.class));\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 62
  },
  "63": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle"
    ],
    "test_src_code": "    @Test\n    public void testRemoveReceiptHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        receiptHandleProcessor.removeReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 63
  },
  "64": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle"
    ],
    "test_src_code": "    @Test\n    public void testRemoveReceiptHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        receiptHandleProcessor.removeReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 64
  },
  "65": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle"
    ],
    "test_src_code": "    @Test\n    public void testRemoveReceiptHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        receiptHandleProcessor.removeReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 65
  },
  "66": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle"
    ],
    "test_src_code": "    @Test\n    public void testRemoveReceiptHandle() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        receiptHandleProcessor.removeReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle);\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(0))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.anyString(),\n                Mockito.anyString(), Mockito.anyString(), Mockito.anyLong());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 66
  },
  "67": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup"
    ],
    "test_src_code": "    @Test\n    public void testClearGroup() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 67
  },
  "68": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup"
    ],
    "test_src_code": "    @Test\n    public void testClearGroup() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 68
  },
  "69": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup"
    ],
    "test_src_code": "    @Test\n    public void testClearGroup() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 69
  },
  "70": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup"
    ],
    "test_src_code": "    @Test\n    public void testClearGroup() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        receiptHandleProcessor.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleProcessor.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 70
  },
  "71": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline"
    ],
    "test_src_code": "    @Test\n    public void testClientOffline() {\n        ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n        Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n        assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 71
  },
  "72": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline"
    ],
    "test_src_code": "    @Test\n    public void testClientOffline() {\n        ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n        Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n        assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 72
  },
  "73": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline"
    ],
    "test_src_code": "    @Test\n    public void testClientOffline() {\n        ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n        Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n        assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 73
  },
  "74": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline"
    ],
    "test_src_code": "    @Test\n    public void testClientOffline() {\n        ArgumentCaptor<ConsumerIdsChangeListener> listenerArgumentCaptor = ArgumentCaptor.forClass(ConsumerIdsChangeListener.class);\n        Mockito.verify(messagingProcessor, Mockito.times(1)).registerConsumerListener(listenerArgumentCaptor.capture());\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleProcessor.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, receiptHandle, messageReceiptHandle);\n        listenerArgumentCaptor.getValue().handle(ConsumerGroupEvent.CLIENT_UNREGISTER, GROUP, new ClientChannelInfo(channel, \"\", LanguageCode.JAVA, 0));\n        assertTrue(receiptHandleProcessor.receiptHandleGroupMap.isEmpty());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 74
  },
  "75": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "test_src_code": "    @Test\n    public void testNum() {\n        BrokerController brokerController = mock(BrokerController.class);\n        long brokerStartTime = System.currentTimeMillis();\n        when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n        PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n        final String topic = \"topic\";\n        final String group = \"group\";\n\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.incrementInFlightMessageNum(topic, group, 0, 3);\n        assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis() - 1000,\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        PopCheckPoint popCheckPoint = new PopCheckPoint();\n        popCheckPoint.setTopic(topic);\n        popCheckPoint.setCId(group);\n        popCheckPoint.setQueueId(0);\n        popCheckPoint.setPopTime(System.currentTimeMillis());\n\n        counter.decrementInFlightMessageNum(popCheckPoint);\n        assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, String ckInfo) {\n        String[] ckInfoList = ExtraInfoUtil.split(ckInfo);\n        long popTime = ExtraInfoUtil.getPopTime(ckInfoList);\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, ExtraInfoUtil.getQueueId(ckInfoList));\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(String topic, String group, long popTime, int qId, int delta) {\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, qId, delta);\n    }\n",
    "test_id": 75
  },
  "76": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "test_src_code": "    @Test\n    public void testNum() {\n        BrokerController brokerController = mock(BrokerController.class);\n        long brokerStartTime = System.currentTimeMillis();\n        when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n        PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n        final String topic = \"topic\";\n        final String group = \"group\";\n\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.incrementInFlightMessageNum(topic, group, 0, 3);\n        assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis() - 1000,\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        PopCheckPoint popCheckPoint = new PopCheckPoint();\n        popCheckPoint.setTopic(topic);\n        popCheckPoint.setCId(group);\n        popCheckPoint.setQueueId(0);\n        popCheckPoint.setPopTime(System.currentTimeMillis());\n\n        counter.decrementInFlightMessageNum(popCheckPoint);\n        assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, String ckInfo) {\n        String[] ckInfoList = ExtraInfoUtil.split(ckInfo);\n        long popTime = ExtraInfoUtil.getPopTime(ckInfoList);\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, ExtraInfoUtil.getQueueId(ckInfoList));\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId(), 1);\n    }\n",
    "test_id": 76
  },
  "77": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "test_src_code": "    @Test\n    public void testNum() {\n        BrokerController brokerController = mock(BrokerController.class);\n        long brokerStartTime = System.currentTimeMillis();\n        when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n        PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n        final String topic = \"topic\";\n        final String group = \"group\";\n\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.incrementInFlightMessageNum(topic, group, 0, 3);\n        assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis() - 1000,\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        PopCheckPoint popCheckPoint = new PopCheckPoint();\n        popCheckPoint.setTopic(topic);\n        popCheckPoint.setCId(group);\n        popCheckPoint.setQueueId(0);\n        popCheckPoint.setPopTime(System.currentTimeMillis());\n\n        counter.decrementInFlightMessageNum(popCheckPoint);\n        assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, String ckInfo) {\n        String[] ckInfoList = ExtraInfoUtil.split(ckInfo);\n        long popTime = ExtraInfoUtil.getPopTime(ckInfoList);\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, ExtraInfoUtil.getQueueId(ckInfoList));\n    }\n",
    "focal_tgt": "    private void decrementInFlightMessageNum(String topic, String group, int queueId, int delta) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.addAndGet(-delta) <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "test_id": 77
  },
  "78": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "test_src_code": "    @Test\n    public void testNum() {\n        BrokerController brokerController = mock(BrokerController.class);\n        long brokerStartTime = System.currentTimeMillis();\n        when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n        PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n        final String topic = \"topic\";\n        final String group = \"group\";\n\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.incrementInFlightMessageNum(topic, group, 0, 3);\n        assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis() - 1000,\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        PopCheckPoint popCheckPoint = new PopCheckPoint();\n        popCheckPoint.setTopic(topic);\n        popCheckPoint.setCId(group);\n        popCheckPoint.setQueueId(0);\n        popCheckPoint.setPopTime(System.currentTimeMillis());\n\n        counter.decrementInFlightMessageNum(popCheckPoint);\n        assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId());\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(String topic, String group, long popTime, int qId, int delta) {\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, qId, delta);\n    }\n",
    "test_id": 78
  },
  "79": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "test_src_code": "    @Test\n    public void testNum() {\n        BrokerController brokerController = mock(BrokerController.class);\n        long brokerStartTime = System.currentTimeMillis();\n        when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n        PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n        final String topic = \"topic\";\n        final String group = \"group\";\n\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.incrementInFlightMessageNum(topic, group, 0, 3);\n        assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis() - 1000,\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        PopCheckPoint popCheckPoint = new PopCheckPoint();\n        popCheckPoint.setTopic(topic);\n        popCheckPoint.setCId(group);\n        popCheckPoint.setQueueId(0);\n        popCheckPoint.setPopTime(System.currentTimeMillis());\n\n        counter.decrementInFlightMessageNum(popCheckPoint);\n        assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId());\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId(), 1);\n    }\n",
    "test_id": 79
  },
  "80": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "test_src_code": "    @Test\n    public void testNum() {\n        BrokerController brokerController = mock(BrokerController.class);\n        long brokerStartTime = System.currentTimeMillis();\n        when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n        PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n        final String topic = \"topic\";\n        final String group = \"group\";\n\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.incrementInFlightMessageNum(topic, group, 0, 3);\n        assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis() - 1000,\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        PopCheckPoint popCheckPoint = new PopCheckPoint();\n        popCheckPoint.setTopic(topic);\n        popCheckPoint.setCId(group);\n        popCheckPoint.setQueueId(0);\n        popCheckPoint.setPopTime(System.currentTimeMillis());\n\n        counter.decrementInFlightMessageNum(popCheckPoint);\n        assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId());\n    }\n",
    "focal_tgt": "    private void decrementInFlightMessageNum(String topic, String group, int queueId, int delta) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.addAndGet(-delta) <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "test_id": 80
  },
  "81": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "test_src_code": "    @Test\n    public void testNum() {\n        BrokerController brokerController = mock(BrokerController.class);\n        long brokerStartTime = System.currentTimeMillis();\n        when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n        PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n        final String topic = \"topic\";\n        final String group = \"group\";\n\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.incrementInFlightMessageNum(topic, group, 0, 3);\n        assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis() - 1000,\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        PopCheckPoint popCheckPoint = new PopCheckPoint();\n        popCheckPoint.setTopic(topic);\n        popCheckPoint.setCId(group);\n        popCheckPoint.setQueueId(0);\n        popCheckPoint.setPopTime(System.currentTimeMillis());\n\n        counter.decrementInFlightMessageNum(popCheckPoint);\n        assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, int queueId) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.decrementAndGet() <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(String topic, String group, long popTime, int qId, int delta) {\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, qId, delta);\n    }\n",
    "test_id": 81
  },
  "82": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "test_src_code": "    @Test\n    public void testNum() {\n        BrokerController brokerController = mock(BrokerController.class);\n        long brokerStartTime = System.currentTimeMillis();\n        when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n        PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n        final String topic = \"topic\";\n        final String group = \"group\";\n\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.incrementInFlightMessageNum(topic, group, 0, 3);\n        assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis() - 1000,\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        PopCheckPoint popCheckPoint = new PopCheckPoint();\n        popCheckPoint.setTopic(topic);\n        popCheckPoint.setCId(group);\n        popCheckPoint.setQueueId(0);\n        popCheckPoint.setPopTime(System.currentTimeMillis());\n\n        counter.decrementInFlightMessageNum(popCheckPoint);\n        assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, int queueId) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.decrementAndGet() <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId(), 1);\n    }\n",
    "test_id": 82
  },
  "83": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "test_src_code": "    @Test\n    public void testNum() {\n        BrokerController brokerController = mock(BrokerController.class);\n        long brokerStartTime = System.currentTimeMillis();\n        when(brokerController.getShouldStartTime()).thenReturn(brokerStartTime);\n        PopInflightMessageCounter counter = new PopInflightMessageCounter(brokerController);\n\n        final String topic = \"topic\";\n        final String group = \"group\";\n\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.incrementInFlightMessageNum(topic, group, 0, 3);\n        assertEquals(3, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis() - 1000,\n            0, 0, topic, \"broker\", 0));\n        assertEquals(2, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        PopCheckPoint popCheckPoint = new PopCheckPoint();\n        popCheckPoint.setTopic(topic);\n        popCheckPoint.setCId(group);\n        popCheckPoint.setQueueId(0);\n        popCheckPoint.setPopTime(System.currentTimeMillis());\n\n        counter.decrementInFlightMessageNum(popCheckPoint);\n        assertEquals(1, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n\n        counter.decrementInFlightMessageNum(topic, group, ExtraInfoUtil.buildExtraInfo(0, System.currentTimeMillis(),\n            0, 0, topic, \"broker\", 0));\n        assertEquals(0, counter.getGroupPopInFlightMessageNum(topic, group, 0));\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, int queueId) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.decrementAndGet() <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "focal_tgt": "    private void decrementInFlightMessageNum(String topic, String group, int queueId, int delta) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.addAndGet(-delta) <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "test_id": 83
  },
  "84": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.remoting.activity.SendMessageActivityTest#testSendMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.remoting.activity.SendMessageActivityTest#testSendMessage"
    ],
    "test_src_code": "    @Test\n    public void testSendMessage() throws Exception {\n        when(metadataServiceMock.getTopicMessageType(eq(topic))).thenReturn(TopicMessageType.NORMAL);\n        Message message = new Message(topic, \"123\".getBytes());\n        message.putUserProperty(\"a\", \"b\");\n        SendMessageRequestHeader sendMessageRequestHeader = new SendMessageRequestHeader();\n        sendMessageRequestHeader.setTopic(topic);\n        sendMessageRequestHeader.setProducerGroup(producerGroup);\n        sendMessageRequestHeader.setDefaultTopic(\"\");\n        sendMessageRequestHeader.setDefaultTopicQueueNums(0);\n        sendMessageRequestHeader.setQueueId(0);\n        sendMessageRequestHeader.setSysFlag(0);\n        sendMessageRequestHeader.setBname(brokerName);\n        sendMessageRequestHeader.setProperties(MessageDecoder.messageProperties2String(message.getProperties()));\n        RemotingCommand remotingCommand = RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE, sendMessageRequestHeader);\n        remotingCommand.setBody(message.getBody());\n        remotingCommand.makeCustomHeaderToNet();\n\n        RemotingCommand expectResponse = RemotingCommand.createResponseCommand(ResponseCode.SUCCESS, \"success\");\n        when(messagingProcessorMock.request(any(), eq(brokerName), eq(remotingCommand), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(expectResponse));\n        RemotingCommand response = sendMessageActivity.processRequest0(ctx, remotingCommand, null);\n        assertThat(response).isNull();\n        verify(ctx, times(1)).writeAndFlush(eq(expectResponse));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivity.java#sendMessage",
    "focal_src": "    protected RemotingCommand sendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        SendMessageRequestHeader requestHeader = SendMessageRequestHeader.parseRequestHeader(request);\n        String topic = requestHeader.getTopic();\n        Map<String, String> property = MessageDecoder.string2messageProperties(requestHeader.getProperties());\n        TopicMessageType messageType = TopicMessageType.parseFromMessageProperty(property);\n        if (ConfigurationManager.getProxyConfig().isEnableTopicMessageTypeCheck()) {\n            if (topicMessageTypeValidator != null) {\n                // Do not check retry or dlq topic\n                if (!NamespaceUtil.isRetryTopic(topic) && !NamespaceUtil.isDLQTopic(topic)) {\n                    TopicMessageType topicMessageType = messagingProcessor.getMetadataService().getTopicMessageType(topic);\n                    topicMessageTypeValidator.validate(topicMessageType, messageType);\n                }\n            }\n        }\n        if (!NamespaceUtil.isRetryTopic(topic) && !NamespaceUtil.isDLQTopic(topic)) {\n            if (TopicMessageType.TRANSACTION.equals(messageType)) {\n                messagingProcessor.addTransactionSubscription(context, requestHeader.getProducerGroup(), requestHeader.getTopic());\n            }\n        }\n        return request(ctx, request, context, Duration.ofSeconds(3).toMillis());\n    }\n",
    "focal_tgt": "    protected RemotingCommand sendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        SendMessageRequestHeader requestHeader = SendMessageRequestHeader.parseRequestHeader(request);\n        String topic = requestHeader.getTopic();\n        Map<String, String> property = MessageDecoder.string2messageProperties(requestHeader.getProperties());\n        TopicMessageType messageType = TopicMessageType.parseFromMessageProperty(property);\n        if (ConfigurationManager.getProxyConfig().isEnableTopicMessageTypeCheck()) {\n            if (topicMessageTypeValidator != null) {\n                // Do not check retry or dlq topic\n                if (!NamespaceUtil.isRetryTopic(topic) && !NamespaceUtil.isDLQTopic(topic)) {\n                    TopicMessageType topicMessageType = messagingProcessor.getMetadataService().getTopicMessageType(context, topic);\n                    topicMessageTypeValidator.validate(topicMessageType, messageType);\n                }\n            }\n        }\n        if (!NamespaceUtil.isRetryTopic(topic) && !NamespaceUtil.isDLQTopic(topic)) {\n            if (TopicMessageType.TRANSACTION.equals(messageType)) {\n                messagingProcessor.addTransactionSubscription(context, requestHeader.getProducerGroup(), requestHeader.getTopic());\n            }\n        }\n        return request(ctx, request, context, Duration.ofSeconds(3).toMillis());\n    }\n",
    "test_id": 84
  },
  "85": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.message.ClusterMessageServiceTest#testAckMessageByInvalidBrokerNameHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.message.ClusterMessageServiceTest#testAckMessageByInvalidBrokerNameHandle"
    ],
    "test_src_code": "    @Test\n    public void testAckMessageByInvalidBrokerNameHandle() throws Exception {\n        when(topicRouteService.getBrokerAddr(anyString())).thenThrow(new MQClientException(ResponseCode.TOPIC_NOT_EXIST, \"\"));\n        try {\n            this.clusterMessageService.ackMessage(\n                ProxyContext.create(),\n                ReceiptHandle.builder()\n                    .startOffset(0L)\n                    .retrieveTime(System.currentTimeMillis())\n                    .invisibleTime(3000)\n                    .reviveQueueId(1)\n                    .topicType(ReceiptHandle.NORMAL_TOPIC)\n                    .brokerName(\"notExistBroker\")\n                    .queueId(0)\n                    .offset(123)\n                    .commitLogOffset(0L)\n                    .build(),\n                MessageClientIDSetter.createUniqID(),\n                new AckMessageRequestHeader(),\n                3000);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e instanceof ProxyException);\n            ProxyException proxyException = (ProxyException) e;\n            assertEquals(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, proxyException.getCode());\n        }\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/message/ClusterMessageService.java#ackMessage",
    "focal_src": "    @Override\n    public CompletableFuture<AckResult> ackMessage(ProxyContext ctx, ReceiptHandle handle, String messageId,\n        AckMessageRequestHeader requestHeader, long timeoutMillis) {\n        return this.mqClientAPIFactory.getClient().ackMessageAsync(\n            this.resolveBrokerAddrInReceiptHandle(handle),\n            requestHeader,\n            timeoutMillis\n        );\n    }\n",
    "focal_tgt": "    @Override\n    public CompletableFuture<AckResult> ackMessage(ProxyContext ctx, ReceiptHandle handle, String messageId,\n        AckMessageRequestHeader requestHeader, long timeoutMillis) {\n        return this.mqClientAPIFactory.getClient().ackMessageAsync(\n            this.resolveBrokerAddrInReceiptHandle(ctx, handle),\n            requestHeader,\n            timeoutMillis\n        );\n    }\n",
    "test_id": 85
  },
  "86": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetTopicMessageType",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetTopicMessageType"
    ],
    "test_src_code": "    @Test\n    public void testGetTopicMessageType() {\n        assertEquals(TopicMessageType.UNSPECIFIED, this.clusterMetadataService.getTopicMessageType(ERR_TOPIC));\n        assertEquals(1, this.clusterMetadataService.topicConfigCache.asMap().size());\n        assertEquals(TopicMessageType.UNSPECIFIED, this.clusterMetadataService.getTopicMessageType(ERR_TOPIC));\n\n        assertEquals(TopicMessageType.NORMAL, this.clusterMetadataService.getTopicMessageType(TOPIC));\n        assertEquals(2, this.clusterMetadataService.topicConfigCache.asMap().size());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataService.java#getTopicMessageType",
    "focal_src": "    @Override\n    public TopicMessageType getTopicMessageType(String topic) {\n        TopicConfigAndQueueMapping topicConfigAndQueueMapping;\n        try {\n            topicConfigAndQueueMapping = topicConfigCache.get(topic);\n        } catch (Exception e) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        if (topicConfigAndQueueMapping.equals(EMPTY_TOPIC_CONFIG)) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        return topicConfigAndQueueMapping.getTopicMessageType();\n    }\n",
    "focal_tgt": "    @Override\n    public TopicMessageType getTopicMessageType(ProxyContext ctx, String topic) {\n        TopicConfigAndQueueMapping topicConfigAndQueueMapping;\n        try {\n            topicConfigAndQueueMapping = topicConfigCache.get(topic);\n        } catch (Exception e) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        if (topicConfigAndQueueMapping.equals(EMPTY_TOPIC_CONFIG)) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        return topicConfigAndQueueMapping.getTopicMessageType();\n    }\n",
    "test_id": 86
  },
  "87": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetSubscriptionGroupConfig",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetSubscriptionGroupConfig"
    ],
    "test_src_code": "    @Test\n    public void testGetSubscriptionGroupConfig() {\n        assertNotNull(this.clusterMetadataService.getSubscriptionGroupConfig(GROUP));\n        assertEquals(1, this.clusterMetadataService.subscriptionGroupConfigCache.asMap().size());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataService.java#getSubscriptionGroupConfig",
    "focal_src": "    @Override\n    public SubscriptionGroupConfig getSubscriptionGroupConfig(String group) {\n        SubscriptionGroupConfig config;\n        try {\n            config = this.subscriptionGroupConfigCache.get(group);\n        } catch (Exception e) {\n            return null;\n        }\n        if (config == EMPTY_SUBSCRIPTION_GROUP_CONFIG) {\n            return null;\n        }\n        return config;\n    }\n",
    "focal_tgt": "    @Override\n    public SubscriptionGroupConfig getSubscriptionGroupConfig(ProxyContext ctx, String group) {\n        SubscriptionGroupConfig config;\n        try {\n            config = this.subscriptionGroupConfigCache.get(group);\n        } catch (Exception e) {\n            return null;\n        }\n        if (config == EMPTY_SUBSCRIPTION_GROUP_CONFIG) {\n            return null;\n        }\n        return config;\n    }\n",
    "test_id": 87
  },
  "88": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetCurrentMessageQueueView",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetCurrentMessageQueueView"
    ],
    "test_src_code": "    @Test\n    public void testGetCurrentMessageQueueView() throws Throwable {\n        MQClientException exception = catchThrowableOfType(() -> this.topicRouteService.getCurrentMessageQueueView(ERR_TOPIC), MQClientException.class);\n        assertTrue(TopicRouteHelper.isTopicNotExistError(exception));\n        assertEquals(1, this.topicRouteService.topicCache.asMap().size());\n\n        assertNotNull(this.topicRouteService.getCurrentMessageQueueView(TOPIC));\n        assertEquals(2, this.topicRouteService.topicCache.asMap().size());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteService.java#getCurrentMessageQueueView",
    "focal_src": "    @Override\n    public MessageQueueView getCurrentMessageQueueView(String topicName) throws Exception {\n        return getAllMessageQueueView(topicName);\n    }\n",
    "focal_tgt": "    @Override\n    public MessageQueueView getCurrentMessageQueueView(ProxyContext ctx, String topicName) throws Exception {\n        return getAllMessageQueueView(ctx, topicName);\n    }\n",
    "test_id": 88
  },
  "89": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetTopicRouteForProxy",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetTopicRouteForProxy"
    ],
    "test_src_code": "    @Test\n    public void testGetTopicRouteForProxy() throws Throwable {\n        List<Address> addressList = Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\"127.0.0.1\", 8888)));\n        ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(addressList, TOPIC);\n\n        assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n        assertEquals(addressList, proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteService.java#getTopicRouteForProxy",
    "focal_src": "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        TopicRouteData topicRouteData = getAllMessageQueueView(topicName).getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                proxyBrokerData.getBrokerAddrs().put(brokerId, requestHostAndPortList);\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n",
    "focal_tgt": "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(ProxyContext ctx, List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        TopicRouteData topicRouteData = getAllMessageQueueView(ctx, topicName).getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                proxyBrokerData.getBrokerAddrs().put(brokerId, requestHostAndPortList);\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n",
    "test_id": 89
  },
  "90": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetCurrentMessageQueueView",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetCurrentMessageQueueView"
    ],
    "test_src_code": "    @Test\n    public void testGetCurrentMessageQueueView() throws Throwable {\n        this.topicConfigTable.put(TOPIC, new TopicConfig(TOPIC, 3, 2, PermName.PERM_WRITE | PermName.PERM_READ));\n        MessageQueueView messageQueueView = this.topicRouteService.getCurrentMessageQueueView(TOPIC);\n        assertEquals(3, messageQueueView.getReadSelector().getQueues().size());\n        assertEquals(2, messageQueueView.getWriteSelector().getQueues().size());\n        assertEquals(1, messageQueueView.getReadSelector().getBrokerActingQueues().size());\n        assertEquals(1, messageQueueView.getWriteSelector().getBrokerActingQueues().size());\n\n        assertEquals(LOCAL_ADDR, messageQueueView.getReadSelector().selectOne(true).getBrokerAddr());\n        assertEquals(LOCAL_BROKER_NAME, messageQueueView.getReadSelector().selectOne(true).getBrokerName());\n        assertEquals(messageQueueView.getReadSelector().selectOne(true), messageQueueView.getWriteSelector().selectOne(true));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteService.java#getCurrentMessageQueueView",
    "focal_src": "    @Override\n    public MessageQueueView getCurrentMessageQueueView(String topic) throws Exception {\n        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().getTopicConfigTable().get(topic);\n        return new MessageQueueView(topic, toTopicRouteData(topicConfig));\n    }\n",
    "focal_tgt": "    @Override\n    public MessageQueueView getCurrentMessageQueueView(ProxyContext ctx, String topic) throws Exception {\n        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().getTopicConfigTable().get(topic);\n        return new MessageQueueView(topic, toTopicRouteData(topicConfig));\n    }\n",
    "test_id": 90
  },
  "91": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetTopicRouteForProxy",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetTopicRouteForProxy"
    ],
    "test_src_code": "    @Test\n    public void testGetTopicRouteForProxy() throws Throwable {\n        ProxyTopicRouteData proxyTopicRouteData = this.topicRouteService.getTopicRouteForProxy(new ArrayList<>(), TOPIC);\n\n        assertEquals(1, proxyTopicRouteData.getBrokerDatas().size());\n        assertEquals(\n            Lists.newArrayList(new Address(Address.AddressScheme.IPv4, HostAndPort.fromParts(\n                HostAndPort.fromString(BROKER_ADDR).getHost(),\n                ConfigurationManager.getProxyConfig().getGrpcServerPort()))),\n            proxyTopicRouteData.getBrokerDatas().get(0).getBrokerAddrs().get(MixAll.MASTER_ID));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteService.java#getTopicRouteForProxy",
    "focal_src": "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        MessageQueueView messageQueueView = getAllMessageQueueView(topicName);\n        TopicRouteData topicRouteData = messageQueueView.getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                String brokerAddr = brokerData.getBrokerAddrs().get(brokerId);\n                HostAndPort brokerHostAndPort = HostAndPort.fromString(brokerAddr);\n                HostAndPort grpcHostAndPort = HostAndPort.fromParts(brokerHostAndPort.getHost(), grpcPort);\n\n                proxyBrokerData.getBrokerAddrs().put(brokerId, Lists.newArrayList(new Address(Address.AddressScheme.IPv4, grpcHostAndPort)));\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n",
    "focal_tgt": "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(ProxyContext ctx, List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        MessageQueueView messageQueueView = getAllMessageQueueView(ctx, topicName);\n        TopicRouteData topicRouteData = messageQueueView.getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                String brokerAddr = brokerData.getBrokerAddrs().get(brokerId);\n                HostAndPort brokerHostAndPort = HostAndPort.fromString(brokerAddr);\n                HostAndPort grpcHostAndPort = HostAndPort.fromParts(brokerHostAndPort.getHost(), grpcPort);\n\n                proxyBrokerData.getBrokerAddrs().put(brokerId, Lists.newArrayList(new Address(Address.AddressScheme.IPv4, grpcHostAndPort)));\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n",
    "test_id": 91
  },
  "92": {
    "commit_src": "737c1e53383350a5671fa207ee0e4ce932850bac",
    "commit_tgt": "7996ec3b3f7ccea01f66951ac639b48303bbf7a6",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtilsTest.java"
    ],
    "refer_PR": "apache_rocketmq-6883",
    "test_src": ".org.apache.rocketmq.common.utils.ConcurrentHashMapUtilsTest#computeIfAbsent",
    "test_tgt": [
      ".org.apache.rocketmq.common.utils.ConcurrentHashMapUtilsTest#computeIfAbsent"
    ],
    "test_src_code": "    @Test\n    public void computeIfAbsent() {\n\n        ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n        map.put(\"123\", \"1111\");\n        String value = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"234\");\n        assertEquals(\"1111\", value);\n        String value1 = ConcurrentHashMapUtils.computeIfAbsent(map, \"1232\", k -> \"2342\");\n        assertEquals(\"2342\", value1);\n        String value2 = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"2342\");\n        assertEquals(\"1111\", value2);\n    }\n",
    "focal_path": "common/src/main/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtils.java#computeIfAbsent",
    "focal_src": "    /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br> Use implementation of\n     * ConcurrentMap.computeIfAbsent instead.\n     *\n     * @see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\n    public static <K, V> V computeIfAbsent(ConcurrentMap<K, V> map, K key, Function<? super K, ? extends V> func) {\n        if (isJdk8) {\n            V v = map.get(key);\n            if (null == v) {\n                v = map.computeIfAbsent(key, func);\n            }\n            return v;\n        } else {\n            return map.computeIfAbsent(key, func);\n        }\n    }\n",
    "focal_tgt": "    /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br> Use implementation of\n     * ConcurrentMap.computeIfAbsent instead.\n     *\n     * @see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\n    public static <K, V> V computeIfAbsent(ConcurrentMap<K, V> map, K key, Function<? super K, ? extends V> func) {\n        Objects.requireNonNull(func);\n        if (isJdk8) {\n            V v = map.get(key);\n            if (null == v) {\n//                v = map.computeIfAbsent(key, func);\n\n                // this bug fix methods maybe cause `func.apply` multiple calls.\n                v = func.apply(key);\n                if (null == v) {\n                    return null;\n                }\n                final V res = map.putIfAbsent(key, v);\n                if (null != res) {\n                    // if pre value present, means other thread put value already, and putIfAbsent not effect\n                    // return exist value\n                    return res;\n                }\n            }\n            return v;\n        } else {\n            return map.computeIfAbsent(key, func);\n        }\n    }\n",
    "test_id": 92
  },
  "93": {
    "commit_src": "3dda55e812240ee5bb667d078fb49acc13f0ccb4",
    "commit_tgt": "aea5811df007c2abf2d46eea931e4c867514e0eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6885",
    "test_src": ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncGrpcV2Channel",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncGrpcV2Channel"
    ],
    "test_src_code": "    @Test\n    public void testSyncGrpcV2Channel() throws Exception {\n        String consumerGroup = \"consumerGroup\";\n        GrpcClientSettingsManager grpcClientSettingsManager = mock(GrpcClientSettingsManager.class);\n        GrpcChannelManager grpcChannelManager = mock(GrpcChannelManager.class);\n        GrpcClientChannel grpcClientChannel = new GrpcClientChannel(\n            proxyRelayService, grpcClientSettingsManager, grpcChannelManager,\n            ProxyContext.create().setRemoteAddress(remoteAddress).setLocalAddress(localAddress),\n            clientId);\n        ClientChannelInfo clientChannelInfo = new ClientChannelInfo(\n            grpcClientChannel,\n            clientId,\n            LanguageCode.JAVA,\n            5\n        );\n\n        ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n        SendResult sendResult = new SendResult();\n        sendResult.setSendStatus(SendStatus.SEND_OK);\n        doReturn(CompletableFuture.completedFuture(sendResult)).when(this.mqClientAPIExt)\n            .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n\n        Settings settings = Settings.newBuilder()\n            .setSubscription(Subscription.newBuilder()\n                .addSubscriptions(SubscriptionEntry.newBuilder()\n                    .setTopic(Resource.newBuilder().setName(\"topic\").build())\n                    .setExpression(FilterExpression.newBuilder()\n                        .setType(FilterType.TAG)\n                        .setExpression(\"tag\")\n                        .build())\n                    .build())\n                .build())\n            .build();\n        when(grpcClientSettingsManager.getRawClientSettings(eq(clientId))).thenReturn(settings);\n\n        HeartbeatSyncer heartbeatSyncer = new HeartbeatSyncer(topicRouteService, adminService, consumerManager, mqClientAPIFactory);\n        heartbeatSyncer.onConsumerRegister(\n            consumerGroup,\n            clientChannelInfo,\n            ConsumeType.CONSUME_PASSIVELY,\n            MessageModel.CLUSTERING,\n            ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n            Sets.newHashSet(FilterAPI.buildSubscriptionData(\"topic\", \"tag\"))\n        );\n\n        await().atMost(Duration.ofSeconds(3)).until(() -> !messageArgumentCaptor.getAllValues().isEmpty());\n        heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n        verify(consumerManager, never()).registerConsumer(anyString(), any(), any(), any(), any(), any(), anyBoolean());\n\n        String localServeAddr = ConfigurationManager.getProxyConfig().getLocalServeAddr();\n        // change local serve addr, to simulate other proxy receive messages\n        heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n        ArgumentCaptor<ClientChannelInfo> syncChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n        doReturn(true).when(consumerManager).registerConsumer(anyString(), syncChannelInfoArgumentCaptor.capture(), any(), any(), any(), any(), anyBoolean());\n\n        heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n        heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getValue())), null);\n        assertEquals(2, syncChannelInfoArgumentCaptor.getAllValues().size());\n        List<ClientChannelInfo> channelInfoList = syncChannelInfoArgumentCaptor.getAllValues();\n        assertSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n        assertEquals(settings, GrpcClientChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n        assertEquals(settings, GrpcClientChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n\n        // start test sync client unregister\n        // reset localServeAddr\n        ConfigurationManager.getProxyConfig().setLocalServeAddr(localServeAddr);\n        heartbeatSyncer.onConsumerUnRegister(consumerGroup, clientChannelInfo);\n        await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n\n        ArgumentCaptor<ClientChannelInfo> syncUnRegisterChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n        doNothing().when(consumerManager).unregisterConsumer(anyString(), syncUnRegisterChannelInfoArgumentCaptor.capture(), anyBoolean());\n\n        // change local serve addr, to simulate other proxy receive messages\n        heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n        heartbeatSyncer.consumeMessage(Lists.newArrayList(convertFromMessage(messageArgumentCaptor.getAllValues().get(1))), null);\n        assertSame(channelInfoList.get(0).getChannel(), syncUnRegisterChannelInfoArgumentCaptor.getValue().getChannel());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncer.java#HeartbeatSyncer",
    "focal_src": "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n        ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory) {\n        super(topicRouteService, adminService, mqClientAPIFactory);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n",
    "focal_tgt": "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n                           ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory, RPCHook rpcHook) {\n        super(topicRouteService, adminService, mqClientAPIFactory, rpcHook);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n",
    "test_id": 93
  },
  "94": {
    "commit_src": "3dda55e812240ee5bb667d078fb49acc13f0ccb4",
    "commit_tgt": "aea5811df007c2abf2d46eea931e4c867514e0eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6885",
    "test_src": ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncRemotingChannel",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncRemotingChannel"
    ],
    "test_src_code": "    @Test\n    public void testSyncRemotingChannel() throws Exception {\n        String consumerGroup = \"consumerGroup\";\n        String consumerGroup2 = \"consumerGroup2\";\n        Channel channel = createMockChannel();\n        Set<SubscriptionData> subscriptionDataSet = new HashSet<>();\n        subscriptionDataSet.add(FilterAPI.buildSubscriptionData(\"topic\", \"tagSub\"));\n        Set<SubscriptionData> subscriptionDataSet2 = new HashSet<>();\n        subscriptionDataSet2.add(FilterAPI.buildSubscriptionData(\"topic2\", \"tagSub2\"));\n        RemotingProxyOutClient remotingProxyOutClient = mock(RemotingProxyOutClient.class);\n        RemotingChannel remotingChannel = new RemotingChannel(remotingProxyOutClient, proxyRelayService, channel, clientId, subscriptionDataSet);\n        ClientChannelInfo clientChannelInfo = new ClientChannelInfo(\n            remotingChannel,\n            clientId,\n            LanguageCode.JAVA,\n            4\n        );\n        RemotingChannel remotingChannel2 = new RemotingChannel(remotingProxyOutClient, proxyRelayService, channel, clientId, subscriptionDataSet2);\n        ClientChannelInfo clientChannelInfo2 = new ClientChannelInfo(\n            remotingChannel2,\n            clientId,\n            LanguageCode.JAVA,\n            4\n        );\n\n        HeartbeatSyncer heartbeatSyncer = new HeartbeatSyncer(topicRouteService, adminService, consumerManager, mqClientAPIFactory);\n        SendResult okSendResult = new SendResult();\n        okSendResult.setSendStatus(SendStatus.SEND_OK);\n        {\n            ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n            doReturn(CompletableFuture.completedFuture(okSendResult)).when(this.mqClientAPIExt)\n                .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n\n            heartbeatSyncer.onConsumerRegister(\n                consumerGroup,\n                clientChannelInfo,\n                ConsumeType.CONSUME_PASSIVELY,\n                MessageModel.CLUSTERING,\n                ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n                subscriptionDataSet\n            );\n            heartbeatSyncer.onConsumerRegister(\n                consumerGroup2,\n                clientChannelInfo2,\n                ConsumeType.CONSUME_PASSIVELY,\n                MessageModel.CLUSTERING,\n                ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET,\n                subscriptionDataSet2\n            );\n\n            await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n            heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n            verify(consumerManager, never()).registerConsumer(anyString(), any(), any(), any(), any(), any(), anyBoolean());\n\n            // change local serve addr, to simulate other proxy receive messages\n            heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n            ArgumentCaptor<ClientChannelInfo> syncChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n            doReturn(true).when(consumerManager).registerConsumer(anyString(), syncChannelInfoArgumentCaptor.capture(), any(), any(), any(), any(), anyBoolean());\n\n            heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n            heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n            /*\n            data in syncChannelInfoArgumentCaptor will be like:\n            1st, data of group1\n            2nd, data of group2\n            3rd, data of group1\n            4th, data of group2\n             */\n            assertEquals(4, syncChannelInfoArgumentCaptor.getAllValues().size());\n            List<ClientChannelInfo> channelInfoList = syncChannelInfoArgumentCaptor.getAllValues();\n            assertSame(channelInfoList.get(0).getChannel(), channelInfoList.get(2).getChannel());\n            assertNotSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n            Set<Set<SubscriptionData>> checkSubscriptionDatas = new HashSet<>();\n            checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n            checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n            assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet));\n            assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet2));\n        }\n\n        {\n            // start test sync client unregister\n            // reset localServeAddr\n            ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n            doReturn(CompletableFuture.completedFuture(okSendResult)).when(this.mqClientAPIExt)\n                .sendMessageAsync(anyString(), anyString(), messageArgumentCaptor.capture(), any(), anyLong());\n            heartbeatSyncer.onConsumerUnRegister(consumerGroup, clientChannelInfo);\n            heartbeatSyncer.onConsumerUnRegister(consumerGroup2, clientChannelInfo2);\n            await().atMost(Duration.ofSeconds(3)).until(() -> messageArgumentCaptor.getAllValues().size() == 2);\n\n            ArgumentCaptor<ClientChannelInfo> syncUnRegisterChannelInfoArgumentCaptor = ArgumentCaptor.forClass(ClientChannelInfo.class);\n            doNothing().when(consumerManager).unregisterConsumer(anyString(), syncUnRegisterChannelInfoArgumentCaptor.capture(), anyBoolean());\n\n            // change local serve addr, to simulate other proxy receive messages\n            heartbeatSyncer.localProxyId = RandomStringUtils.randomAlphabetic(10);\n            heartbeatSyncer.consumeMessage(convertFromMessage(messageArgumentCaptor.getAllValues()), null);\n            List<ClientChannelInfo> channelInfoList = syncUnRegisterChannelInfoArgumentCaptor.getAllValues();\n            assertNotSame(channelInfoList.get(0).getChannel(), channelInfoList.get(1).getChannel());\n            Set<Set<SubscriptionData>> checkSubscriptionDatas = new HashSet<>();\n            checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(0).getChannel()));\n            checkSubscriptionDatas.add(RemotingChannel.parseChannelExtendAttribute(channelInfoList.get(1).getChannel()));\n            assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet));\n            assertTrue(checkSubscriptionDatas.contains(subscriptionDataSet2));\n        }\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncer.java#HeartbeatSyncer",
    "focal_src": "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n        ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory) {\n        super(topicRouteService, adminService, mqClientAPIFactory);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n",
    "focal_tgt": "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n                           ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory, RPCHook rpcHook) {\n        super(topicRouteService, adminService, mqClientAPIFactory, rpcHook);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n",
    "test_id": 94
  },
  "95": {
    "commit_src": "e369d7deac6e4dde950a8da7c3d976bb26d0e6b5",
    "commit_tgt": "16ef5755375e7c8f4fb11dd63f5fdfdfa25668e7",
    "changed_tests": [
      "client/src/test/java/org/apache/rocketmq/client/trace/TraceDataEncoderTest.java"
    ],
    "refer_PR": "apache_rocketmq-6941",
    "test_src": ".org.apache.rocketmq.client.trace.TraceDataEncoderTest#testSubAfterTraceDataFormatTest",
    "test_tgt": [
      ".org.apache.rocketmq.client.trace.TraceDataEncoderTest#testSubAfterTraceDataFormatTest"
    ],
    "test_src_code": "    @Test\n    public void testSubAfterTraceDataFormatTest() {\n        TraceContext subAfterContext = new TraceContext();\n        subAfterContext.setTraceType(TraceType.SubAfter);\n        subAfterContext.setRequestId(\"3455848576927\");\n        subAfterContext.setCostTime(20);\n        subAfterContext.setSuccess(true);\n        subAfterContext.setTimeStamp(1625883640000L);\n        subAfterContext.setGroupName(\"GroupName-test\");\n        subAfterContext.setContextCode(98623046);\n        TraceBean bean = new TraceBean();\n        bean.setMsgId(\"AC1415116D1418B4AAC217FE1B4E0000\");\n        bean.setKeys(\"keys\");\n        subAfterContext.setTraceBeans(new ArrayList<>(1));\n        subAfterContext.getTraceBeans().add(bean);\n\n        TraceTransferBean traceTransferBean = TraceDataEncoder.encoderFromContextBean(subAfterContext);\n        String transData = traceTransferBean.getTransData();\n        Assert.assertNotNull(transData);\n        String[] items = transData.split(String.valueOf(TraceConstants.CONTENT_SPLITOR));\n        Assert.assertEquals(9, items.length);\n\n    }\n",
    "focal_path": "client/src/main/java/org/apache/rocketmq/client/trace/TraceDataEncoder.java#encoderFromContextBean",
    "focal_src": "    /**\n     * Encoding the trace context into data strings and keyset sets\n     *\n     * @param ctx\n     * @return\n     */\n    public static TraceTransferBean encoderFromContextBean(TraceContext ctx) {\n        if (ctx == null) {\n            return null;\n        }\n        //build message trace of the transferring entity content bean\n        TraceTransferBean transferBean = new TraceTransferBean();\n        StringBuilder sb = new StringBuilder(256);\n        switch (ctx.getTraceType()) {\n            case Pub: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                //append the content of context and traceBean to transferBean's TransData\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getBodyLength()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getOffsetMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.isSuccess()).append(TraceConstants.FIELD_SPLITOR);//\n            }\n            break;\n            case SubBefore: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getRetryTimes()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.FIELD_SPLITOR);//\n                }\n            }\n            break;\n            case SubAfter: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.isSuccess()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getContextCode()).append(TraceConstants.CONTENT_SPLITOR)\n                        .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)\n                        .append(ctx.getGroupName()).append(TraceConstants.FIELD_SPLITOR);\n                }\n            }\n            break;\n            case EndTransaction: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionState().name()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.isFromTransactionCheck()).append(TraceConstants.FIELD_SPLITOR);\n            }\n            break;\n            default:\n        }\n        transferBean.setTransData(sb.toString());\n        for (TraceBean bean : ctx.getTraceBeans()) {\n\n            transferBean.getTransKey().add(bean.getMsgId());\n            if (bean.getKeys() != null && bean.getKeys().length() > 0) {\n                String[] keys = bean.getKeys().split(MessageConst.KEY_SEPARATOR);\n                transferBean.getTransKey().addAll(Arrays.asList(keys));\n            }\n        }\n        return transferBean;\n    }\n",
    "focal_tgt": "    /**\n     * Encoding the trace context into data strings and keyset sets\n     *\n     * @param ctx\n     * @return\n     */\n    public static TraceTransferBean encoderFromContextBean(TraceContext ctx) {\n        if (ctx == null) {\n            return null;\n        }\n        //build message trace of the transferring entity content bean\n        TraceTransferBean transferBean = new TraceTransferBean();\n        StringBuilder sb = new StringBuilder(256);\n        switch (ctx.getTraceType()) {\n            case Pub: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                //append the content of context and traceBean to transferBean's TransData\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getBodyLength()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getOffsetMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.isSuccess()).append(TraceConstants.FIELD_SPLITOR);//\n            }\n            break;\n            case SubBefore: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getRetryTimes()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.FIELD_SPLITOR);//\n                }\n            }\n            break;\n            case SubAfter: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.isSuccess()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getContextCode()).append(TraceConstants.CONTENT_SPLITOR);\n                    if (!ctx.getAccessChannel().equals(AccessChannel.CLOUD)) {\n                        sb.append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)\n                            .append(ctx.getGroupName()).append(TraceConstants.FIELD_SPLITOR);\n                    }\n                }\n            }\n            break;\n            case EndTransaction: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionState().name()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.isFromTransactionCheck()).append(TraceConstants.FIELD_SPLITOR);\n            }\n            break;\n            default:\n        }\n        transferBean.setTransData(sb.toString());\n        for (TraceBean bean : ctx.getTraceBeans()) {\n\n            transferBean.getTransKey().add(bean.getMsgId());\n            if (bean.getKeys() != null && bean.getKeys().length() > 0) {\n                String[] keys = bean.getKeys().split(MessageConst.KEY_SEPARATOR);\n                transferBean.getTransKey().addAll(Arrays.asList(keys));\n            }\n        }\n        return transferBean;\n    }\n",
    "test_id": 95
  },
  "96": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetProducerData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetProducerData"
    ],
    "test_src_code": "    @Test\n    public void testGetProducerData() {\n        ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n        this.grpcClientSettingsManager.updateClientSettings(CLIENT_ID, Settings.newBuilder()\n            .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n            .setPublishing(Publishing.getDefaultInstance())\n            .build());\n        Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n        assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#getClientSettings",
    "focal_src": "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = CLIENT_SETTINGS_MAP.get(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "focal_tgt": "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = getRawClientSettings(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "test_id": 96
  },
  "97": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetProducerData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetProducerData"
    ],
    "test_src_code": "    @Test\n    public void testGetProducerData() {\n        ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n        this.grpcClientSettingsManager.updateClientSettings(CLIENT_ID, Settings.newBuilder()\n            .setBackoffPolicy(RetryPolicy.getDefaultInstance())\n            .setPublishing(Publishing.getDefaultInstance())\n            .build());\n        Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertNotEquals(settings.getBackoffPolicy(), settings.getBackoffPolicy().getDefaultInstanceForType());\n        assertNotEquals(settings.getPublishing(), settings.getPublishing().getDefaultInstanceForType());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#updateClientSettings",
    "focal_src": "    public void updateClientSettings(String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n",
    "focal_tgt": "    public void updateClientSettings(ProxyContext ctx, String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n",
    "test_id": 97
  },
  "98": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData"
    ],
    "test_src_code": "    @Test\n    public void testGetSubscriptionData() {\n        SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n        when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n            .thenReturn(subscriptionGroupConfig);\n\n        this.grpcClientSettingsManager.updateClientSettings(CLIENT_ID, Settings.newBuilder()\n            .setSubscription(Subscription.newBuilder()\n                .setGroup(Resource.newBuilder().setName(\"group\").build())\n                .build())\n            .build());\n\n        ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n        Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n        subscriptionGroupConfig.setRetryMaxTimes(3);\n        subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n        subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n        settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(RetryPolicy.newBuilder()\n            .setMaxAttempts(4)\n            .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n                .addNext(Durations.fromSeconds(1))\n                .build())\n            .build(), settings.getBackoffPolicy());\n\n        subscriptionGroupConfig.setRetryMaxTimes(10);\n        subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n        subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n        settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(RetryPolicy.newBuilder()\n            .setMaxAttempts(11)\n            .setExponentialBackoff(ExponentialBackoff.newBuilder()\n                .setMax(Durations.fromSeconds(2))\n                .setInitial(Durations.fromSeconds(1))\n                .setMultiplier(3)\n                .build())\n            .build(), settings.getBackoffPolicy());\n\n        Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n        assertEquals(settings, settings1);\n\n        assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n        assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#getClientSettings",
    "focal_src": "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = CLIENT_SETTINGS_MAP.get(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "focal_tgt": "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = getRawClientSettings(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "test_id": 98
  },
  "99": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData"
    ],
    "test_src_code": "    @Test\n    public void testGetSubscriptionData() {\n        SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n        when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n            .thenReturn(subscriptionGroupConfig);\n\n        this.grpcClientSettingsManager.updateClientSettings(CLIENT_ID, Settings.newBuilder()\n            .setSubscription(Subscription.newBuilder()\n                .setGroup(Resource.newBuilder().setName(\"group\").build())\n                .build())\n            .build());\n\n        ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n        Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n        subscriptionGroupConfig.setRetryMaxTimes(3);\n        subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n        subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n        settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(RetryPolicy.newBuilder()\n            .setMaxAttempts(4)\n            .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n                .addNext(Durations.fromSeconds(1))\n                .build())\n            .build(), settings.getBackoffPolicy());\n\n        subscriptionGroupConfig.setRetryMaxTimes(10);\n        subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n        subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n        settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(RetryPolicy.newBuilder()\n            .setMaxAttempts(11)\n            .setExponentialBackoff(ExponentialBackoff.newBuilder()\n                .setMax(Durations.fromSeconds(2))\n                .setInitial(Durations.fromSeconds(1))\n                .setMultiplier(3)\n                .build())\n            .build(), settings.getBackoffPolicy());\n\n        Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n        assertEquals(settings, settings1);\n\n        assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n        assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#updateClientSettings",
    "focal_src": "    public void updateClientSettings(String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n",
    "focal_tgt": "    public void updateClientSettings(ProxyContext ctx, String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n",
    "test_id": 99
  },
  "100": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData"
    ],
    "test_src_code": "    @Test\n    public void testGetSubscriptionData() {\n        SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n        when(this.messagingProcessor.getSubscriptionGroupConfig(any(), any()))\n            .thenReturn(subscriptionGroupConfig);\n\n        this.grpcClientSettingsManager.updateClientSettings(CLIENT_ID, Settings.newBuilder()\n            .setSubscription(Subscription.newBuilder()\n                .setGroup(Resource.newBuilder().setName(\"group\").build())\n                .build())\n            .build());\n\n        ProxyContext context = ProxyContext.create().withVal(ContextVariable.CLIENT_ID, CLIENT_ID);\n\n        Settings settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(settings.getBackoffPolicy(), this.grpcClientSettingsManager.createDefaultConsumerSettingsBuilder().build().getBackoffPolicy());\n\n        subscriptionGroupConfig.setRetryMaxTimes(3);\n        subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.CUSTOMIZED);\n        subscriptionGroupConfig.getGroupRetryPolicy().setCustomizedRetryPolicy(new CustomizedRetryPolicy(new long[] {1000}));\n        settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(RetryPolicy.newBuilder()\n            .setMaxAttempts(4)\n            .setCustomizedBackoff(CustomizedBackoff.newBuilder()\n                .addNext(Durations.fromSeconds(1))\n                .build())\n            .build(), settings.getBackoffPolicy());\n\n        subscriptionGroupConfig.setRetryMaxTimes(10);\n        subscriptionGroupConfig.getGroupRetryPolicy().setType(GroupRetryPolicyType.EXPONENTIAL);\n        subscriptionGroupConfig.getGroupRetryPolicy().setExponentialRetryPolicy(new ExponentialRetryPolicy(1000, 2000, 3));\n        settings = this.grpcClientSettingsManager.getClientSettings(context);\n        assertEquals(RetryPolicy.newBuilder()\n            .setMaxAttempts(11)\n            .setExponentialBackoff(ExponentialBackoff.newBuilder()\n                .setMax(Durations.fromSeconds(2))\n                .setInitial(Durations.fromSeconds(1))\n                .setMultiplier(3)\n                .build())\n            .build(), settings.getBackoffPolicy());\n\n        Settings settings1 = this.grpcClientSettingsManager.removeAndGetClientSettings(context);\n        assertEquals(settings, settings1);\n\n        assertNull(this.grpcClientSettingsManager.getClientSettings(context));\n        assertNull(this.grpcClientSettingsManager.removeAndGetClientSettings(context));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#removeAndGetClientSettings",
    "focal_src": "    public Settings removeAndGetClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = CLIENT_SETTINGS_MAP.remove(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "focal_tgt": "    public Settings removeAndGetClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = this.removeAndGetRawClientSettings(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "test_id": 100
  },
  "101": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithoutSub",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithoutSub"
    ],
    "test_src_code": "    @Test\n    public void testPullMessageWithoutSub() throws Exception {\n        when(messagingProcessorMock.getConsumerGroupInfo(eq(group)))\n            .thenReturn(consumerGroupInfoMock);\n        SubscriptionData subscriptionData = new SubscriptionData();\n        subscriptionData.setSubString(subString);\n        subscriptionData.setExpressionType(type);\n        when(consumerGroupInfoMock.findSubscriptionData(eq(topic)))\n            .thenReturn(subscriptionData);\n\n        PullMessageRequestHeader header = new PullMessageRequestHeader();\n        header.setTopic(topic);\n        header.setConsumerGroup(group);\n        header.setQueueId(0);\n        header.setQueueOffset(0L);\n        header.setMaxMsgNums(16);\n        header.setSysFlag(PullSysFlag.buildSysFlag(true, false, false, false));\n        header.setCommitOffset(0L);\n        header.setSuspendTimeoutMillis(1000L);\n        header.setSubVersion(0L);\n        header.setBname(brokerName);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, header);\n        request.makeCustomHeaderToNet();\n        RemotingCommand expectResponse = RemotingCommand.createResponseCommand(ResponseCode.NO_MESSAGE, \"success\");\n        PullMessageRequestHeader newHeader = new PullMessageRequestHeader();\n        newHeader.setTopic(topic);\n        newHeader.setConsumerGroup(group);\n        newHeader.setQueueId(0);\n        newHeader.setQueueOffset(0L);\n        newHeader.setMaxMsgNums(16);\n        newHeader.setSysFlag(PullSysFlag.buildSysFlag(true, false, true, false));\n        newHeader.setCommitOffset(0L);\n        newHeader.setSuspendTimeoutMillis(1000L);\n        newHeader.setSubVersion(0L);\n        newHeader.setBname(brokerName);\n        newHeader.setSubscription(subString);\n        newHeader.setExpressionType(type);\n        RemotingCommand matchRequest = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, newHeader);\n        matchRequest.setOpaque(request.getOpaque());\n        matchRequest.makeCustomHeaderToNet();\n\n        ArgumentCaptor<RemotingCommand> captor = ArgumentCaptor.forClass(RemotingCommand.class);\n        when(messagingProcessorMock.request(any(), eq(brokerName), captor.capture(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(expectResponse));\n        RemotingCommand response = pullMessageActivity.processRequest0(ctx, request, null);\n        assertThat(captor.getValue().getExtFields()).isEqualTo(matchRequest.getExtFields());\n        assertThat(response).isNull();\n        verify(ctx, times(1)).writeAndFlush(eq(expectResponse));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivity.java#processRequest0",
    "focal_src": "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n",
    "focal_tgt": "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(context, requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n",
    "test_id": 101
  },
  "102": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithSub",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithSub"
    ],
    "test_src_code": "    @Test\n    public void testPullMessageWithSub() throws Exception {\n        when(messagingProcessorMock.getConsumerGroupInfo(eq(group)))\n            .thenReturn(consumerGroupInfoMock);\n        SubscriptionData subscriptionData = new SubscriptionData();\n        subscriptionData.setSubString(subString);\n        subscriptionData.setExpressionType(type);\n        when(consumerGroupInfoMock.findSubscriptionData(eq(topic)))\n            .thenReturn(subscriptionData);\n\n        PullMessageRequestHeader header = new PullMessageRequestHeader();\n        header.setTopic(topic);\n        header.setConsumerGroup(group);\n        header.setQueueId(0);\n        header.setQueueOffset(0L);\n        header.setMaxMsgNums(16);\n        header.setSysFlag(PullSysFlag.buildSysFlag(true, true, false, false));\n        header.setCommitOffset(0L);\n        header.setSuspendTimeoutMillis(1000L);\n        header.setSubVersion(0L);\n        header.setBname(brokerName);\n        header.setSubscription(subString);\n        header.setExpressionType(type);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, header);\n        request.makeCustomHeaderToNet();\n        RemotingCommand expectResponse = RemotingCommand.createResponseCommand(ResponseCode.NO_MESSAGE, \"success\");\n\n        ArgumentCaptor<RemotingCommand> captor = ArgumentCaptor.forClass(RemotingCommand.class);\n        when(messagingProcessorMock.request(any(), eq(brokerName), captor.capture(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(expectResponse));\n        RemotingCommand response = pullMessageActivity.processRequest0(ctx, request, null);\n        assertThat(captor.getValue().getExtFields()).isEqualTo(request.getExtFields());\n        assertThat(response).isNull();\n        verify(ctx, times(1)).writeAndFlush(eq(expectResponse));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivity.java#processRequest0",
    "focal_src": "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n",
    "focal_tgt": "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(context, requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n",
    "test_id": 102
  },
  "103": {
    "commit_src": "a1bf49d5d07cf64374bc3dde5ab43add831433ad",
    "commit_tgt": "ab61183030f4f230619ea539cbd2cb977234208b",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-7105",
    "test_src": ".org.apache.rocketmq.proxy.service.receipt.DefaultReceiptHandleManagerTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.receipt.DefaultReceiptHandleManagerTest#testClearGroup"
    ],
    "test_src_code": "    @Test\n    public void testClearGroup() {\n        Channel channel = PROXY_CONTEXT.getVal(ContextVariable.CHANNEL);\n        receiptHandleManager.addReceiptHandle(PROXY_CONTEXT, channel, GROUP, MSG_ID, messageReceiptHandle);\n        receiptHandleManager.clearGroup(new ReceiptHandleProcessor.ReceiptHandleGroupKey(channel, GROUP));\n        SubscriptionGroupConfig groupConfig = new SubscriptionGroupConfig();\n        Mockito.when(metadataService.getSubscriptionGroupConfig(Mockito.any(), Mockito.eq(GROUP))).thenReturn(groupConfig);\n        receiptHandleManager.scheduleRenewTask();\n        Mockito.verify(messagingProcessor, Mockito.timeout(1000).times(1))\n            .changeInvisibleTime(Mockito.any(ProxyContext.class), Mockito.any(ReceiptHandle.class), Mockito.eq(MESSAGE_ID),\n                Mockito.eq(GROUP), Mockito.eq(TOPIC), Mockito.eq(ConfigurationManager.getProxyConfig().getInvisibleTimeMillisWhenClear()));\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManager.java#clearGroup",
    "focal_src": "    protected void clearGroup(ReceiptHandleProcessor.ReceiptHandleGroupKey key) {\n        if (key == null) {\n            return;\n        }\n        ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n        ReceiptHandleGroup handleGroup = receiptHandleGroupMap.remove(key);\n        if (handleGroup == null) {\n            return;\n        }\n        handleGroup.scan((msgID, handle, v) -> {\n            try {\n                handleGroup.computeIfPresent(msgID, handle, messageReceiptHandle -> {\n                    CompletableFuture<AckResult> future = new CompletableFuture<>();\n                    eventListener.fireEvent(new RenewEvent(messageReceiptHandle, proxyConfig.getInvisibleTimeMillisWhenClear(), RenewEvent.EventType.CLEAR_GROUP, future));\n                    return CompletableFuture.completedFuture(null);\n                });\n            } catch (Exception e) {\n                log.error(\"error when clear handle for group. key:{}\", key, e);\n            }\n        });\n    }\n",
    "focal_tgt": "    protected void clearGroup(ReceiptHandleGroupKey key) {\n        if (key == null) {\n            return;\n        }\n        ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n        ReceiptHandleGroup handleGroup = receiptHandleGroupMap.remove(key);\n        if (handleGroup == null) {\n            return;\n        }\n        handleGroup.scan((msgID, handle, v) -> {\n            try {\n                handleGroup.computeIfPresent(msgID, handle, messageReceiptHandle -> {\n                    CompletableFuture<AckResult> future = new CompletableFuture<>();\n                    eventListener.fireEvent(new RenewEvent(key, messageReceiptHandle, proxyConfig.getInvisibleTimeMillisWhenClear(), RenewEvent.EventType.CLEAR_GROUP, future));\n                    return CompletableFuture.completedFuture(null);\n                });\n            } catch (Exception e) {\n                log.error(\"error when clear handle for group. key:{}\", key, e);\n            }\n        });\n    }\n",
    "test_id": 103
  },
  "104": {
    "commit_src": "017ad110475e8024585327b44f47e5e97aabc63b",
    "commit_tgt": "77e8e54b37c3fc3ea0beffc1ace6f5bf20af10d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/AckMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/BaseProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/mqclient/MQClientAPIExtTest.java"
    ],
    "refer_PR": "apache_rocketmq-7225",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.consumer.AckMessageActivityTest#testAckMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.AckMessageActivityTest#testAckMessage",
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.AckMessageActivityTest#testAckMessageInBatch"
    ],
    "test_src_code": "    @Test\n    public void testAckMessage() throws Throwable {\n        when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg1\"), anyString(), anyString()))\n            .thenThrow(new ProxyException(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, \"receipt handle is expired\"));\n\n        AckResult msg2AckResult = new AckResult();\n        msg2AckResult.setStatus(AckStatus.OK);\n        when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg2\"), anyString(), anyString()))\n            .thenReturn(CompletableFuture.completedFuture(msg2AckResult));\n\n        AckResult msg3AckResult = new AckResult();\n        msg3AckResult.setStatus(AckStatus.NO_EXIST);\n        when(this.messagingProcessor.ackMessage(any(), any(), eq(\"msg3\"), anyString(), anyString()))\n            .thenReturn(CompletableFuture.completedFuture(msg3AckResult));\n\n        AckMessageResponse response = this.ackMessageActivity.ackMessage(\n            createContext(),\n            AckMessageRequest.newBuilder()\n                .setTopic(Resource.newBuilder().setName(TOPIC).build())\n                .setGroup(Resource.newBuilder().setName(GROUP).build())\n                .addEntries(AckMessageEntry.newBuilder()\n                    .setMessageId(\"msg1\")\n                    .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis() - 10000, 1000))\n                    .build())\n                .addEntries(AckMessageEntry.newBuilder()\n                    .setMessageId(\"msg2\")\n                    .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                    .build())\n                .addEntries(AckMessageEntry.newBuilder()\n                    .setMessageId(\"msg3\")\n                    .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                    .build())\n                .build()\n        ).get();\n\n        assertEquals(Code.MULTIPLE_RESULTS, response.getStatus().getCode());\n        assertEquals(3, response.getEntriesCount());\n        assertEquals(Code.INVALID_RECEIPT_HANDLE, response.getEntries(0).getStatus().getCode());\n        assertEquals(Code.OK, response.getEntries(1).getStatus().getCode());\n        assertEquals(Code.INTERNAL_SERVER_ERROR, response.getEntries(2).getStatus().getCode());\n    }\n",
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/AckMessageActivity.java#ackMessage",
    "focal_src": "    public CompletableFuture<AckMessageResponse> ackMessage(ProxyContext ctx, AckMessageRequest request) {\n        CompletableFuture<AckMessageResponse> future = new CompletableFuture<>();\n\n        try {\n            validateTopicAndConsumerGroup(request.getTopic(), request.getGroup());\n\n            CompletableFuture<AckMessageResultEntry>[] futures = new CompletableFuture[request.getEntriesCount()];\n            for (int i = 0; i < request.getEntriesCount(); i++) {\n                futures[i] = processAckMessage(ctx, request, request.getEntries(i));\n            }\n            CompletableFuture.allOf(futures).whenComplete((val, throwable) -> {\n                if (throwable != null) {\n                    future.completeExceptionally(throwable);\n                    return;\n                }\n\n                Set<Code> responseCodes = new HashSet<>();\n                List<AckMessageResultEntry> entryList = new ArrayList<>();\n                for (CompletableFuture<AckMessageResultEntry> entryFuture : futures) {\n                    AckMessageResultEntry entryResult = entryFuture.join();\n                    responseCodes.add(entryResult.getStatus().getCode());\n                    entryList.add(entryResult);\n                }\n                AckMessageResponse.Builder responseBuilder = AckMessageResponse.newBuilder()\n                    .addAllEntries(entryList);\n                if (responseCodes.size() > 1) {\n                    responseBuilder.setStatus(ResponseBuilder.getInstance().buildStatus(Code.MULTIPLE_RESULTS, Code.MULTIPLE_RESULTS.name()));\n                } else if (responseCodes.size() == 1) {\n                    Code code = responseCodes.stream().findAny().get();\n                    responseBuilder.setStatus(ResponseBuilder.getInstance().buildStatus(code, code.name()));\n                } else {\n                    responseBuilder.setStatus(ResponseBuilder.getInstance().buildStatus(Code.INTERNAL_SERVER_ERROR, \"ack message result is empty\"));\n                }\n                future.complete(responseBuilder.build());\n            });\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n",
    "focal_tgt": "    public CompletableFuture<AckMessageResponse> ackMessage(ProxyContext ctx, AckMessageRequest request) {\n        CompletableFuture<AckMessageResponse> future = new CompletableFuture<>();\n\n        try {\n            validateTopicAndConsumerGroup(request.getTopic(), request.getGroup());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getTopic());\n            if (ConfigurationManager.getProxyConfig().isEnableBatchAck()) {\n                future = ackMessageInBatch(ctx, group, topic, request);\n            } else {\n                future = ackMessageOneByOne(ctx, group, topic, request);\n            }\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n",
    "test_id": 104
  },
  "105": {
    "commit_src": "c36bb78e850129b9db40adc5b0e1b9bfd5c8fd2e",
    "commit_tgt": "84156084a4c5228e1d2fe21e068fff330bbc40d1",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/RemotingServerTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannel.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannelPromise.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstractTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingClientTest.java"
    ],
    "refer_PR": "apache_rocketmq-7322",
    "test_src": ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand"
    ],
    "test_src_code": "    @Test\n    public void testProcessResponseCommand() throws InterruptedException {\n        final Semaphore semaphore = new Semaphore(0);\n        ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n            @Override\n            public void operationComplete(final ResponseFuture responseFuture) {\n                assertThat(semaphore.availablePermits()).isEqualTo(0);\n            }\n        }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n        remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n\n        RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n        response.setOpaque(1);\n        remotingAbstract.processResponseCommand(null, response);\n\n        // Acquire the release permit after call back\n        semaphore.acquire(1);\n        assertThat(semaphore.availablePermits()).isEqualTo(0);\n    }\n",
    "focal_path": "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand",
    "focal_src": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, but not matched any request, \" + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n            log.warn(cmd.toString());\n        }\n    }\n",
    "focal_tgt": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, cmd={}, but not matched any request, address={}\", cmd, RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n    }\n",
    "test_id": 105
  },
  "106": {
    "commit_src": "c36bb78e850129b9db40adc5b0e1b9bfd5c8fd2e",
    "commit_tgt": "84156084a4c5228e1d2fe21e068fff330bbc40d1",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/RemotingServerTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannel.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannelPromise.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstractTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingClientTest.java"
    ],
    "refer_PR": "apache_rocketmq-7322",
    "test_src": ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand_RunCallBackInCurrentThread",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand_RunCallBackInCurrentThread"
    ],
    "test_src_code": "    @Test\n    public void testProcessResponseCommand_RunCallBackInCurrentThread() throws InterruptedException {\n        final Semaphore semaphore = new Semaphore(0);\n        ResponseFuture responseFuture = new ResponseFuture(null, 1, 3000, new InvokeCallback() {\n            @Override\n            public void operationComplete(final ResponseFuture responseFuture) {\n                assertThat(semaphore.availablePermits()).isEqualTo(0);\n            }\n        }, new SemaphoreReleaseOnlyOnce(semaphore));\n\n        remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n        when(remotingAbstract.getCallbackExecutor()).thenReturn(null);\n\n        RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n        response.setOpaque(1);\n        remotingAbstract.processResponseCommand(null, response);\n\n        // Acquire the release permit after call back finished in current thread\n        semaphore.acquire(1);\n        assertThat(semaphore.availablePermits()).isEqualTo(0);\n    }\n",
    "focal_path": "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand",
    "focal_src": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, but not matched any request, \" + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n            log.warn(cmd.toString());\n        }\n    }\n",
    "focal_tgt": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, cmd={}, but not matched any request, address={}\", cmd, RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n    }\n",
    "test_id": 106
  },
  "107": {
    "commit_src": "c36bb78e850129b9db40adc5b0e1b9bfd5c8fd2e",
    "commit_tgt": "84156084a4c5228e1d2fe21e068fff330bbc40d1",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/RemotingServerTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannel.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannelPromise.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstractTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingClientTest.java"
    ],
    "refer_PR": "apache_rocketmq-7322",
    "test_src": ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessRequestCommand",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessRequestCommand"
    ],
    "test_src_code": "    @Test\n    public void testProcessRequestCommand() throws InterruptedException {\n        final Semaphore semaphore = new Semaphore(0);\n        RemotingCommand request = RemotingCommand.createRequestCommand(1, null);\n        ResponseFuture responseFuture = new ResponseFuture(null, 1, request, 3000,\n            responseFuture1 -> assertThat(semaphore.availablePermits()).isEqualTo(0), new SemaphoreReleaseOnlyOnce(semaphore));\n\n        remotingAbstract.responseTable.putIfAbsent(1, responseFuture);\n        RemotingCommand response = RemotingCommand.createResponseCommand(0, \"Foo\");\n        response.setOpaque(1);\n        remotingAbstract.processResponseCommand(null, response);\n\n        // Acquire the release permit after call back\n        semaphore.acquire(1);\n        assertThat(semaphore.availablePermits()).isEqualTo(0);\n    }\n",
    "focal_path": "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand",
    "focal_src": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, but not matched any request, \" + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n            log.warn(cmd.toString());\n        }\n    }\n",
    "focal_tgt": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, cmd={}, but not matched any request, address={}\", cmd, RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n    }\n",
    "test_id": 107
  },
  "108": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testUpdateAndCreateTopicOnSlaveInRocksdb",
    "test_tgt": [],
    "test_src_code": "    @Test\n    public void testUpdateAndCreateTopicOnSlaveInRocksdb() throws Exception {\n        if (notToBeExecuted()) {\n            return;\n        }\n        initRocksdbTopicManager();\n        testUpdateAndCreateTopicOnSlave();\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#updateAndCreateTopic",
    "focal_src": "    private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        final CreateTopicRequestHeader requestHeader =\n            (CreateTopicRequestHeader) request.decodeCommandCustomHeader(CreateTopicRequestHeader.class);\n\n        LOGGER.info(\"Broker receive request to update or create topic={}, caller address={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        TopicConfig topicConfig = new TopicConfig(topic);\n        topicConfig.setReadQueueNums(requestHeader.getReadQueueNums());\n        topicConfig.setWriteQueueNums(requestHeader.getWriteQueueNums());\n        topicConfig.setTopicFilterType(requestHeader.getTopicFilterTypeEnum());\n        topicConfig.setPerm(requestHeader.getPerm());\n        topicConfig.setTopicSysFlag(requestHeader.getTopicSysFlag() == null ? 0 : requestHeader.getTopicSysFlag());\n        topicConfig.setOrder(requestHeader.getOrder());\n        String attributesModification = requestHeader.getAttributes();\n        topicConfig.setAttributes(AttributeParser.parseToMap(attributesModification));\n\n        if (topicConfig.getTopicMessageType() == TopicMessageType.MIXED\n            && !brokerController.getBrokerConfig().isEnableMixedMessageType()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"MIXED message type is not supported.\");\n            return response;\n        }\n\n        try {\n            this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);\n            if (brokerController.getBrokerConfig().isEnableSingleTopicRegister()) {\n                this.brokerController.registerSingleTopicAll(topicConfig);\n            } else {\n                this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());\n            }\n            response.setCode(ResponseCode.SUCCESS);\n        } catch (Exception e) {\n            LOGGER.error(\"Update / create topic failed for [{}]\", request, e);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(e.getMessage());\n        }\n\n        return response;\n    }\n",
    "focal_tgt": "    private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        final CreateTopicRequestHeader requestHeader =\n            (CreateTopicRequestHeader) request.decodeCommandCustomHeader(CreateTopicRequestHeader.class);\n\n        LOGGER.info(\"Broker receive request to update or create topic={}, caller address={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        TopicConfig topicConfig = new TopicConfig(topic);\n        topicConfig.setReadQueueNums(requestHeader.getReadQueueNums());\n        topicConfig.setWriteQueueNums(requestHeader.getWriteQueueNums());\n        topicConfig.setTopicFilterType(requestHeader.getTopicFilterTypeEnum());\n        topicConfig.setPerm(requestHeader.getPerm());\n        topicConfig.setTopicSysFlag(requestHeader.getTopicSysFlag() == null ? 0 : requestHeader.getTopicSysFlag());\n        topicConfig.setOrder(requestHeader.getOrder());\n        String attributesModification = requestHeader.getAttributes();\n        topicConfig.setAttributes(AttributeParser.parseToMap(attributesModification));\n\n        if (topicConfig.getTopicMessageType() == TopicMessageType.MIXED\n            && !brokerController.getBrokerConfig().isEnableMixedMessageType()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"MIXED message type is not supported.\");\n            return response;\n        }\n\n        try {\n            this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);\n            if (brokerController.getBrokerConfig().isEnableSingleTopicRegister()) {\n                this.brokerController.registerSingleTopicAll(topicConfig);\n            } else {\n                this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());\n            }\n            response.setCode(ResponseCode.SUCCESS);\n        } catch (Exception e) {\n            LOGGER.error(\"Update / create topic failed for [{}]\", request, e);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(e.getMessage());\n        }\n\n        return response;\n    }\n",
    "test_id": 108
  },
  "109": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testUpdateAndCreateTopicOnSlave",
    "test_tgt": [],
    "test_src_code": "    @Test\n    public void testUpdateAndCreateTopicOnSlave() throws Exception {\n        // setup\n        MessageStoreConfig messageStoreConfig = mock(MessageStoreConfig.class);\n        when(messageStoreConfig.getBrokerRole()).thenReturn(BrokerRole.SLAVE);\n        defaultMessageStore = mock(DefaultMessageStore.class);\n        when(brokerController.getMessageStoreConfig()).thenReturn(messageStoreConfig);\n\n        // test on slave\n        String topic = \"TEST_CREATE_TOPIC\";\n        RemotingCommand request = buildCreateTopicRequest(topic);\n        RemotingCommand response = adminBrokerProcessor.processRequest(handlerContext, request);\n        assertThat(response.getCode()).isEqualTo(ResponseCode.SYSTEM_ERROR);\n        assertThat(response.getRemark()).isEqualTo(\"Can't modify topic or subscription group from slave broker, \" +\n            \"please execute it from master broker.\");\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#updateAndCreateTopic",
    "focal_src": "    private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        final CreateTopicRequestHeader requestHeader =\n            (CreateTopicRequestHeader) request.decodeCommandCustomHeader(CreateTopicRequestHeader.class);\n\n        LOGGER.info(\"Broker receive request to update or create topic={}, caller address={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        TopicConfig topicConfig = new TopicConfig(topic);\n        topicConfig.setReadQueueNums(requestHeader.getReadQueueNums());\n        topicConfig.setWriteQueueNums(requestHeader.getWriteQueueNums());\n        topicConfig.setTopicFilterType(requestHeader.getTopicFilterTypeEnum());\n        topicConfig.setPerm(requestHeader.getPerm());\n        topicConfig.setTopicSysFlag(requestHeader.getTopicSysFlag() == null ? 0 : requestHeader.getTopicSysFlag());\n        topicConfig.setOrder(requestHeader.getOrder());\n        String attributesModification = requestHeader.getAttributes();\n        topicConfig.setAttributes(AttributeParser.parseToMap(attributesModification));\n\n        if (topicConfig.getTopicMessageType() == TopicMessageType.MIXED\n            && !brokerController.getBrokerConfig().isEnableMixedMessageType()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"MIXED message type is not supported.\");\n            return response;\n        }\n\n        try {\n            this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);\n            if (brokerController.getBrokerConfig().isEnableSingleTopicRegister()) {\n                this.brokerController.registerSingleTopicAll(topicConfig);\n            } else {\n                this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());\n            }\n            response.setCode(ResponseCode.SUCCESS);\n        } catch (Exception e) {\n            LOGGER.error(\"Update / create topic failed for [{}]\", request, e);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(e.getMessage());\n        }\n\n        return response;\n    }\n",
    "focal_tgt": "    private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        final CreateTopicRequestHeader requestHeader =\n            (CreateTopicRequestHeader) request.decodeCommandCustomHeader(CreateTopicRequestHeader.class);\n\n        LOGGER.info(\"Broker receive request to update or create topic={}, caller address={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        TopicConfig topicConfig = new TopicConfig(topic);\n        topicConfig.setReadQueueNums(requestHeader.getReadQueueNums());\n        topicConfig.setWriteQueueNums(requestHeader.getWriteQueueNums());\n        topicConfig.setTopicFilterType(requestHeader.getTopicFilterTypeEnum());\n        topicConfig.setPerm(requestHeader.getPerm());\n        topicConfig.setTopicSysFlag(requestHeader.getTopicSysFlag() == null ? 0 : requestHeader.getTopicSysFlag());\n        topicConfig.setOrder(requestHeader.getOrder());\n        String attributesModification = requestHeader.getAttributes();\n        topicConfig.setAttributes(AttributeParser.parseToMap(attributesModification));\n\n        if (topicConfig.getTopicMessageType() == TopicMessageType.MIXED\n            && !brokerController.getBrokerConfig().isEnableMixedMessageType()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"MIXED message type is not supported.\");\n            return response;\n        }\n\n        try {\n            this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);\n            if (brokerController.getBrokerConfig().isEnableSingleTopicRegister()) {\n                this.brokerController.registerSingleTopicAll(topicConfig);\n            } else {\n                this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());\n            }\n            response.setCode(ResponseCode.SUCCESS);\n        } catch (Exception e) {\n            LOGGER.error(\"Update / create topic failed for [{}]\", request, e);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(e.getMessage());\n        }\n\n        return response;\n    }\n",
    "test_id": 109
  },
  "110": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testDeleteTopicOnSlaveInRocksdb",
    "test_tgt": [],
    "test_src_code": "    @Test\n    public void testDeleteTopicOnSlaveInRocksdb() throws Exception {\n        if (notToBeExecuted()) {\n            return;\n        }\n        initRocksdbTopicManager();\n        testDeleteTopicOnSlave();\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#deleteTopic",
    "focal_src": "    private synchronized RemotingCommand deleteTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        DeleteTopicRequestHeader requestHeader =\n            (DeleteTopicRequestHeader) request.decodeCommandCustomHeader(DeleteTopicRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteTopic: broker receive request to delete topic={}, caller={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        final Set<String> groups = this.brokerController.getConsumerOffsetManager().whichGroupByTopic(topic);\n        // delete pop retry topics first\n        for (String group : groups) {\n            final String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n            if (brokerController.getTopicConfigManager().selectTopicConfig(popRetryTopic) != null) {\n                deleteTopicInBroker(popRetryTopic);\n            }\n        }\n        // delete topic\n        deleteTopicInBroker(topic);\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private synchronized RemotingCommand deleteTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        DeleteTopicRequestHeader requestHeader =\n            (DeleteTopicRequestHeader) request.decodeCommandCustomHeader(DeleteTopicRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteTopic: broker receive request to delete topic={}, caller={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        final Set<String> groups = this.brokerController.getConsumerOffsetManager().whichGroupByTopic(topic);\n        // delete pop retry topics first\n        for (String group : groups) {\n            final String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n            if (brokerController.getTopicConfigManager().selectTopicConfig(popRetryTopic) != null) {\n                deleteTopicInBroker(popRetryTopic);\n            }\n        }\n        // delete topic\n        deleteTopicInBroker(topic);\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 110
  },
  "111": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testDeleteTopicOnSlave",
    "test_tgt": [],
    "test_src_code": "    @Test\n    public void testDeleteTopicOnSlave() throws Exception {\n        // setup\n        MessageStoreConfig messageStoreConfig = mock(MessageStoreConfig.class);\n        when(messageStoreConfig.getBrokerRole()).thenReturn(BrokerRole.SLAVE);\n        defaultMessageStore = mock(DefaultMessageStore.class);\n        when(brokerController.getMessageStoreConfig()).thenReturn(messageStoreConfig);\n\n        String topic = \"TEST_DELETE_TOPIC\";\n        RemotingCommand request = buildDeleteTopicRequest(topic);\n        RemotingCommand response = adminBrokerProcessor.processRequest(handlerContext, request);\n        assertThat(response.getCode()).isEqualTo(ResponseCode.SYSTEM_ERROR);\n        assertThat(response.getRemark()).isEqualTo(\"Can't modify topic or subscription group from slave broker, \" +\n            \"please execute it from master broker.\");\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#deleteTopic",
    "focal_src": "    private synchronized RemotingCommand deleteTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        DeleteTopicRequestHeader requestHeader =\n            (DeleteTopicRequestHeader) request.decodeCommandCustomHeader(DeleteTopicRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteTopic: broker receive request to delete topic={}, caller={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        final Set<String> groups = this.brokerController.getConsumerOffsetManager().whichGroupByTopic(topic);\n        // delete pop retry topics first\n        for (String group : groups) {\n            final String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n            if (brokerController.getTopicConfigManager().selectTopicConfig(popRetryTopic) != null) {\n                deleteTopicInBroker(popRetryTopic);\n            }\n        }\n        // delete topic\n        deleteTopicInBroker(topic);\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private synchronized RemotingCommand deleteTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        DeleteTopicRequestHeader requestHeader =\n            (DeleteTopicRequestHeader) request.decodeCommandCustomHeader(DeleteTopicRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteTopic: broker receive request to delete topic={}, caller={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        final Set<String> groups = this.brokerController.getConsumerOffsetManager().whichGroupByTopic(topic);\n        // delete pop retry topics first\n        for (String group : groups) {\n            final String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n            if (brokerController.getTopicConfigManager().selectTopicConfig(popRetryTopic) != null) {\n                deleteTopicInBroker(popRetryTopic);\n            }\n        }\n        // delete topic\n        deleteTopicInBroker(topic);\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 111
  },
  "112": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testUpdateAndCreateSubscriptionGroupOnSlaveInRocksdb",
    "test_tgt": [],
    "test_src_code": "    @Test\n    public void testUpdateAndCreateSubscriptionGroupOnSlaveInRocksdb() throws Exception {\n        initRocksdbSubscriptionManager();\n        testUpdateAndCreateSubscriptionGroupOnSlave();\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#updateAndCreateSubscriptionGroup",
    "focal_src": "    private RemotingCommand updateAndCreateSubscriptionGroup(ChannelHandlerContext ctx, RemotingCommand request)\n        throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n\n        LOGGER.info(\"AdminBrokerProcessor#updateAndCreateSubscriptionGroup called by {}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        SubscriptionGroupConfig config = RemotingSerializable.decode(request.getBody(), SubscriptionGroupConfig.class);\n        if (config != null) {\n            this.brokerController.getSubscriptionGroupManager().updateSubscriptionGroupConfig(config);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private RemotingCommand updateAndCreateSubscriptionGroup(ChannelHandlerContext ctx, RemotingCommand request)\n        throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        LOGGER.info(\"AdminBrokerProcessor#updateAndCreateSubscriptionGroup called by {}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        SubscriptionGroupConfig config = RemotingSerializable.decode(request.getBody(), SubscriptionGroupConfig.class);\n        if (config != null) {\n            this.brokerController.getSubscriptionGroupManager().updateSubscriptionGroupConfig(config);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 112
  },
  "113": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testUpdateAndCreateSubscriptionGroupOnSlave",
    "test_tgt": [],
    "test_src_code": "    @Test\n    public void testUpdateAndCreateSubscriptionGroupOnSlave() throws RemotingCommandException {\n        // Setup\n        MessageStoreConfig messageStoreConfig = mock(MessageStoreConfig.class);\n        when(messageStoreConfig.getBrokerRole()).thenReturn(BrokerRole.SLAVE);\n        defaultMessageStore = mock(DefaultMessageStore.class);\n        when(brokerController.getMessageStoreConfig()).thenReturn(messageStoreConfig);\n\n        // Test\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.UPDATE_AND_CREATE_SUBSCRIPTIONGROUP, null);\n        SubscriptionGroupConfig subscriptionGroupConfig = new SubscriptionGroupConfig();\n        subscriptionGroupConfig.setBrokerId(1);\n        subscriptionGroupConfig.setGroupName(\"groupId\");\n        subscriptionGroupConfig.setConsumeEnable(Boolean.TRUE);\n        subscriptionGroupConfig.setConsumeBroadcastEnable(Boolean.TRUE);\n        subscriptionGroupConfig.setRetryMaxTimes(111);\n        subscriptionGroupConfig.setConsumeFromMinEnable(Boolean.TRUE);\n        request.setBody(JSON.toJSON(subscriptionGroupConfig).toString().getBytes());\n        RemotingCommand response = adminBrokerProcessor.processRequest(handlerContext, request);\n        assertThat(response.getCode()).isEqualTo(ResponseCode.SYSTEM_ERROR);\n        assertThat(response.getRemark()).isEqualTo(\"Can't modify topic or subscription group from slave broker, \" +\n            \"please execute it from master broker.\");\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#updateAndCreateSubscriptionGroup",
    "focal_src": "    private RemotingCommand updateAndCreateSubscriptionGroup(ChannelHandlerContext ctx, RemotingCommand request)\n        throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n\n        LOGGER.info(\"AdminBrokerProcessor#updateAndCreateSubscriptionGroup called by {}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        SubscriptionGroupConfig config = RemotingSerializable.decode(request.getBody(), SubscriptionGroupConfig.class);\n        if (config != null) {\n            this.brokerController.getSubscriptionGroupManager().updateSubscriptionGroupConfig(config);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private RemotingCommand updateAndCreateSubscriptionGroup(ChannelHandlerContext ctx, RemotingCommand request)\n        throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        LOGGER.info(\"AdminBrokerProcessor#updateAndCreateSubscriptionGroup called by {}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        SubscriptionGroupConfig config = RemotingSerializable.decode(request.getBody(), SubscriptionGroupConfig.class);\n        if (config != null) {\n            this.brokerController.getSubscriptionGroupManager().updateSubscriptionGroupConfig(config);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 113
  },
  "114": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testDeleteSubscriptionGroupOnSlaveInRocksdb",
    "test_tgt": [],
    "test_src_code": "    @Test\n    public void testDeleteSubscriptionGroupOnSlaveInRocksdb() throws Exception {\n        initRocksdbSubscriptionManager();\n        testDeleteSubscriptionGroupOnSlave();\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#deleteSubscriptionGroup",
    "focal_src": "    private RemotingCommand deleteSubscriptionGroup(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        DeleteSubscriptionGroupRequestHeader requestHeader =\n            (DeleteSubscriptionGroupRequestHeader) request.decodeCommandCustomHeader(DeleteSubscriptionGroupRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteSubscriptionGroup, caller={}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        this.brokerController.getSubscriptionGroupManager().deleteSubscriptionGroupConfig(requestHeader.getGroupName());\n\n        if (requestHeader.isCleanOffset()) {\n            this.brokerController.getConsumerOffsetManager().removeOffset(requestHeader.getGroupName());\n            this.brokerController.getPopInflightMessageCounter().clearInFlightMessageNumByGroupName(requestHeader.getGroupName());\n        }\n\n        if (this.brokerController.getBrokerConfig().isAutoDeleteUnusedStats()) {\n            this.brokerController.getBrokerStatsManager().onGroupDeleted(requestHeader.getGroupName());\n        }\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private RemotingCommand deleteSubscriptionGroup(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        DeleteSubscriptionGroupRequestHeader requestHeader =\n            (DeleteSubscriptionGroupRequestHeader) request.decodeCommandCustomHeader(DeleteSubscriptionGroupRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteSubscriptionGroup, caller={}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        this.brokerController.getSubscriptionGroupManager().deleteSubscriptionGroupConfig(requestHeader.getGroupName());\n\n        if (requestHeader.isCleanOffset()) {\n            this.brokerController.getConsumerOffsetManager().removeOffset(requestHeader.getGroupName());\n            this.brokerController.getPopInflightMessageCounter().clearInFlightMessageNumByGroupName(requestHeader.getGroupName());\n        }\n\n        if (this.brokerController.getBrokerConfig().isAutoDeleteUnusedStats()) {\n            this.brokerController.getBrokerStatsManager().onGroupDeleted(requestHeader.getGroupName());\n        }\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 114
  },
  "115": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testDeleteSubscriptionGroupOnSlave",
    "test_tgt": [],
    "test_src_code": "    @Test\n    public void testDeleteSubscriptionGroupOnSlave() throws RemotingCommandException {\n        // Setup\n        MessageStoreConfig messageStoreConfig = mock(MessageStoreConfig.class);\n        when(messageStoreConfig.getBrokerRole()).thenReturn(BrokerRole.SLAVE);\n        defaultMessageStore = mock(DefaultMessageStore.class);\n        when(brokerController.getMessageStoreConfig()).thenReturn(messageStoreConfig);\n\n        // Test\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.DELETE_SUBSCRIPTIONGROUP, null);\n        request.addExtField(\"groupName\", \"GID-Group-Name\");\n        request.addExtField(\"removeOffset\", \"true\");\n        RemotingCommand response = adminBrokerProcessor.processRequest(handlerContext, request);\n        assertThat(response.getCode()).isEqualTo(ResponseCode.SYSTEM_ERROR);\n        assertThat(response.getRemark()).isEqualTo(\"Can't modify topic or subscription group from slave broker, \" +\n            \"please execute it from master broker.\");\n    }\n",
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#deleteSubscriptionGroup",
    "focal_src": "    private RemotingCommand deleteSubscriptionGroup(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        DeleteSubscriptionGroupRequestHeader requestHeader =\n            (DeleteSubscriptionGroupRequestHeader) request.decodeCommandCustomHeader(DeleteSubscriptionGroupRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteSubscriptionGroup, caller={}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        this.brokerController.getSubscriptionGroupManager().deleteSubscriptionGroupConfig(requestHeader.getGroupName());\n\n        if (requestHeader.isCleanOffset()) {\n            this.brokerController.getConsumerOffsetManager().removeOffset(requestHeader.getGroupName());\n            this.brokerController.getPopInflightMessageCounter().clearInFlightMessageNumByGroupName(requestHeader.getGroupName());\n        }\n\n        if (this.brokerController.getBrokerConfig().isAutoDeleteUnusedStats()) {\n            this.brokerController.getBrokerStatsManager().onGroupDeleted(requestHeader.getGroupName());\n        }\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private RemotingCommand deleteSubscriptionGroup(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        DeleteSubscriptionGroupRequestHeader requestHeader =\n            (DeleteSubscriptionGroupRequestHeader) request.decodeCommandCustomHeader(DeleteSubscriptionGroupRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteSubscriptionGroup, caller={}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        this.brokerController.getSubscriptionGroupManager().deleteSubscriptionGroupConfig(requestHeader.getGroupName());\n\n        if (requestHeader.isCleanOffset()) {\n            this.brokerController.getConsumerOffsetManager().removeOffset(requestHeader.getGroupName());\n            this.brokerController.getPopInflightMessageCounter().clearInFlightMessageNumByGroupName(requestHeader.getGroupName());\n        }\n\n        if (this.brokerController.getBrokerConfig().isAutoDeleteUnusedStats()) {\n            this.brokerController.getBrokerStatsManager().onGroupDeleted(requestHeader.getGroupName());\n        }\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 115
  },
  "116": {
    "commit_src": "73b3fde83765e066541e3455cd1e6604292a9b7c",
    "commit_tgt": "88a9d939ce110381b3b418370d4711c0c214dc7f",
    "changed_tests": [
      "store/src/test/java/org/apache/rocketmq/store/timer/TimerMetricsTest.java"
    ],
    "refer_PR": "apache_rocketmq-7382",
    "test_src": ".org.apache.rocketmq.store.timer.TimerMetricsTest#testTimingCount",
    "test_tgt": [
      ".org.apache.rocketmq.store.timer.TimerMetricsTest#testTimingCount"
    ],
    "test_src_code": "    @Test\n    public void testTimingCount() {\n        String baseDir = StoreTestUtils.createBaseDir();\n\n        TimerMetrics first = new TimerMetrics(baseDir);\n        Assert.assertTrue(first.load());\n        first.addAndGet(\"AAA\", 1000);\n        first.addAndGet(\"BBB\", 2000);\n        Assert.assertEquals(1000, first.getTimingCount(\"AAA\"));\n        Assert.assertEquals(2000, first.getTimingCount(\"BBB\"));\n        long curr = System.currentTimeMillis();\n        Assert.assertTrue(first.getTopicPair(\"AAA\").getTimeStamp() > curr - 10);\n        Assert.assertTrue(first.getTopicPair(\"AAA\").getTimeStamp() <= curr);\n        first.persist();\n\n        TimerMetrics second = new TimerMetrics(baseDir);\n        Assert.assertTrue(second.load());\n        Assert.assertEquals(1000, second.getTimingCount(\"AAA\"));\n        Assert.assertEquals(2000, second.getTimingCount(\"BBB\"));\n        Assert.assertTrue(second.getTopicPair(\"BBB\").getTimeStamp() > curr - 100);\n        Assert.assertTrue(second.getTopicPair(\"BBB\").getTimeStamp() <= curr);\n        second.persist();\n        StoreTestUtils.deleteFile(baseDir);\n    }\n",
    "focal_path": "store/src/main/java/org/apache/rocketmq/store/timer/TimerMetrics.java#addAndGet",
    "focal_src": "    public long addAndGet(String topic, int value) {\n        Metric pair = getTopicPair(topic);\n        getDataVersion().nextVersion();\n        pair.setTimeStamp(System.currentTimeMillis());\n        return pair.getCount().addAndGet(value);\n    }\n",
    "focal_tgt": "    public long addAndGet(MessageExt msg, int value) {\n        String topic = msg.getProperty(MessageConst.PROPERTY_REAL_TOPIC);\n        Metric pair = getTopicPair(topic);\n        getDataVersion().nextVersion();\n        pair.setTimeStamp(System.currentTimeMillis());\n        return pair.getCount().addAndGet(value);\n    }\n",
    "test_id": 116
  },
  "117": {
    "commit_src": "84285d13a7d056a444e52f0f58e713b9a6343c08",
    "commit_tgt": "af1936d93ad9adab9527e19ceb5c89bb3a907e49",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/MixAllTest.java",
      "common/src/test/java/org/apache/rocketmq/common/NetworkUtilTest.java",
      "common/src/test/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtilsTest.java"
    ],
    "refer_PR": "apache_rocketmq-7714",
    "test_src": ".org.apache.rocketmq.common.MixAllTest#testGetLocalhostByNetworkInterface",
    "test_tgt": [],
    "test_src_code": "    @Test\n    public void testGetLocalhostByNetworkInterface() throws Exception {\n        assertThat(MixAll.LOCALHOST).isNotNull();\n        assertThat(MixAll.getLocalhostByNetworkInterface()).isNotNull();\n    }\n",
    "focal_path": "common/src/main/java/org/apache/rocketmq/common/MixAll.java#getLocalhostByNetworkInterface",
    "focal_src": "    public static String getLocalhostByNetworkInterface() throws SocketException {\n        List<String> candidatesHost = new ArrayList<>();\n        Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n\n        while (enumeration.hasMoreElements()) {\n            NetworkInterface networkInterface = enumeration.nextElement();\n            // Workaround for docker0 bridge\n            if (\"docker0\".equals(networkInterface.getName()) || !networkInterface.isUp()) {\n                continue;\n            }\n            Enumeration<InetAddress> addrs = networkInterface.getInetAddresses();\n            while (addrs.hasMoreElements()) {\n                InetAddress address = addrs.nextElement();\n                if (address.isLoopbackAddress()) {\n                    continue;\n                }\n                //ip4 higher priority\n                if (address instanceof Inet6Address) {\n                    candidatesHost.add(address.getHostAddress());\n                    continue;\n                }\n                return address.getHostAddress();\n            }\n        }\n\n        if (!candidatesHost.isEmpty()) {\n            return candidatesHost.get(0);\n        }\n        return null;\n    }\n",
    "focal_tgt": "    public static String getLocalhostByNetworkInterface() throws SocketException {\n        List<String> candidatesHost = new ArrayList<>();\n        Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n\n        while (enumeration.hasMoreElements()) {\n            NetworkInterface networkInterface = enumeration.nextElement();\n            // Workaround for docker0 bridge\n            if (\"docker0\".equals(networkInterface.getName()) || !networkInterface.isUp()) {\n                continue;\n            }\n            Enumeration<InetAddress> addrs = networkInterface.getInetAddresses();\n            while (addrs.hasMoreElements()) {\n                InetAddress address = addrs.nextElement();\n                if (address.isLoopbackAddress()) {\n                    continue;\n                }\n                //ip4 higher priority\n                if (address instanceof Inet6Address) {\n                    candidatesHost.add(address.getHostAddress());\n                    continue;\n                }\n                return address.getHostAddress();\n            }\n        }\n\n        if (!candidatesHost.isEmpty()) {\n            return candidatesHost.get(0);\n        }\n\n        // Fallback to loopback \n        return localhost();\n    }\n",
    "test_id": 117
  }
}