{
  "1": {
    "commit_src": "03ffc45a8b93844b692b7a834cf28b922015de3a",
    "commit_tgt": "4af193e3253a8b7e15e8447ae00d6df079599919",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImplTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageUtilTest.java",
      "test/src/test/java/org/apache/rocketmq/test/container/ContainerIntegrationTestBase.java",
      "test/src/test/java/org/apache/rocketmq/test/container/TransactionListenerImpl.java",
      "test/src/test/java/org/apache/rocketmq/test/container/TransactionMessageIT.java"
    ],
    "refer_PR": "apache_rocketmq-5062",
    "test_src": ".org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImplTest#testCheck_withDiscard",
    "test_tgt": [
      ".org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImplTest#testCheck_withDiscard"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImpl.java#check",
    "focal_src": "    @Override\n    public void check(long transactionTimeout, int transactionCheckMax,\n        AbstractTransactionalMessageCheckListener listener) {\n        try {\n            String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;\n            Set<MessageQueue> msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);\n            if (msgQueues == null || msgQueues.size() == 0) {\n                log.warn(\"The queue of topic is empty :\" + topic);\n                return;\n            }\n            log.debug(\"Check topic={}, queues={}\", topic, msgQueues);\n            for (MessageQueue messageQueue : msgQueues) {\n                long startTime = System.currentTimeMillis();\n                MessageQueue opQueue = getOpQueue(messageQueue);\n                long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);\n                long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);\n                log.info(\"Before check, the queue={} msgOffset={} opOffset={}\", messageQueue, halfOffset, opOffset);\n                if (halfOffset < 0 || opOffset < 0) {\n                    log.error(\"MessageQueue: {} illegal offset read: {}, op offset: {},skip this queue\", messageQueue,\n                        halfOffset, opOffset);\n                    continue;\n                }\n\n                List<Long> doneOpOffset = new ArrayList<>();\n                HashMap<Long, Long> removeMap = new HashMap<>();\n                PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);\n                if (null == pullResult) {\n                    log.error(\"The queue={} check msgOffset={} with opOffset={} failed, pullResult is null\",\n                        messageQueue, halfOffset, opOffset);\n                    continue;\n                }\n                // single thread\n                int getMessageNullCount = 1;\n                long newOffset = halfOffset;\n                long i = halfOffset;\n                while (true) {\n                    if (System.currentTimeMillis() - startTime > MAX_PROCESS_TIME_LIMIT) {\n                        log.info(\"Queue={} process time reach max={}\", messageQueue, MAX_PROCESS_TIME_LIMIT);\n                        break;\n                    }\n                    if (removeMap.containsKey(i)) {\n                        log.debug(\"Half offset {} has been committed/rolled back\", i);\n                        Long removedOpOffset = removeMap.remove(i);\n                        doneOpOffset.add(removedOpOffset);\n                    } else {\n                        GetResult getResult = getHalfMsg(messageQueue, i);\n                        MessageExt msgExt = getResult.getMsg();\n                        if (msgExt == null) {\n                            if (getMessageNullCount++ > MAX_RETRY_COUNT_WHEN_HALF_NULL) {\n                                break;\n                            }\n                            if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) {\n                                log.debug(\"No new msg, the miss offset={} in={}, continue check={}, pull result={}\", i,\n                                    messageQueue, getMessageNullCount, getResult.getPullResult());\n                                break;\n                            } else {\n                                log.info(\"Illegal offset, the miss offset={} in={}, continue check={}, pull result={}\",\n                                    i, messageQueue, getMessageNullCount, getResult.getPullResult());\n                                i = getResult.getPullResult().getNextBeginOffset();\n                                newOffset = i;\n                                continue;\n                            }\n                        }\n\n                        if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {\n                            listener.resolveDiscardMsg(msgExt);\n                            newOffset = i + 1;\n                            i++;\n                            continue;\n                        }\n                        if (msgExt.getStoreTimestamp() >= startTime) {\n                            log.debug(\"Fresh stored. the miss offset={}, check it later, store={}\", i,\n                                new Date(msgExt.getStoreTimestamp()));\n                            break;\n                        }\n\n                        long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();\n                        long checkImmunityTime = transactionTimeout;\n                        String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS);\n                        if (null != checkImmunityTimeStr) {\n                            checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);\n                            if (valueOfCurrentMinusBorn < checkImmunityTime) {\n                                if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) {\n                                    newOffset = i + 1;\n                                    i++;\n                                    continue;\n                                }\n                            }\n                        } else {\n                            if (0 <= valueOfCurrentMinusBorn && valueOfCurrentMinusBorn < checkImmunityTime) {\n                                log.debug(\"New arrived, the miss offset={}, check it later checkImmunity={}, born={}\", i,\n                                    checkImmunityTime, new Date(msgExt.getBornTimestamp()));\n                                break;\n                            }\n                        }\n                        List<MessageExt> opMsg = pullResult.getMsgFoundList();\n                        boolean isNeedCheck = opMsg == null && valueOfCurrentMinusBorn > checkImmunityTime\n                            || opMsg != null && opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout\n                            || valueOfCurrentMinusBorn <= -1;\n\n                        if (isNeedCheck) {\n                            if (!putBackHalfMsgQueue(msgExt, i)) {\n                                continue;\n                            }\n                            listener.resolveHalfMsg(msgExt);\n                        } else {\n                            pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);\n                            log.debug(\"The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}\", i,\n                                messageQueue, pullResult);\n                            continue;\n                        }\n                    }\n                    newOffset = i + 1;\n                    i++;\n                }\n                if (newOffset != halfOffset) {\n                    transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);\n                }\n                long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);\n                if (newOpOffset != opOffset) {\n                    transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);\n                }\n            }\n        } catch (Throwable e) {\n            log.error(\"Check error\", e);\n        }\n\n    }\n",
    "focal_tgt": "    @Override\n    public void check(long transactionTimeout, int transactionCheckMax,\n        AbstractTransactionalMessageCheckListener listener) {\n        try {\n            String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;\n            Set<MessageQueue> msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);\n            if (msgQueues == null || msgQueues.size() == 0) {\n                log.warn(\"The queue of topic is empty :\" + topic);\n                return;\n            }\n            log.debug(\"Check topic={}, queues={}\", topic, msgQueues);\n            for (MessageQueue messageQueue : msgQueues) {\n                long startTime = System.currentTimeMillis();\n                MessageQueue opQueue = getOpQueue(messageQueue);\n                long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);\n                long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);\n                log.info(\"Before check, the queue={} msgOffset={} opOffset={}\", messageQueue, halfOffset, opOffset);\n                if (halfOffset < 0 || opOffset < 0) {\n                    log.error(\"MessageQueue: {} illegal offset read: {}, op offset: {},skip this queue\", messageQueue,\n                        halfOffset, opOffset);\n                    continue;\n                }\n\n                List<Long> doneOpOffset = new ArrayList<>();\n                HashMap<Long, Long> removeMap = new HashMap<>();\n                PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);\n                if (null == pullResult) {\n                    log.error(\"The queue={} check msgOffset={} with opOffset={} failed, pullResult is null\",\n                        messageQueue, halfOffset, opOffset);\n                    continue;\n                }\n                // single thread\n                int getMessageNullCount = 1;\n                long newOffset = halfOffset;\n                long i = halfOffset;\n                int escapeFailCnt = 0;\n                while (true) {\n                    if (System.currentTimeMillis() - startTime > MAX_PROCESS_TIME_LIMIT) {\n                        log.info(\"Queue={} process time reach max={}\", messageQueue, MAX_PROCESS_TIME_LIMIT);\n                        break;\n                    }\n                    if (removeMap.containsKey(i)) {\n                        log.debug(\"Half offset {} has been committed/rolled back\", i);\n                        Long removedOpOffset = removeMap.remove(i);\n                        doneOpOffset.add(removedOpOffset);\n                    } else {\n                        GetResult getResult = getHalfMsg(messageQueue, i);\n                        MessageExt msgExt = getResult.getMsg();\n                        if (msgExt == null) {\n                            if (getMessageNullCount++ > MAX_RETRY_COUNT_WHEN_HALF_NULL) {\n                                break;\n                            }\n                            if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) {\n                                log.debug(\"No new msg, the miss offset={} in={}, continue check={}, pull result={}\", i,\n                                    messageQueue, getMessageNullCount, getResult.getPullResult());\n                                break;\n                            } else {\n                                log.info(\"Illegal offset, the miss offset={} in={}, continue check={}, pull result={}\",\n                                    i, messageQueue, getMessageNullCount, getResult.getPullResult());\n                                i = getResult.getPullResult().getNextBeginOffset();\n                                newOffset = i;\n                                continue;\n                            }\n                        }\n\n                        if (this.transactionalMessageBridge.getBrokerController().getBrokerConfig().isEnableSlaveActingMaster()\n                            && this.transactionalMessageBridge.getBrokerController().getMinBrokerIdInGroup()\n                            == this.transactionalMessageBridge.getBrokerController().getBrokerIdentity().getBrokerId()\n                            && BrokerRole.SLAVE.equals(this.transactionalMessageBridge.getBrokerController().getMessageStoreConfig().getBrokerRole())\n                        ) {\n                            final MessageExtBrokerInner msgInner = this.transactionalMessageBridge.renewHalfMessageInner(msgExt);\n                            final boolean isSuccess = this.transactionalMessageBridge.escapeMessage(msgInner);\n\n                            if (isSuccess) {\n                                escapeFailCnt = 0;\n                                newOffset = i + 1;\n                                i++;\n                            } else {\n                                log.warn(\"Escaping transactional message failed {} times! msgId(offsetId)={}, UNIQ_KEY(transactionId)={}\",\n                                    escapeFailCnt + 1,\n                                    msgExt.getMsgId(),\n                                    msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));\n                                if (escapeFailCnt < MAX_RETRY_TIMES_FOR_ESCAPE) {\n                                    escapeFailCnt++;\n                                    Thread.sleep(100L * (2 ^ escapeFailCnt));\n                                } else {\n                                    escapeFailCnt = 0;\n                                    newOffset = i + 1;\n                                    i++;\n                                }\n                            }\n                            continue;\n                        }\n\n                        if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {\n                            listener.resolveDiscardMsg(msgExt);\n                            newOffset = i + 1;\n                            i++;\n                            continue;\n                        }\n                        if (msgExt.getStoreTimestamp() >= startTime) {\n                            log.debug(\"Fresh stored. the miss offset={}, check it later, store={}\", i,\n                                new Date(msgExt.getStoreTimestamp()));\n                            break;\n                        }\n\n                        long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();\n                        long checkImmunityTime = transactionTimeout;\n                        String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS);\n                        if (null != checkImmunityTimeStr) {\n                            checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);\n                            if (valueOfCurrentMinusBorn < checkImmunityTime) {\n                                if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) {\n                                    newOffset = i + 1;\n                                    i++;\n                                    continue;\n                                }\n                            }\n                        } else {\n                            if (0 <= valueOfCurrentMinusBorn && valueOfCurrentMinusBorn < checkImmunityTime) {\n                                log.debug(\"New arrived, the miss offset={}, check it later checkImmunity={}, born={}\", i,\n                                    checkImmunityTime, new Date(msgExt.getBornTimestamp()));\n                                break;\n                            }\n                        }\n                        List<MessageExt> opMsg = pullResult.getMsgFoundList();\n                        boolean isNeedCheck = opMsg == null && valueOfCurrentMinusBorn > checkImmunityTime\n                            || opMsg != null && opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout\n                            || valueOfCurrentMinusBorn <= -1;\n\n                        if (isNeedCheck) {\n                            if (!putBackHalfMsgQueue(msgExt, i)) {\n                                continue;\n                            }\n                            listener.resolveHalfMsg(msgExt);\n                        } else {\n                            pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);\n                            log.debug(\"The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}\", i,\n                                messageQueue, pullResult);\n                            continue;\n                        }\n                    }\n                    newOffset = i + 1;\n                    i++;\n                }\n                if (newOffset != halfOffset) {\n                    transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);\n                }\n                long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);\n                if (newOpOffset != opOffset) {\n                    transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);\n                }\n            }\n        } catch (Throwable e) {\n            log.error(\"Check error\", e);\n        }\n\n    }\n",
    "test_id": 1
  },
  "2": {
    "commit_src": "a7c1d49454ce405fc651f95d036571d91bd8c9e0",
    "commit_tgt": "d54f8cb1eba99b0c83131ccbce193ad64380d0ef",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/failover/EscapeBridgeTest.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopNormally.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopBigMessageIT.java"
    ],
    "refer_PR": "apache_rocketmq-5403",
    "test_src": ".org.apache.rocketmq.broker.failover.EscapeBridgeTest#getMessageTest",
    "test_tgt": [
      ".org.apache.rocketmq.broker.failover.EscapeBridgeTest#getMessageTest"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/failover/EscapeBridge.java#getMessage",
    "focal_src": "    public MessageExt getMessage(String topic, long offset, int queueId, String brokerName) {\n        MessageStore messageStore = brokerController.getMessageStoreByBrokerName(brokerName);\n        if (messageStore != null) {\n            final GetMessageResult getMessageTmpResult = messageStore.getMessage(innerConsumerGroupName, topic, queueId, offset, 1, null);\n            if (getMessageTmpResult == null) {\n                LOG.warn(\"getMessageResult is null , innerConsumerGroupName {}, topic {}, offset {}, queueId {}\", innerConsumerGroupName, topic, offset, queueId);\n                return null;\n            }\n            List<MessageExt> list = decodeMsgList(getMessageTmpResult);\n            if (list == null || list.isEmpty()) {\n                LOG.warn(\"Can not get msg , topic {}, offset {}, queueId {}, result is {}\", topic, offset, queueId, getMessageTmpResult);\n                return null;\n            } else {\n                return list.get(0);\n            }\n        } else {\n            return getMessageFromRemote(topic, offset, queueId, brokerName);\n        }\n    }\n",
    "focal_tgt": "    public MessageExt getMessage(String topic, long offset, int queueId, String brokerName, boolean deCompressBody) {\n        MessageStore messageStore = brokerController.getMessageStoreByBrokerName(brokerName);\n        if (messageStore != null) {\n            final GetMessageResult getMessageTmpResult = messageStore.getMessage(innerConsumerGroupName, topic, queueId, offset, 1, null);\n            if (getMessageTmpResult == null) {\n                LOG.warn(\"getMessageResult is null , innerConsumerGroupName {}, topic {}, offset {}, queueId {}\", innerConsumerGroupName, topic, offset, queueId);\n                return null;\n            }\n            List<MessageExt> list = decodeMsgList(getMessageTmpResult, deCompressBody);\n            if (list == null || list.isEmpty()) {\n                LOG.warn(\"Can not get msg , topic {}, offset {}, queueId {}, result is {}\", topic, offset, queueId, getMessageTmpResult);\n                return null;\n            } else {\n                return list.get(0);\n            }\n        } else {\n            return getMessageFromRemote(topic, offset, queueId, brokerName);\n        }\n    }\n",
    "test_id": 2
  },
  "3": {
    "commit_src": "a7c1d49454ce405fc651f95d036571d91bd8c9e0",
    "commit_tgt": "d54f8cb1eba99b0c83131ccbce193ad64380d0ef",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/failover/EscapeBridgeTest.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopNormally.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopBigMessageIT.java"
    ],
    "refer_PR": "apache_rocketmq-5403",
    "test_src": ".org.apache.rocketmq.broker.failover.EscapeBridgeTest#decodeMsgListTest",
    "test_tgt": [
      ".org.apache.rocketmq.broker.failover.EscapeBridgeTest#decodeMsgListTest"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/failover/EscapeBridge.java#decodeMsgList",
    "focal_src": "    protected List<MessageExt> decodeMsgList(GetMessageResult getMessageResult) {\n        List<MessageExt> foundList = new ArrayList<>();\n        try {\n            List<ByteBuffer> messageBufferList = getMessageResult.getMessageBufferList();\n            if (messageBufferList != null) {\n                for (int i = 0; i < messageBufferList.size(); i++) {\n                    ByteBuffer bb = messageBufferList.get(i);\n                    if (bb == null) {\n                        LOG.error(\"bb is null {}\", getMessageResult);\n                        continue;\n                    }\n                    MessageExt msgExt = MessageDecoder.decode(bb);\n                    if (msgExt == null) {\n                        LOG.error(\"decode msgExt is null {}\", getMessageResult);\n                        continue;\n                    }\n                    // use CQ offset, not offset in Message\n                    msgExt.setQueueOffset(getMessageResult.getMessageQueueOffset().get(i));\n                    foundList.add(msgExt);\n                }\n            }\n        } finally {\n            getMessageResult.release();\n        }\n\n        return foundList;\n    }\n",
    "focal_tgt": "    protected List<MessageExt> decodeMsgList(GetMessageResult getMessageResult, boolean deCompressBody) {\n        List<MessageExt> foundList = new ArrayList<>();\n        try {\n            List<ByteBuffer> messageBufferList = getMessageResult.getMessageBufferList();\n            if (messageBufferList != null) {\n                for (int i = 0; i < messageBufferList.size(); i++) {\n                    ByteBuffer bb = messageBufferList.get(i);\n                    if (bb == null) {\n                        LOG.error(\"bb is null {}\", getMessageResult);\n                        continue;\n                    }\n                    MessageExt msgExt = MessageDecoder.decode(bb, true, deCompressBody);\n                    if (msgExt == null) {\n                        LOG.error(\"decode msgExt is null {}\", getMessageResult);\n                        continue;\n                    }\n                    // use CQ offset, not offset in Message\n                    msgExt.setQueueOffset(getMessageResult.getMessageQueueOffset().get(i));\n                    foundList.add(msgExt);\n                }\n            }\n        } finally {\n            getMessageResult.release();\n        }\n\n        return foundList;\n    }\n",
    "test_id": 3
  },
  "4": {
    "commit_src": "48ed8980719c14fde8ce145e5d585c6c0852920f",
    "commit_tgt": "407d2738f2d8b20a8ea264c75dbfc876ecb8519e",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/NetworkUtilTest.java"
    ],
    "refer_PR": "apache_rocketmq-5513",
    "test_src": ".org.apache.rocketmq.common.NetworkUtilTest#testGetLocalAddress",
    "test_tgt": [
      ".org.apache.rocketmq.common.NetworkUtilTest#testGetLocalAddress"
    ],
    "focal_path": "common/src/main/java/org/apache/rocketmq/common/utils/NetworkUtil.java#getLocalAddress",
    "focal_src": "    public static String getLocalAddress() {\n        try {\n            // Traversal Network interface to get the first non-loopback and non-private address\n            Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n            ArrayList<String> ipv4Result = new ArrayList<>();\n            ArrayList<String> ipv6Result = new ArrayList<>();\n            while (enumeration.hasMoreElements()) {\n                final NetworkInterface networkInterface = enumeration.nextElement();\n                if (isBridge(networkInterface)) {\n                    continue;\n                }\n\n                final Enumeration<InetAddress> en = networkInterface.getInetAddresses();\n                while (en.hasMoreElements()) {\n                    final InetAddress address = en.nextElement();\n                    if (!address.isLoopbackAddress()) {\n                        if (address instanceof Inet6Address) {\n                            ipv6Result.add(normalizeHostAddress(address));\n                        } else {\n                            ipv4Result.add(normalizeHostAddress(address));\n                        }\n                    }\n                }\n            }\n\n            // prefer ipv4\n            if (!ipv4Result.isEmpty()) {\n                for (String ip : ipv4Result) {\n                    if (ip.startsWith(\"127.0\") || ip.startsWith(\"192.168\")) {\n                        continue;\n                    }\n\n                    return ip;\n                }\n\n                return ipv4Result.get(ipv4Result.size() - 1);\n            } else if (!ipv6Result.isEmpty()) {\n                return ipv6Result.get(0);\n            }\n            //If failed to find,fall back to localhost\n            final InetAddress localHost = InetAddress.getLocalHost();\n            return normalizeHostAddress(localHost);\n        } catch (Exception e) {\n            log.error(\"Failed to obtain local address\", e);\n        }\n\n        return null;\n    }\n",
    "focal_tgt": "    public static String getLocalAddress() {\n        try {\n            // Traversal Network interface to get the first non-loopback and non-private address\n            Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n            ArrayList<String> ipv4Result = new ArrayList<>();\n            ArrayList<String> ipv6Result = new ArrayList<>();\n            while (enumeration.hasMoreElements()) {\n                final NetworkInterface nif = enumeration.nextElement();\n                if (isBridge(nif) || nif.isVirtual() || nif.isPointToPoint() || !nif.isUp()) {\n                    continue;\n                }\n\n                final Enumeration<InetAddress> en = nif.getInetAddresses();\n                while (en.hasMoreElements()) {\n                    final InetAddress address = en.nextElement();\n                    if (!address.isLoopbackAddress()) {\n                        if (address instanceof Inet6Address) {\n                            ipv6Result.add(normalizeHostAddress(address));\n                        } else {\n                            ipv4Result.add(normalizeHostAddress(address));\n                        }\n                    }\n                }\n            }\n\n            // prefer ipv4\n            if (!ipv4Result.isEmpty()) {\n                for (String ip : ipv4Result) {\n                    if (ip.startsWith(\"127.0\") || ip.startsWith(\"192.168\")) {\n                        continue;\n                    }\n\n                    return ip;\n                }\n\n                return ipv4Result.get(ipv4Result.size() - 1);\n            } else if (!ipv6Result.isEmpty()) {\n                return ipv6Result.get(0);\n            }\n            //If failed to find,fall back to localhost\n            final InetAddress localHost = InetAddress.getLocalHost();\n            return normalizeHostAddress(localHost);\n        } catch (Exception e) {\n            log.error(\"Failed to obtain local address\", e);\n        }\n\n        return null;\n    }\n",
    "test_id": 4
  },
  "5": {
    "commit_src": "44072e62bdba8ef1111808046f06c081c766d4ae",
    "commit_tgt": "da5a5b62927d041ad858bc4dd973e1bf68abcb1b",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/RegisterBrokerBodyTest.java"
    ],
    "refer_PR": "apache_rocketmq-5539",
    "test_src": ".org.apache.rocketmq.remoting.protocol.RegisterBrokerBodyTest#test_encode_decode",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.protocol.RegisterBrokerBodyTest#test_encode_decode"
    ],
    "focal_path": "remoting/src/main/java/org/apache/rocketmq/remoting/protocol/body/RegisterBrokerBody.java#decode",
    "focal_src": "    public static RegisterBrokerBody decode(byte[] data, boolean compressed) throws IOException {\n        if (!compressed) {\n            return RegisterBrokerBody.decode(data, RegisterBrokerBody.class);\n        }\n        long start = System.currentTimeMillis();\n        InflaterInputStream inflaterInputStream = new InflaterInputStream(new ByteArrayInputStream(data));\n        int dataVersionLength = readInt(inflaterInputStream);\n        byte[] dataVersionBytes = readBytes(inflaterInputStream, dataVersionLength);\n        DataVersion dataVersion = DataVersion.decode(dataVersionBytes, DataVersion.class);\n\n        RegisterBrokerBody registerBrokerBody = new RegisterBrokerBody();\n        registerBrokerBody.getTopicConfigSerializeWrapper().setDataVersion(dataVersion);\n        ConcurrentMap<String, TopicConfig> topicConfigTable = registerBrokerBody.getTopicConfigSerializeWrapper().getTopicConfigTable();\n\n        int topicConfigNumber = readInt(inflaterInputStream);\n        LOGGER.debug(\"{} topic configs to extract\", topicConfigNumber);\n\n        for (int i = 0; i < topicConfigNumber; i++) {\n            int topicConfigJsonLength = readInt(inflaterInputStream);\n\n            byte[] buffer = readBytes(inflaterInputStream, topicConfigJsonLength);\n            TopicConfig topicConfig = new TopicConfig();\n            String topicConfigJson = new String(buffer, MixAll.DEFAULT_CHARSET);\n            topicConfig.decode(topicConfigJson);\n            topicConfigTable.put(topicConfig.getTopicName(), topicConfig);\n        }\n\n        int filterServerListJsonLength = readInt(inflaterInputStream);\n\n        byte[] filterServerListBuffer = readBytes(inflaterInputStream, filterServerListJsonLength);\n        String filterServerListJson = new String(filterServerListBuffer, MixAll.DEFAULT_CHARSET);\n        List<String> filterServerList = new ArrayList<>();\n        try {\n            filterServerList = JSON.parseArray(filterServerListJson, String.class);\n        } catch (Exception e) {\n            LOGGER.error(\"Decompressing occur Exception {}\", filterServerListJson);\n        }\n\n        registerBrokerBody.setFilterServerList(filterServerList);\n\n        int topicQueueMappingNum =  readInt(inflaterInputStream);\n        Map<String/* topic */, TopicQueueMappingInfo> topicQueueMappingInfoMap = new ConcurrentHashMap<>();\n        for (int i = 0; i < topicQueueMappingNum; i++) {\n            int mappingJsonLen = readInt(inflaterInputStream);\n            byte[] buffer = readBytes(inflaterInputStream, mappingJsonLen);\n            TopicQueueMappingInfo info = TopicQueueMappingInfo.decode(buffer, TopicQueueMappingInfo.class);\n            topicQueueMappingInfoMap.put(info.getTopic(), info);\n        }\n        registerBrokerBody.getTopicConfigSerializeWrapper().setTopicQueueMappingInfoMap(topicQueueMappingInfoMap);\n\n        long interval = System.currentTimeMillis() - start;\n        if (interval > 50) {\n            LOGGER.info(\"Decompressing takes {}ms\", interval);\n        }\n        return registerBrokerBody;\n    }\n",
    "focal_tgt": "    public static RegisterBrokerBody decode(byte[] data, boolean compressed, MQVersion.Version brokerVersion) throws IOException {\n        if (!compressed) {\n            return RegisterBrokerBody.decode(data, RegisterBrokerBody.class);\n        }\n        long start = System.currentTimeMillis();\n        InflaterInputStream inflaterInputStream = new InflaterInputStream(new ByteArrayInputStream(data));\n        int dataVersionLength = readInt(inflaterInputStream);\n        byte[] dataVersionBytes = readBytes(inflaterInputStream, dataVersionLength);\n        DataVersion dataVersion = DataVersion.decode(dataVersionBytes, DataVersion.class);\n\n        RegisterBrokerBody registerBrokerBody = new RegisterBrokerBody();\n        registerBrokerBody.getTopicConfigSerializeWrapper().setDataVersion(dataVersion);\n        ConcurrentMap<String, TopicConfig> topicConfigTable = registerBrokerBody.getTopicConfigSerializeWrapper().getTopicConfigTable();\n\n        int topicConfigNumber = readInt(inflaterInputStream);\n        LOGGER.debug(\"{} topic configs to extract\", topicConfigNumber);\n\n        for (int i = 0; i < topicConfigNumber; i++) {\n            int topicConfigJsonLength = readInt(inflaterInputStream);\n\n            byte[] buffer = readBytes(inflaterInputStream, topicConfigJsonLength);\n            TopicConfig topicConfig = new TopicConfig();\n            String topicConfigJson = new String(buffer, MixAll.DEFAULT_CHARSET);\n            topicConfig.decode(topicConfigJson);\n            topicConfigTable.put(topicConfig.getTopicName(), topicConfig);\n        }\n\n        int filterServerListJsonLength = readInt(inflaterInputStream);\n\n        byte[] filterServerListBuffer = readBytes(inflaterInputStream, filterServerListJsonLength);\n        String filterServerListJson = new String(filterServerListBuffer, MixAll.DEFAULT_CHARSET);\n        List<String> filterServerList = new ArrayList<>();\n        try {\n            filterServerList = JSON.parseArray(filterServerListJson, String.class);\n        } catch (Exception e) {\n            LOGGER.error(\"Decompressing occur Exception {}\", filterServerListJson);\n        }\n\n        registerBrokerBody.setFilterServerList(filterServerList);\n\n        if (brokerVersion.ordinal() >= MQVersion.Version.V5_0_0.ordinal()) {\n            int topicQueueMappingNum = readInt(inflaterInputStream);\n            Map<String/* topic */, TopicQueueMappingInfo> topicQueueMappingInfoMap = new ConcurrentHashMap<>();\n            for (int i = 0; i < topicQueueMappingNum; i++) {\n                int mappingJsonLen = readInt(inflaterInputStream);\n                byte[] buffer = readBytes(inflaterInputStream, mappingJsonLen);\n                TopicQueueMappingInfo info = TopicQueueMappingInfo.decode(buffer, TopicQueueMappingInfo.class);\n                topicQueueMappingInfoMap.put(info.getTopic(), info);\n            }\n            registerBrokerBody.getTopicConfigSerializeWrapper().setTopicQueueMappingInfoMap(topicQueueMappingInfoMap);\n        }\n\n        long interval = System.currentTimeMillis() - start;\n        if (interval > 50) {\n            LOGGER.info(\"Decompressing takes {}ms\", interval);\n        }\n        return registerBrokerBody;\n    }\n",
    "test_id": 5
  },
  "6": {
    "commit_src": "59acc7d3554d61f046233fc00308b07b7a7b39fb",
    "commit_tgt": "e5fadc7db7c4a5c098e5f912a19fd71cba3dde3d",
    "changed_tests": [
      "client/src/test/java/org/apache/rocketmq/client/consumer/DefaultLitePullConsumerTest.java"
    ],
    "refer_PR": "apache_rocketmq-5640",
    "test_src": ".org.apache.rocketmq.client.consumer.DefaultLitePullConsumerTest#testConsumerCommitSyncWithMQOffset",
    "test_tgt": [
      ".org.apache.rocketmq.client.consumer.DefaultLitePullConsumerTest#testConsumerCommitSyncWithMQOffset"
    ],
    "focal_path": "client/src/main/java/org/apache/rocketmq/client/consumer/DefaultLitePullConsumer.java#commitSync",
    "focal_src": "    @Override\n    public void commitSync() {\n        this.defaultLitePullConsumerImpl.commitAll();\n    }\n",
    "focal_tgt": "    @Deprecated\n    @Override\n    public void commitSync() {\n        this.defaultLitePullConsumerImpl.commitAll();\n    }\n",
    "test_id": 6
  },
  "7": {
    "commit_src": "0533816d42961d0ba0ea012a115261ea71dd30c4",
    "commit_tgt": "5894332918e7158d6ff4cc35b126a1b82a1f6b0c",
    "changed_tests": [
      "tools/src/test/java/org/apache/rocketmq/tools/command/broker/BrokerStatusSubCommandTest.java"
    ],
    "refer_PR": "apache_rocketmq-5818",
    "test_src": ".org.apache.rocketmq.tools.command.broker.BrokerStatusSubCommandTest#testExecute",
    "test_tgt": [
      ".org.apache.rocketmq.tools.command.broker.BrokerStatusSubCommandTest#testExecute"
    ],
    "focal_path": "tools/src/main/java/org/apache/rocketmq/tools/command/broker/BrokerStatusSubCommand.java#buildCommandlineOptions",
    "focal_src": "    @Override\n    public Options buildCommandlineOptions(Options options) {\n        Option opt = new Option(\"b\", \"brokerAddr\", true, \"Broker address\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"c\", \"clusterName\", true, \"which cluster\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        return options;\n    }\n",
    "focal_tgt": "    @Override\n    public Options buildCommandlineOptions(Options options) {\n        OptionGroup optionGroup = new OptionGroup();\n        Option opt = new Option(\"b\", \"brokerAddr\", true, \"Broker address\");\n        optionGroup.addOption(opt);\n\n        opt = new Option(\"c\", \"clusterName\", true, \"which cluster\");\n        optionGroup.addOption(opt);\n\n        optionGroup.setRequired(true);\n        options.addOptionGroup(optionGroup);\n\n        return options;\n    }\n",
    "test_id": 7
  },
  "8": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_TopicNotExist",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_TopicNotExist",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest",
    "focal_src": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "focal_tgt": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "test_id": 8
  },
  "9": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_Found",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_Found",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest",
    "focal_src": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "focal_tgt": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "test_id": 9
  },
  "10": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_MsgWasRemoving",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_MsgWasRemoving",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest",
    "focal_src": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "focal_tgt": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "test_id": 10
  },
  "11": {
    "commit_src": "61c4ba5009a9fe1fa2d68135e2349e85d556db3a",
    "commit_tgt": "9e0fb1b0293aebbe5019e55c0fdbd356611b3d16",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopMessageProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6184",
    "test_src": ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_NoMsgInQueue",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_NoMsgInQueue",
      ".org.apache.rocketmq.broker.processor.PopMessageProcessorTest#testProcessRequest_whenTimerWheelIsFalse"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopMessageProcessor.java#processRequest",
    "focal_src": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] poping message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] poping message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] poping message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "focal_tgt": "    private RemotingCommand processRequest(final Channel channel, RemotingCommand request)\n        throws RemotingCommandException {\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PopMessageRequestHeader requestHeader =\n            (PopMessageRequestHeader) request.decodeCommandCustomHeader(PopMessageRequestHeader.class);\n        StringBuilder startOffsetInfo = new StringBuilder(64);\n        StringBuilder msgOffsetInfo = new StringBuilder(64);\n        StringBuilder orderCountInfo = null;\n        if (requestHeader.isOrder()) {\n            orderCountInfo = new StringBuilder(64);\n        }\n\n        brokerController.getConsumerManager().compensateBasicConsumerInfo(requestHeader.getConsumerGroup(),\n            ConsumeType.CONSUME_POP, MessageModel.CLUSTERING);\n\n        response.setOpaque(request.getOpaque());\n\n        if (brokerController.getBrokerConfig().isEnablePopLog()) {\n            POP_LOGGER.info(\"receive PopMessage request command, {}\", request);\n        }\n\n        if (requestHeader.isTimeoutTooMuch()) {\n            response.setCode(ResponseCode.POLLING_TIMEOUT);\n            response.setRemark(String.format(\"the broker[%s] pop message is timeout too much\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n        if (requestHeader.getMaxMsgNums() > 32) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message's num is greater than 32\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        if (!brokerController.getMessageStore().getMessageStoreConfig().isTimerWheelEnable()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(String.format(\"the broker[%s] pop message is forbidden because timerWheelEnable is false\",\n                this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            POP_LOGGER.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(),\n                RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(),\n                FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] \" +\n                    \"consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(),\n                channel.remoteAddress());\n            POP_LOGGER.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig =\n            this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\",\n                requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n\n        ExpressionMessageFilter messageFilter = null;\n        if (requestHeader.getExp() != null && requestHeader.getExp().length() > 0) {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), requestHeader.getExp(), requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, SubscriptionData.SUB_ALL, requestHeader.getExpType());\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n\n                ConsumerFilterData consumerFilterData = null;\n                if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) {\n                    consumerFilterData = ConsumerFilterManager.build(\n                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getExp(),\n                        requestHeader.getExpType(), System.currentTimeMillis()\n                    );\n                    if (consumerFilterData == null) {\n                        POP_LOGGER.warn(\"Parse the consumer's subscription[{}] failed, group: {}\",\n                            requestHeader.getExp(), requestHeader.getConsumerGroup());\n                        response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                        response.setRemark(\"parse the consumer's subscription failed\");\n                        return response;\n                    }\n                }\n                messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,\n                    brokerController.getConsumerFilterManager());\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Parse the consumer's subscription[{}] error, group: {}\", requestHeader.getExp(),\n                    requestHeader.getConsumerGroup());\n                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n                response.setRemark(\"parse the consumer's subscription failed\");\n                return response;\n            }\n        } else {\n            try {\n                SubscriptionData subscriptionData = FilterAPI.build(requestHeader.getTopic(), \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    requestHeader.getTopic(), subscriptionData);\n\n                String retryTopic = KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup());\n                SubscriptionData retrySubscriptionData = FilterAPI.build(retryTopic, \"*\", ExpressionType.TAG);\n                brokerController.getConsumerManager().compensateSubscribeData(requestHeader.getConsumerGroup(),\n                    retryTopic, retrySubscriptionData);\n            } catch (Exception e) {\n                POP_LOGGER.warn(\"Build default subscription error, group: {}\", requestHeader.getConsumerGroup());\n            }\n        }\n\n        int randomQ = random.nextInt(100);\n        int reviveQid;\n        if (requestHeader.isOrder()) {\n            reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE;\n        } else {\n            reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum());\n        }\n\n        int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg();\n        GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg);\n        ExpressionMessageFilter finalMessageFilter = messageFilter;\n        StringBuilder finalOrderCountInfo = orderCountInfo;\n\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        CompletableFuture<Long> getMessageFuture = CompletableFuture.completedFuture(0L);\n        if (needRetry && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                    startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) {\n            TopicConfig retryTopicConfig =\n                this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    getMessageFuture = getMessageFuture.thenCompose(restNum -> popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, finalMessageFilter,\n                        startOffsetInfo, msgOffsetInfo, finalOrderCountInfo));\n                }\n            }\n        }\n\n        final RemotingCommand finalResponse = response;\n        getMessageFuture.thenApply(restNum -> {\n            if (!getMessageResult.getMessageBufferList().isEmpty()) {\n                finalResponse.setCode(ResponseCode.SUCCESS);\n                getMessageResult.setStatus(GetMessageStatus.FOUND);\n                if (restNum > 0) {\n                    // all queue pop can not notify specified queue pop, and vice versa\n                    notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(),\n                        requestHeader.getQueueId());\n                }\n            } else {\n                int pollingResult = polling(channel, request, requestHeader);\n                if (POLLING_SUC == pollingResult) {\n                    return null;\n                } else if (POLLING_FULL == pollingResult) {\n                    finalResponse.setCode(ResponseCode.POLLING_FULL);\n                } else {\n                    finalResponse.setCode(ResponseCode.POLLING_TIMEOUT);\n                }\n                getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n            }\n            responseHeader.setInvisibleTime(requestHeader.getInvisibleTime());\n            responseHeader.setPopTime(popTime);\n            responseHeader.setReviveQid(reviveQid);\n            responseHeader.setRestNum(restNum);\n            responseHeader.setStartOffsetInfo(startOffsetInfo.toString());\n            responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString());\n            if (requestHeader.isOrder() && finalOrderCountInfo != null) {\n                responseHeader.setOrderCountInfo(finalOrderCountInfo.toString());\n            }\n            finalResponse.setRemark(getMessageResult.getStatus().name());\n            switch (finalResponse.getCode()) {\n                case ResponseCode.SUCCESS:\n                    if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                        final long beginTimeMills = this.brokerController.getMessageStore().now();\n                        final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId());\n                        this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                            requestHeader.getTopic(), requestHeader.getQueueId(),\n                            (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                        finalResponse.setBody(r);\n                    } else {\n                        final GetMessageResult tmpGetMessageResult = getMessageResult;\n                        try {\n                            FileRegion fileRegion =\n                                new ManyMessageTransfer(finalResponse.encodeHeader(getMessageResult.getBufferTotalSize()),\n                                    getMessageResult);\n                            channel.writeAndFlush(fileRegion)\n                                .addListener((ChannelFutureListener) future -> {\n                                    tmpGetMessageResult.release();\n                                    Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                        .put(LABEL_REQUEST_CODE, RemotingMetricsManager.getRequestCodeDesc(request.getCode()))\n                                        .put(LABEL_RESPONSE_CODE, RemotingMetricsManager.getResponseCodeDesc(finalResponse.getCode()))\n                                        .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                        .build();\n                                    RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                    if (!future.isSuccess()) {\n                                        POP_LOGGER.error(\"Fail to transfer messages from page cache to {}\",\n                                            channel.remoteAddress(), future.cause());\n                                    }\n                                });\n                        } catch (Throwable e) {\n                            POP_LOGGER.error(\"Error occurred when transferring messages from page cache\", e);\n                            getMessageResult.release();\n                        }\n\n                        return null;\n                    }\n                    break;\n                default:\n                    return finalResponse;\n            }\n            return finalResponse;\n        }).thenAccept(result -> NettyRemotingAbstract.writeResponse(channel, request, result));\n        return null;\n    }\n",
    "test_id": 11
  },
  "12": {
    "commit_src": "b00c82caccea8d8a23614c1854885d0a187e159e",
    "commit_tgt": "dcf7ccdd9ba92c22a44cde4c1df36c4d1ef6a172",
    "changed_tests": [
      "tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java"
    ],
    "refer_PR": "apache_rocketmq-6651",
    "test_src": ".org.apache.rocketmq.tieredstore.TieredMessageStoreTest#testGetMessageAsync",
    "test_tgt": [
      ".org.apache.rocketmq.tieredstore.TieredMessageStoreTest#testGetMessageAsync"
    ],
    "focal_path": "tieredstore/src/main/java/org/apache/rocketmq/tieredstore/TieredMessageStore.java#getMessageAsync",
    "focal_src": "    @Override\n    public CompletableFuture<GetMessageResult> getMessageAsync(String group, String topic,\n        int queueId, long offset, int maxMsgNums, MessageFilter messageFilter) {\n        if (viaTieredStorage(topic, queueId, offset, maxMsgNums)) {\n            Stopwatch stopwatch = Stopwatch.createStarted();\n            return fetcher.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter)\n                .thenApply(result -> {\n                    Attributes latencyAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                        .put(TieredStoreMetricsConstant.LABEL_OPERATION, TieredStoreMetricsConstant.OPERATION_API_GET_MESSAGE)\n                        .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                        .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                        .build();\n                    TieredStoreMetricsManager.apiLatency.record(stopwatch.elapsed(TimeUnit.MILLISECONDS), latencyAttributes);\n\n                    if (result.getStatus() == GetMessageStatus.OFFSET_FOUND_NULL ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_ONE ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        if (next.checkInDiskByConsumeOffset(topic, queueId, offset)) {\n                            logger.debug(\"TieredMessageStore#getMessageAsync: not found message, try to get message from next store: topic: {}, queue: {}, queue offset: {}, tiered store result: {}, min offset: {}, max offset: {}\",\n                                topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                            TieredStoreMetricsManager.fallbackTotal.add(1, latencyAttributes);\n                            return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                        }\n                    }\n                    if (result.getStatus() != GetMessageStatus.FOUND &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_ONE &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        logger.warn(\"TieredMessageStore#getMessageAsync: not found message, and message is not in next store: topic: {}, queue: {}, queue offset: {}, result: {}, min offset: {}, max offset: {}\",\n                            topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                    }\n                    if (result.getStatus() == GetMessageStatus.FOUND) {\n                        Attributes messagesOutAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                            .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                            .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                            .build();\n                        TieredStoreMetricsManager.messagesOutTotal.add(result.getMessageCount(), messagesOutAttributes);\n                    }\n\n                    // fix min or max offset using next store\n                    long minOffsetInQueue = next.getMinOffsetInQueue(topic, queueId);\n                    if (minOffsetInQueue >= 0 && minOffsetInQueue < result.getMinOffset()) {\n                        result.setMinOffset(minOffsetInQueue);\n                    }\n                    long maxOffsetInQueue = next.getMaxOffsetInQueue(topic, queueId);\n                    if (maxOffsetInQueue >= 0 && maxOffsetInQueue > result.getMaxOffset()) {\n                        result.setMaxOffset(maxOffsetInQueue);\n                    }\n                    return result;\n                }).exceptionally(e -> {\n                    logger.error(\"TieredMessageStore#getMessageAsync: get message from tiered store failed: \", e);\n                    return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                });\n        }\n        return next.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter);\n    }\n",
    "focal_tgt": "    @Override\n    public CompletableFuture<GetMessageResult> getMessageAsync(String group, String topic,\n        int queueId, long offset, int maxMsgNums, MessageFilter messageFilter) {\n        if (viaTieredStorage(topic, queueId, offset, maxMsgNums)) {\n            Stopwatch stopwatch = Stopwatch.createStarted();\n            return fetcher.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter)\n                .thenApply(result -> {\n                    Attributes latencyAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                        .put(TieredStoreMetricsConstant.LABEL_OPERATION, TieredStoreMetricsConstant.OPERATION_API_GET_MESSAGE)\n                        .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                        .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                        .build();\n                    TieredStoreMetricsManager.apiLatency.record(stopwatch.elapsed(TimeUnit.MILLISECONDS), latencyAttributes);\n\n                    if (result.getStatus() == GetMessageStatus.OFFSET_FOUND_NULL ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_ONE ||\n                        result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        if (next.checkInStoreByConsumeOffset(topic, queueId, offset)) {\n                            logger.debug(\"TieredMessageStore#getMessageAsync: not found message, try to get message from next store: topic: {}, queue: {}, queue offset: {}, tiered store result: {}, min offset: {}, max offset: {}\",\n                                topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                            TieredStoreMetricsManager.fallbackTotal.add(1, latencyAttributes);\n                            return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                        }\n                    }\n                    if (result.getStatus() != GetMessageStatus.FOUND &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_ONE &&\n                        result.getStatus() != GetMessageStatus.OFFSET_OVERFLOW_BADLY) {\n                        logger.warn(\"TieredMessageStore#getMessageAsync: not found message, and message is not in next store: topic: {}, queue: {}, queue offset: {}, result: {}, min offset: {}, max offset: {}\",\n                            topic, queueId, offset, result.getStatus(), result.getMinOffset(), result.getMaxOffset());\n                    }\n                    if (result.getStatus() == GetMessageStatus.FOUND) {\n                        Attributes messagesOutAttributes = TieredStoreMetricsManager.newAttributesBuilder()\n                            .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                            .put(TieredStoreMetricsConstant.LABEL_GROUP, group)\n                            .build();\n                        TieredStoreMetricsManager.messagesOutTotal.add(result.getMessageCount(), messagesOutAttributes);\n                    }\n\n                    // fix min or max offset using next store\n                    long minOffsetInQueue = next.getMinOffsetInQueue(topic, queueId);\n                    if (minOffsetInQueue >= 0 && minOffsetInQueue < result.getMinOffset()) {\n                        result.setMinOffset(minOffsetInQueue);\n                    }\n                    long maxOffsetInQueue = next.getMaxOffsetInQueue(topic, queueId);\n                    if (maxOffsetInQueue >= 0 && maxOffsetInQueue > result.getMaxOffset()) {\n                        result.setMaxOffset(maxOffsetInQueue);\n                    }\n                    return result;\n                }).exceptionally(e -> {\n                    logger.error(\"TieredMessageStore#getMessageAsync: get message from tiered store failed: \", e);\n                    return next.getMessage(group, topic, queueId, offset, maxMsgNums, messageFilter);\n                });\n        }\n        return next.getMessageAsync(group, topic, queueId, offset, maxMsgNums, messageFilter);\n    }\n",
    "test_id": 12
  },
  "13": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenNoAck",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenNoAck"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 13
  },
  "14": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenAck",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeMessageThenAck"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 14
  },
  "15": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleLonger",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleLonger"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 15
  },
  "16": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleShorter",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testConsumeTheChangeInvisibleShorter"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 16
  },
  "17": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testRecover",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerLockFreeNotifyTest#testRecover"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 17
  },
  "18": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testCommitAndNext",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testCommitAndNext",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 18
  },
  "19": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testCommitAndNext",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testCommitAndNext",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#checkBlock",
    "focal_src": "    public boolean checkBlock(String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(invisibleTime);\n    }\n",
    "focal_tgt": "    public boolean checkBlock(String attemptId, String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(attemptId, invisibleTime);\n    }\n",
    "test_id": 19
  },
  "20": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCount",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCount",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 20
  },
  "21": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCountForMultiQueue",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testConsumedCountForMultiQueue",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 21
  },
  "22": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testUpdateNextVisibleTime",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testUpdateNextVisibleTime",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 22
  },
  "23": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testAutoCleanAndEncode",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testAutoCleanAndEncode",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 23
  },
  "24": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testLoadFromOldVersionOrderInfoData",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testLoadFromOldVersionOrderInfoData",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#update",
    "focal_src": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "focal_tgt": "    /**\n     * update the message list received\n     *\n     * @param isRetry is retry topic or not\n     * @param topic topic\n     * @param group group\n     * @param queueId queue id of message\n     * @param popTime the time of pop message\n     * @param invisibleTime invisible time\n     * @param msgQueueOffsetList the queue offsets of messages\n     * @param orderInfoBuilder will append order info to this builder\n     */\n    public void update(String attemptId, boolean isRetry, String topic, String group, int queueId, long popTime, long invisibleTime,\n        List<Long> msgQueueOffsetList, StringBuilder orderInfoBuilder) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo != null) {\n            OrderInfo newOrderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n            newOrderInfo.mergeOffsetConsumedCount(orderInfo.attemptId, orderInfo.offsetList, orderInfo.offsetConsumedCount);\n\n            orderInfo = newOrderInfo;\n        } else {\n            orderInfo = new OrderInfo(attemptId, popTime, invisibleTime, msgQueueOffsetList, System.currentTimeMillis(), 0);\n        }\n        qs.put(queueId, orderInfo);\n\n        Map<Long, Integer> offsetConsumedCount = orderInfo.offsetConsumedCount;\n        int minConsumedTimes = Integer.MAX_VALUE;\n        if (offsetConsumedCount != null) {\n            Set<Long> offsetSet = offsetConsumedCount.keySet();\n            for (Long offset : offsetSet) {\n                Integer consumedTimes = offsetConsumedCount.getOrDefault(offset, 0);\n                ExtraInfoUtil.buildQueueOffsetOrderCountInfo(orderInfoBuilder, isRetry, queueId, offset, consumedTimes);\n                minConsumedTimes = Math.min(minConsumedTimes, consumedTimes);\n            }\n\n            if (offsetConsumedCount.size() != orderInfo.offsetList.size()) {\n                // offsetConsumedCount only save messages which consumed count is greater than 0\n                // if size not equal, means there are some new messages\n                minConsumedTimes = 0;\n            }\n        } else {\n            minConsumedTimes = 0;\n        }\n\n        // for compatibility\n        // the old pop sdk use queueId to get consumedTimes from orderCountInfo\n        ExtraInfoUtil.buildQueueIdOrderCountInfo(orderInfoBuilder, isRetry, queueId, minConsumedTimes);\n        updateLockFreeTimestamp(topic, group, queueId, orderInfo);\n    }\n",
    "test_id": 24
  },
  "25": {
    "commit_src": "6f6032e9eb812d42a67bea3cdb02cf4ef6e7f6c3",
    "commit_tgt": "57642bc630d5ee42cca026ae389ae3016a61bb9c",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerLockFreeNotifyTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java",
      "test/src/main/java/org/apache/rocketmq/test/client/rmq/RMQPopClient.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/BasePopOrderly.java",
      "test/src/test/java/org/apache/rocketmq/test/client/consumer/pop/PopOrderlyIT.java",
      "test/src/test/java/org/apache/rocketmq/test/offset/OffsetResetForPopIT.java"
    ],
    "refer_PR": "apache_rocketmq-6692",
    "test_src": ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testLoadFromOldVersionOrderInfoData",
    "test_tgt": [
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testLoadFromOldVersionOrderInfoData",
      ".org.apache.rocketmq.broker.offset.ConsumerOrderInfoManagerTest#testReentrant"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java#checkBlock",
    "focal_src": "    public boolean checkBlock(String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(invisibleTime);\n    }\n",
    "focal_tgt": "    public boolean checkBlock(String attemptId, String topic, String group, int queueId, long invisibleTime) {\n        String key = buildKey(topic, group);\n        ConcurrentHashMap<Integer/*queueId*/, OrderInfo> qs = table.get(key);\n        if (qs == null) {\n            qs = new ConcurrentHashMap<>(16);\n            ConcurrentHashMap<Integer/*queueId*/, OrderInfo> old = table.putIfAbsent(key, qs);\n            if (old != null) {\n                qs = old;\n            }\n        }\n\n        OrderInfo orderInfo = qs.get(queueId);\n\n        if (orderInfo == null) {\n            return false;\n        }\n        return orderInfo.needBlock(attemptId, invisibleTime);\n    }\n",
    "test_id": 25
  },
  "26": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresent",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresent"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent",
    "focal_src": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "focal_tgt": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "test_id": 26
  },
  "27": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresentReturnNull",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testGetWhenComputeIfPresentReturnNull"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent",
    "focal_src": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "focal_tgt": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "test_id": 27
  },
  "28": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresent",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresent"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent",
    "focal_src": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "focal_tgt": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "test_id": 28
  },
  "29": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresentReturnNull",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveWhenComputeIfPresentReturnNull"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#computeIfPresent",
    "focal_src": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "focal_tgt": "    public void computeIfPresent(String msgID, String handle,\n        Function<MessageReceiptHandle, CompletableFuture<MessageReceiptHandle>> function) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to compute failed\");\n            }\n            CompletableFuture<MessageReceiptHandle> future = function.apply(handleData.messageReceiptHandle);\n            future.whenComplete((messageReceiptHandle, throwable) -> {\n                try {\n                    if (throwable != null) {\n                        return;\n                    }\n                    if (messageReceiptHandle == null) {\n                        handleData.needRemove = true;\n                    } else {\n                        handleData.messageReceiptHandle = messageReceiptHandle;\n                    }\n                } finally {\n                    handleData.unlock();\n                }\n                if (handleData.needRemove) {\n                    handleMap.remove(handleKey, handleData);\n                }\n                removeHandleMapKeyIfNeed(msgID);\n            });\n            return handleData;\n        });\n    }\n",
    "test_id": 29
  },
  "30": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveMultiThread",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testAddDuplicationHandle",
      ".org.apache.rocketmq.proxy.common.ReceiptHandleGroupTest#testRemoveMultiThread"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroup.java#remove",
    "focal_src": "    public MessageReceiptHandle remove(String msgID, String handle) {\n        Map<String, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(handle, (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to remove and get handle failed\");\n            }\n            try {\n                if (!handleData.needRemove) {\n                    handleData.needRemove = true;\n                    res.set(handleData.messageReceiptHandle);\n                }\n                return null;\n            } finally {\n                handleData.unlock();\n            }\n        });\n        removeHandleMapKeyIfNeed(msgID);\n        return res.get();\n    }\n",
    "focal_tgt": "    public MessageReceiptHandle remove(String msgID, String handle) {\n        Map<HandleKey, HandleData> handleMap = this.receiptHandleMap.get(msgID);\n        if (handleMap == null) {\n            return null;\n        }\n        long timeout = ConfigurationManager.getProxyConfig().getLockTimeoutMsInHandleGroup();\n        AtomicReference<MessageReceiptHandle> res = new AtomicReference<>();\n        handleMap.computeIfPresent(new HandleKey(handle), (handleKey, handleData) -> {\n            if (!handleData.lock(timeout)) {\n                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"try to remove and get handle failed\");\n            }\n            try {\n                if (!handleData.needRemove) {\n                    handleData.needRemove = true;\n                    res.set(handleData.messageReceiptHandle);\n                }\n                return null;\n            } finally {\n                handleData.unlock();\n            }\n        });\n        removeHandleMapKeyIfNeed(msgID);\n        return res.get();\n    }\n",
    "test_id": 30
  },
  "31": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessagePollingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessagePollingTime"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java#receiveMessage",
    "focal_src": "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), receiptHandle, messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n",
    "focal_tgt": "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    request.getAttemptId(),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n",
    "test_id": 31
  },
  "32": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivityTest#testReceiveMessage"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java#receiveMessage",
    "focal_src": "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), receiptHandle, messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n",
    "focal_tgt": "    public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    request.getAttemptId(),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    receiptHandleProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }\n",
    "test_id": 32
  },
  "33": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ConsumerProcessorTest#testPopMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ConsumerProcessorTest#testPopMessage"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ConsumerProcessor.java#popMessage",
    "focal_src": "    public CompletableFuture<PopResult> popMessage(\n        ProxyContext ctx,\n        QueueSelector queueSelector,\n        String consumerGroup,\n        String topic,\n        int maxMsgNums,\n        long invisibleTime,\n        long pollTime,\n        int initMode,\n        SubscriptionData subscriptionData,\n        boolean fifo,\n        PopMessageResultFilter popMessageResultFilter,\n        long timeoutMillis\n    ) {\n        CompletableFuture<PopResult> future = new CompletableFuture<>();\n        try {\n            AddressableMessageQueue messageQueue = queueSelector.select(ctx, this.serviceManager.getTopicRouteService().getCurrentMessageQueueView(ctx, topic));\n            if (messageQueue == null) {\n                throw new ProxyException(ProxyExceptionCode.FORBIDDEN, \"no readable queue\");\n            }\n            return popMessage(ctx, messageQueue, consumerGroup, topic, maxMsgNums, invisibleTime, pollTime, initMode, subscriptionData, fifo, popMessageResultFilter, timeoutMillis);\n        }  catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n",
    "focal_tgt": "    public CompletableFuture<PopResult> popMessage(\n        ProxyContext ctx,\n        QueueSelector queueSelector,\n        String consumerGroup,\n        String topic,\n        int maxMsgNums,\n        long invisibleTime,\n        long pollTime,\n        int initMode,\n        SubscriptionData subscriptionData,\n        boolean fifo,\n        PopMessageResultFilter popMessageResultFilter,\n        String attemptId,\n        long timeoutMillis\n    ) {\n        CompletableFuture<PopResult> future = new CompletableFuture<>();\n        try {\n            AddressableMessageQueue messageQueue = queueSelector.select(ctx, this.serviceManager.getTopicRouteService().getCurrentMessageQueueView(ctx, topic));\n            if (messageQueue == null) {\n                throw new ProxyException(ProxyExceptionCode.FORBIDDEN, \"no readable queue\");\n            }\n            return popMessage(ctx, messageQueue, consumerGroup, topic, maxMsgNums, invisibleTime, pollTime, initMode,\n                subscriptionData, fifo, popMessageResultFilter, attemptId, timeoutMillis);\n        }  catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n",
    "test_id": 33
  },
  "34": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddReceiptHandle",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 34
  },
  "35": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 35
  },
  "36": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 36
  },
  "37": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 37
  },
  "38": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 38
  },
  "39": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 39
  },
  "40": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 40
  },
  "41": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 41
  },
  "42": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewExceedMaxRenewTimes"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 42
  },
  "43": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 43
  },
  "44": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 44
  },
  "45": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 45
  },
  "46": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithInvalidHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 46
  },
  "47": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 47
  },
  "48": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 48
  },
  "49": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 49
  },
  "50": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewWithErrorThenOK"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 50
  },
  "51": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 51
  },
  "52": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 52
  },
  "53": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 53
  },
  "54": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeout"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 54
  },
  "55": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 55
  },
  "56": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 56
  },
  "57": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 57
  },
  "58": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenTimeoutWithNoSubscription"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 58
  },
  "59": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 59
  },
  "60": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 60
  },
  "61": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 61
  },
  "62": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRenewReceiptHandleWhenNotArrivingTime"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 62
  },
  "63": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 63
  },
  "64": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 64
  },
  "65": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 65
  },
  "66": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testRemoveReceiptHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 66
  },
  "67": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 67
  },
  "68": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 68
  },
  "69": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 69
  },
  "70": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClearGroup"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 70
  },
  "71": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 71
  },
  "72": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 72
  },
  "73": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    public void addReceiptHandle(ProxyContext ctx, Channel channel, String group, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        this.addReceiptHandle(ctx, new ReceiptHandleGroupKey(channel, group), msgID, messageReceiptHandle);\n    }\n",
    "test_id": 73
  },
  "74": {
    "commit_src": "c96a0b56658b48b17b762a1d2894e6d0576acad1",
    "commit_tgt": "8ab99aceb704e4c8906b9d6d57c97143a59b04c7",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/common/ReceiptHandleGroupTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-6755",
    "test_src": ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testAddDuplicationMessage",
      ".org.apache.rocketmq.proxy.processor.ReceiptHandleProcessorTest#testClientOffline"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ReceiptHandleProcessor.java#addReceiptHandle",
    "focal_src": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, String receiptHandle,\n        MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, receiptHandle, messageReceiptHandle);\n    }\n",
    "focal_tgt": "    protected void addReceiptHandle(ProxyContext ctx, ReceiptHandleGroupKey key, String msgID, MessageReceiptHandle messageReceiptHandle) {\n        if (key == null) {\n            return;\n        }\n        ConcurrentHashMapUtils.computeIfAbsent(this.receiptHandleGroupMap, key,\n            k -> new ReceiptHandleGroup()).put(msgID, messageReceiptHandle);\n    }\n",
    "test_id": 74
  },
  "75": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, String ckInfo) {\n        String[] ckInfoList = ExtraInfoUtil.split(ckInfo);\n        long popTime = ExtraInfoUtil.getPopTime(ckInfoList);\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, ExtraInfoUtil.getQueueId(ckInfoList));\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(String topic, String group, long popTime, int qId, int delta) {\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, qId, delta);\n    }\n",
    "test_id": 75
  },
  "76": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, String ckInfo) {\n        String[] ckInfoList = ExtraInfoUtil.split(ckInfo);\n        long popTime = ExtraInfoUtil.getPopTime(ckInfoList);\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, ExtraInfoUtil.getQueueId(ckInfoList));\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId(), 1);\n    }\n",
    "test_id": 76
  },
  "77": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, String ckInfo) {\n        String[] ckInfoList = ExtraInfoUtil.split(ckInfo);\n        long popTime = ExtraInfoUtil.getPopTime(ckInfoList);\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, ExtraInfoUtil.getQueueId(ckInfoList));\n    }\n",
    "focal_tgt": "    private void decrementInFlightMessageNum(String topic, String group, int queueId, int delta) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.addAndGet(-delta) <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "test_id": 77
  },
  "78": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId());\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(String topic, String group, long popTime, int qId, int delta) {\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, qId, delta);\n    }\n",
    "test_id": 78
  },
  "79": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId());\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId(), 1);\n    }\n",
    "test_id": 79
  },
  "80": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId());\n    }\n",
    "focal_tgt": "    private void decrementInFlightMessageNum(String topic, String group, int queueId, int delta) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.addAndGet(-delta) <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "test_id": 80
  },
  "81": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, int queueId) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.decrementAndGet() <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(String topic, String group, long popTime, int qId, int delta) {\n        if (popTime < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(topic, group, qId, delta);\n    }\n",
    "test_id": 81
  },
  "82": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, int queueId) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.decrementAndGet() <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "focal_tgt": "    public void decrementInFlightMessageNum(PopCheckPoint checkPoint) {\n        if (checkPoint.getPopTime() < this.brokerController.getShouldStartTime()) {\n            return;\n        }\n        decrementInFlightMessageNum(checkPoint.getTopic(), checkPoint.getCId(), checkPoint.getQueueId(), 1);\n    }\n",
    "test_id": 82
  },
  "83": {
    "commit_src": "3ac885705d9fa36870c1b059e1089c158fa66285",
    "commit_tgt": "6238caaac92fb1870f5eb234ddce86f3be045c79",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AckMessageProcessorTest.java",
      "broker/src/test/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounterTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/protocol/body/BatchAckTest.java"
    ],
    "refer_PR": "apache_rocketmq-6842",
    "test_src": ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum",
    "test_tgt": [
      ".org.apache.rocketmq.broker.processor.PopInflightMessageCounterTest#testNum"
    ],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/PopInflightMessageCounter.java#decrementInFlightMessageNum",
    "focal_src": "    public void decrementInFlightMessageNum(String topic, String group, int queueId) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.decrementAndGet() <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "focal_tgt": "    private void decrementInFlightMessageNum(String topic, String group, int queueId, int delta) {\n        topicInFlightMessageNum.computeIfPresent(buildKey(topic, group), (key, queueNum) -> {\n            queueNum.computeIfPresent(queueId, (queueIdKey, counter) -> {\n                if (counter.addAndGet(-delta) <= 0) {\n                    return null;\n                }\n                return counter;\n            });\n            if (queueNum.isEmpty()) {\n                return null;\n            }\n            return queueNum;\n        });\n    }\n",
    "test_id": 83
  },
  "84": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.remoting.activity.SendMessageActivityTest#testSendMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.remoting.activity.SendMessageActivityTest#testSendMessage"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivity.java#sendMessage",
    "focal_src": "    protected RemotingCommand sendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        SendMessageRequestHeader requestHeader = SendMessageRequestHeader.parseRequestHeader(request);\n        String topic = requestHeader.getTopic();\n        Map<String, String> property = MessageDecoder.string2messageProperties(requestHeader.getProperties());\n        TopicMessageType messageType = TopicMessageType.parseFromMessageProperty(property);\n        if (ConfigurationManager.getProxyConfig().isEnableTopicMessageTypeCheck()) {\n            if (topicMessageTypeValidator != null) {\n                // Do not check retry or dlq topic\n                if (!NamespaceUtil.isRetryTopic(topic) && !NamespaceUtil.isDLQTopic(topic)) {\n                    TopicMessageType topicMessageType = messagingProcessor.getMetadataService().getTopicMessageType(topic);\n                    topicMessageTypeValidator.validate(topicMessageType, messageType);\n                }\n            }\n        }\n        if (!NamespaceUtil.isRetryTopic(topic) && !NamespaceUtil.isDLQTopic(topic)) {\n            if (TopicMessageType.TRANSACTION.equals(messageType)) {\n                messagingProcessor.addTransactionSubscription(context, requestHeader.getProducerGroup(), requestHeader.getTopic());\n            }\n        }\n        return request(ctx, request, context, Duration.ofSeconds(3).toMillis());\n    }\n",
    "focal_tgt": "    protected RemotingCommand sendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        SendMessageRequestHeader requestHeader = SendMessageRequestHeader.parseRequestHeader(request);\n        String topic = requestHeader.getTopic();\n        Map<String, String> property = MessageDecoder.string2messageProperties(requestHeader.getProperties());\n        TopicMessageType messageType = TopicMessageType.parseFromMessageProperty(property);\n        if (ConfigurationManager.getProxyConfig().isEnableTopicMessageTypeCheck()) {\n            if (topicMessageTypeValidator != null) {\n                // Do not check retry or dlq topic\n                if (!NamespaceUtil.isRetryTopic(topic) && !NamespaceUtil.isDLQTopic(topic)) {\n                    TopicMessageType topicMessageType = messagingProcessor.getMetadataService().getTopicMessageType(context, topic);\n                    topicMessageTypeValidator.validate(topicMessageType, messageType);\n                }\n            }\n        }\n        if (!NamespaceUtil.isRetryTopic(topic) && !NamespaceUtil.isDLQTopic(topic)) {\n            if (TopicMessageType.TRANSACTION.equals(messageType)) {\n                messagingProcessor.addTransactionSubscription(context, requestHeader.getProducerGroup(), requestHeader.getTopic());\n            }\n        }\n        return request(ctx, request, context, Duration.ofSeconds(3).toMillis());\n    }\n",
    "test_id": 84
  },
  "85": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.message.ClusterMessageServiceTest#testAckMessageByInvalidBrokerNameHandle",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.message.ClusterMessageServiceTest#testAckMessageByInvalidBrokerNameHandle"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/message/ClusterMessageService.java#ackMessage",
    "focal_src": "    @Override\n    public CompletableFuture<AckResult> ackMessage(ProxyContext ctx, ReceiptHandle handle, String messageId,\n        AckMessageRequestHeader requestHeader, long timeoutMillis) {\n        return this.mqClientAPIFactory.getClient().ackMessageAsync(\n            this.resolveBrokerAddrInReceiptHandle(handle),\n            requestHeader,\n            timeoutMillis\n        );\n    }\n",
    "focal_tgt": "    @Override\n    public CompletableFuture<AckResult> ackMessage(ProxyContext ctx, ReceiptHandle handle, String messageId,\n        AckMessageRequestHeader requestHeader, long timeoutMillis) {\n        return this.mqClientAPIFactory.getClient().ackMessageAsync(\n            this.resolveBrokerAddrInReceiptHandle(ctx, handle),\n            requestHeader,\n            timeoutMillis\n        );\n    }\n",
    "test_id": 85
  },
  "86": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetTopicMessageType",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetTopicMessageType"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataService.java#getTopicMessageType",
    "focal_src": "    @Override\n    public TopicMessageType getTopicMessageType(String topic) {\n        TopicConfigAndQueueMapping topicConfigAndQueueMapping;\n        try {\n            topicConfigAndQueueMapping = topicConfigCache.get(topic);\n        } catch (Exception e) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        if (topicConfigAndQueueMapping.equals(EMPTY_TOPIC_CONFIG)) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        return topicConfigAndQueueMapping.getTopicMessageType();\n    }\n",
    "focal_tgt": "    @Override\n    public TopicMessageType getTopicMessageType(ProxyContext ctx, String topic) {\n        TopicConfigAndQueueMapping topicConfigAndQueueMapping;\n        try {\n            topicConfigAndQueueMapping = topicConfigCache.get(topic);\n        } catch (Exception e) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        if (topicConfigAndQueueMapping.equals(EMPTY_TOPIC_CONFIG)) {\n            return TopicMessageType.UNSPECIFIED;\n        }\n        return topicConfigAndQueueMapping.getTopicMessageType();\n    }\n",
    "test_id": 86
  },
  "87": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetSubscriptionGroupConfig",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.metadata.ClusterMetadataServiceTest#testGetSubscriptionGroupConfig"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataService.java#getSubscriptionGroupConfig",
    "focal_src": "    @Override\n    public SubscriptionGroupConfig getSubscriptionGroupConfig(String group) {\n        SubscriptionGroupConfig config;\n        try {\n            config = this.subscriptionGroupConfigCache.get(group);\n        } catch (Exception e) {\n            return null;\n        }\n        if (config == EMPTY_SUBSCRIPTION_GROUP_CONFIG) {\n            return null;\n        }\n        return config;\n    }\n",
    "focal_tgt": "    @Override\n    public SubscriptionGroupConfig getSubscriptionGroupConfig(ProxyContext ctx, String group) {\n        SubscriptionGroupConfig config;\n        try {\n            config = this.subscriptionGroupConfigCache.get(group);\n        } catch (Exception e) {\n            return null;\n        }\n        if (config == EMPTY_SUBSCRIPTION_GROUP_CONFIG) {\n            return null;\n        }\n        return config;\n    }\n",
    "test_id": 87
  },
  "88": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetCurrentMessageQueueView",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetCurrentMessageQueueView"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteService.java#getCurrentMessageQueueView",
    "focal_src": "    @Override\n    public MessageQueueView getCurrentMessageQueueView(String topicName) throws Exception {\n        return getAllMessageQueueView(topicName);\n    }\n",
    "focal_tgt": "    @Override\n    public MessageQueueView getCurrentMessageQueueView(ProxyContext ctx, String topicName) throws Exception {\n        return getAllMessageQueueView(ctx, topicName);\n    }\n",
    "test_id": 88
  },
  "89": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetTopicRouteForProxy",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.ClusterTopicRouteServiceTest#testGetTopicRouteForProxy"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteService.java#getTopicRouteForProxy",
    "focal_src": "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        TopicRouteData topicRouteData = getAllMessageQueueView(topicName).getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                proxyBrokerData.getBrokerAddrs().put(brokerId, requestHostAndPortList);\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n",
    "focal_tgt": "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(ProxyContext ctx, List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        TopicRouteData topicRouteData = getAllMessageQueueView(ctx, topicName).getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                proxyBrokerData.getBrokerAddrs().put(brokerId, requestHostAndPortList);\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n",
    "test_id": 89
  },
  "90": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetCurrentMessageQueueView",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetCurrentMessageQueueView"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteService.java#getCurrentMessageQueueView",
    "focal_src": "    @Override\n    public MessageQueueView getCurrentMessageQueueView(String topic) throws Exception {\n        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().getTopicConfigTable().get(topic);\n        return new MessageQueueView(topic, toTopicRouteData(topicConfig));\n    }\n",
    "focal_tgt": "    @Override\n    public MessageQueueView getCurrentMessageQueueView(ProxyContext ctx, String topic) throws Exception {\n        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().getTopicConfigTable().get(topic);\n        return new MessageQueueView(topic, toTopicRouteData(topicConfig));\n    }\n",
    "test_id": 90
  },
  "91": {
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/TransactionProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/SendMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/BaseServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/metadata/ClusterMetadataServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/ClusterTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/AbstractTransactionServiceTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/transaction/ClusterTransactionServiceTest.java"
    ],
    "refer_PR": "apache_rocketmq-6859",
    "test_src": ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetTopicRouteForProxy",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.route.LocalTopicRouteServiceTest#testGetTopicRouteForProxy"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/route/LocalTopicRouteService.java#getTopicRouteForProxy",
    "focal_src": "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        MessageQueueView messageQueueView = getAllMessageQueueView(topicName);\n        TopicRouteData topicRouteData = messageQueueView.getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                String brokerAddr = brokerData.getBrokerAddrs().get(brokerId);\n                HostAndPort brokerHostAndPort = HostAndPort.fromString(brokerAddr);\n                HostAndPort grpcHostAndPort = HostAndPort.fromParts(brokerHostAndPort.getHost(), grpcPort);\n\n                proxyBrokerData.getBrokerAddrs().put(brokerId, Lists.newArrayList(new Address(Address.AddressScheme.IPv4, grpcHostAndPort)));\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n",
    "focal_tgt": "    @Override\n    public ProxyTopicRouteData getTopicRouteForProxy(ProxyContext ctx, List<Address> requestHostAndPortList,\n        String topicName) throws Exception {\n        MessageQueueView messageQueueView = getAllMessageQueueView(ctx, topicName);\n        TopicRouteData topicRouteData = messageQueueView.getTopicRouteData();\n\n        ProxyTopicRouteData proxyTopicRouteData = new ProxyTopicRouteData();\n        proxyTopicRouteData.setQueueDatas(topicRouteData.getQueueDatas());\n\n        for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n            ProxyTopicRouteData.ProxyBrokerData proxyBrokerData = new ProxyTopicRouteData.ProxyBrokerData();\n            proxyBrokerData.setCluster(brokerData.getCluster());\n            proxyBrokerData.setBrokerName(brokerData.getBrokerName());\n            for (Long brokerId : brokerData.getBrokerAddrs().keySet()) {\n                String brokerAddr = brokerData.getBrokerAddrs().get(brokerId);\n                HostAndPort brokerHostAndPort = HostAndPort.fromString(brokerAddr);\n                HostAndPort grpcHostAndPort = HostAndPort.fromParts(brokerHostAndPort.getHost(), grpcPort);\n\n                proxyBrokerData.getBrokerAddrs().put(brokerId, Lists.newArrayList(new Address(Address.AddressScheme.IPv4, grpcHostAndPort)));\n            }\n            proxyTopicRouteData.getBrokerDatas().add(proxyBrokerData);\n        }\n\n        return proxyTopicRouteData;\n    }\n",
    "test_id": 91
  },
  "92": {
    "commit_src": "737c1e53383350a5671fa207ee0e4ce932850bac",
    "commit_tgt": "7996ec3b3f7ccea01f66951ac639b48303bbf7a6",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtilsTest.java"
    ],
    "refer_PR": "apache_rocketmq-6883",
    "test_src": ".org.apache.rocketmq.common.utils.ConcurrentHashMapUtilsTest#computeIfAbsent",
    "test_tgt": [
      ".org.apache.rocketmq.common.utils.ConcurrentHashMapUtilsTest#computeIfAbsent"
    ],
    "focal_path": "common/src/main/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtils.java#computeIfAbsent",
    "focal_src": "    /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br> Use implementation of\n     * ConcurrentMap.computeIfAbsent instead.\n     *\n     * @see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\n    public static <K, V> V computeIfAbsent(ConcurrentMap<K, V> map, K key, Function<? super K, ? extends V> func) {\n        if (isJdk8) {\n            V v = map.get(key);\n            if (null == v) {\n                v = map.computeIfAbsent(key, func);\n            }\n            return v;\n        } else {\n            return map.computeIfAbsent(key, func);\n        }\n    }\n",
    "focal_tgt": "    /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br> Use implementation of\n     * ConcurrentMap.computeIfAbsent instead.\n     *\n     * @see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\n    public static <K, V> V computeIfAbsent(ConcurrentMap<K, V> map, K key, Function<? super K, ? extends V> func) {\n        Objects.requireNonNull(func);\n        if (isJdk8) {\n            V v = map.get(key);\n            if (null == v) {\n//                v = map.computeIfAbsent(key, func);\n\n                // this bug fix methods maybe cause `func.apply` multiple calls.\n                v = func.apply(key);\n                if (null == v) {\n                    return null;\n                }\n                final V res = map.putIfAbsent(key, v);\n                if (null != res) {\n                    // if pre value present, means other thread put value already, and putIfAbsent not effect\n                    // return exist value\n                    return res;\n                }\n            }\n            return v;\n        } else {\n            return map.computeIfAbsent(key, func);\n        }\n    }\n",
    "test_id": 92
  },
  "93": {
    "commit_src": "3dda55e812240ee5bb667d078fb49acc13f0ccb4",
    "commit_tgt": "aea5811df007c2abf2d46eea931e4c867514e0eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6885",
    "test_src": ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncGrpcV2Channel",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncGrpcV2Channel"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncer.java#HeartbeatSyncer",
    "focal_src": "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n        ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory) {\n        super(topicRouteService, adminService, mqClientAPIFactory);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n",
    "focal_tgt": "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n                           ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory, RPCHook rpcHook) {\n        super(topicRouteService, adminService, mqClientAPIFactory, rpcHook);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n",
    "test_id": 93
  },
  "94": {
    "commit_src": "3dda55e812240ee5bb667d078fb49acc13f0ccb4",
    "commit_tgt": "aea5811df007c2abf2d46eea931e4c867514e0eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6885",
    "test_src": ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncRemotingChannel",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.sysmessage.HeartbeatSyncerTest#testSyncRemotingChannel"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/sysmessage/HeartbeatSyncer.java#HeartbeatSyncer",
    "focal_src": "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n        ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory) {\n        super(topicRouteService, adminService, mqClientAPIFactory);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n",
    "focal_tgt": "    protected final Map<String /* group @ channelId as longText */, RemoteChannel> remoteChannelMap = new ConcurrentHashMap<>();\n    protected String localProxyId;\n\n    public HeartbeatSyncer(TopicRouteService topicRouteService, AdminService adminService,\n                           ConsumerManager consumerManager, MQClientAPIFactory mqClientAPIFactory, RPCHook rpcHook) {\n        super(topicRouteService, adminService, mqClientAPIFactory, rpcHook);\n        this.consumerManager = consumerManager;\n        this.localProxyId = buildLocalProxyId();\n        this.init();\n    }\n",
    "test_id": 94
  },
  "95": {
    "commit_src": "e369d7deac6e4dde950a8da7c3d976bb26d0e6b5",
    "commit_tgt": "16ef5755375e7c8f4fb11dd63f5fdfdfa25668e7",
    "changed_tests": [
      "client/src/test/java/org/apache/rocketmq/client/trace/TraceDataEncoderTest.java"
    ],
    "refer_PR": "apache_rocketmq-6941",
    "test_src": ".org.apache.rocketmq.client.trace.TraceDataEncoderTest#testSubAfterTraceDataFormatTest",
    "test_tgt": [
      ".org.apache.rocketmq.client.trace.TraceDataEncoderTest#testSubAfterTraceDataFormatTest"
    ],
    "focal_path": "client/src/main/java/org/apache/rocketmq/client/trace/TraceDataEncoder.java#encoderFromContextBean",
    "focal_src": "    /**\n     * Encoding the trace context into data strings and keyset sets\n     *\n     * @param ctx\n     * @return\n     */\n    public static TraceTransferBean encoderFromContextBean(TraceContext ctx) {\n        if (ctx == null) {\n            return null;\n        }\n        //build message trace of the transferring entity content bean\n        TraceTransferBean transferBean = new TraceTransferBean();\n        StringBuilder sb = new StringBuilder(256);\n        switch (ctx.getTraceType()) {\n            case Pub: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                //append the content of context and traceBean to transferBean's TransData\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getBodyLength()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getOffsetMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.isSuccess()).append(TraceConstants.FIELD_SPLITOR);//\n            }\n            break;\n            case SubBefore: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getRetryTimes()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.FIELD_SPLITOR);//\n                }\n            }\n            break;\n            case SubAfter: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.isSuccess()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getContextCode()).append(TraceConstants.CONTENT_SPLITOR)\n                        .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)\n                        .append(ctx.getGroupName()).append(TraceConstants.FIELD_SPLITOR);\n                }\n            }\n            break;\n            case EndTransaction: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionState().name()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.isFromTransactionCheck()).append(TraceConstants.FIELD_SPLITOR);\n            }\n            break;\n            default:\n        }\n        transferBean.setTransData(sb.toString());\n        for (TraceBean bean : ctx.getTraceBeans()) {\n\n            transferBean.getTransKey().add(bean.getMsgId());\n            if (bean.getKeys() != null && bean.getKeys().length() > 0) {\n                String[] keys = bean.getKeys().split(MessageConst.KEY_SEPARATOR);\n                transferBean.getTransKey().addAll(Arrays.asList(keys));\n            }\n        }\n        return transferBean;\n    }\n",
    "focal_tgt": "    /**\n     * Encoding the trace context into data strings and keyset sets\n     *\n     * @param ctx\n     * @return\n     */\n    public static TraceTransferBean encoderFromContextBean(TraceContext ctx) {\n        if (ctx == null) {\n            return null;\n        }\n        //build message trace of the transferring entity content bean\n        TraceTransferBean transferBean = new TraceTransferBean();\n        StringBuilder sb = new StringBuilder(256);\n        switch (ctx.getTraceType()) {\n            case Pub: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                //append the content of context and traceBean to transferBean's TransData\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getBodyLength()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getOffsetMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.isSuccess()).append(TraceConstants.FIELD_SPLITOR);//\n            }\n            break;\n            case SubBefore: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getRetryTimes()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.FIELD_SPLITOR);//\n                }\n            }\n            break;\n            case SubAfter: {\n                for (TraceBean bean : ctx.getTraceBeans()) {\n                    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.isSuccess()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                        .append(ctx.getContextCode()).append(TraceConstants.CONTENT_SPLITOR);\n                    if (!ctx.getAccessChannel().equals(AccessChannel.CLOUD)) {\n                        sb.append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)\n                            .append(ctx.getGroupName()).append(TraceConstants.FIELD_SPLITOR);\n                    }\n                }\n            }\n            break;\n            case EndTransaction: {\n                TraceBean bean = ctx.getTraceBeans().get(0);\n                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionId()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.getTransactionState().name()).append(TraceConstants.CONTENT_SPLITOR)//\n                    .append(bean.isFromTransactionCheck()).append(TraceConstants.FIELD_SPLITOR);\n            }\n            break;\n            default:\n        }\n        transferBean.setTransData(sb.toString());\n        for (TraceBean bean : ctx.getTraceBeans()) {\n\n            transferBean.getTransKey().add(bean.getMsgId());\n            if (bean.getKeys() != null && bean.getKeys().length() > 0) {\n                String[] keys = bean.getKeys().split(MessageConst.KEY_SEPARATOR);\n                transferBean.getTransKey().addAll(Arrays.asList(keys));\n            }\n        }\n        return transferBean;\n    }\n",
    "test_id": 95
  },
  "96": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetProducerData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetProducerData"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#getClientSettings",
    "focal_src": "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = CLIENT_SETTINGS_MAP.get(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "focal_tgt": "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = getRawClientSettings(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "test_id": 96
  },
  "97": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetProducerData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetProducerData"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#updateClientSettings",
    "focal_src": "    public void updateClientSettings(String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n",
    "focal_tgt": "    public void updateClientSettings(ProxyContext ctx, String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n",
    "test_id": 97
  },
  "98": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#getClientSettings",
    "focal_src": "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = CLIENT_SETTINGS_MAP.get(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "focal_tgt": "    public Settings getClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = getRawClientSettings(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasPublishing()) {\n            settings = mergeProducerData(settings);\n        } else if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "test_id": 98
  },
  "99": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#updateClientSettings",
    "focal_src": "    public void updateClientSettings(String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n",
    "focal_tgt": "    public void updateClientSettings(ProxyContext ctx, String clientId, Settings settings) {\n        if (settings.hasSubscription()) {\n            settings = createDefaultConsumerSettingsBuilder().mergeFrom(settings).build();\n        }\n        CLIENT_SETTINGS_MAP.put(clientId, settings);\n    }\n",
    "test_id": 99
  },
  "100": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManagerTest#testGetSubscriptionData"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManager.java#removeAndGetClientSettings",
    "focal_src": "    public Settings removeAndGetClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = CLIENT_SETTINGS_MAP.remove(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "focal_tgt": "    public Settings removeAndGetClientSettings(ProxyContext ctx) {\n        String clientId = ctx.getClientID();\n        Settings settings = this.removeAndGetRawClientSettings(clientId);\n        if (settings == null) {\n            return null;\n        }\n        if (settings.hasSubscription()) {\n            settings = mergeSubscriptionData(ctx, settings,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(settings.getSubscription().getGroup()));\n        }\n        return mergeMetric(settings);\n    }\n",
    "test_id": 100
  },
  "101": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithoutSub",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithoutSub"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivity.java#processRequest0",
    "focal_src": "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n",
    "focal_tgt": "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(context, requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n",
    "test_id": 101
  },
  "102": {
    "commit_src": "87075c26623c2c40486c4189e2fb1855426a8ae9",
    "commit_tgt": "bbbe737e4e57ebc32581220fa8766cf32f7833eb",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/client/ClientActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcClientSettingsManagerTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/remoting/channel/RemotingChannelManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-6965",
    "test_src": ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithSub",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.remoting.activity.PullMessageActivityTest#testPullMessageWithSub"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/PullMessageActivity.java#processRequest0",
    "focal_src": "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n",
    "focal_tgt": "    @Override\n    protected RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n        ProxyContext context) throws Exception {\n        PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n        int sysFlag = requestHeader.getSysFlag();\n        if (!PullSysFlag.hasSubscriptionFlag(sysFlag)) {\n            ConsumerGroupInfo consumerInfo = messagingProcessor.getConsumerGroupInfo(context, requestHeader.getConsumerGroup());\n            if (consumerInfo == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_LATEST,\n                    \"the consumer's subscription not latest\");\n            }\n            SubscriptionData subscriptionData = consumerInfo.findSubscriptionData(requestHeader.getTopic());\n            if (subscriptionData == null) {\n                return RemotingCommand.buildErrorResponse(ResponseCode.SUBSCRIPTION_NOT_EXIST,\n                    \"the consumer's subscription not exist\");\n            }\n            requestHeader.setSysFlag(PullSysFlag.buildSysFlagWithSubscription(sysFlag));\n            requestHeader.setSubscription(subscriptionData.getSubString());\n            requestHeader.setExpressionType(subscriptionData.getExpressionType());\n            request.writeCustomHeader(requestHeader);\n            request.makeCustomHeaderToNet();\n        }\n        long timeoutMillis = requestHeader.getSuspendTimeoutMillis() + Duration.ofSeconds(10).toMillis();\n        return request(ctx, request, context, timeoutMillis);\n    }\n",
    "test_id": 102
  },
  "103": {
    "commit_src": "a1bf49d5d07cf64374bc3dde5ab43add831433ad",
    "commit_tgt": "ab61183030f4f230619ea539cbd2cb977234208b",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManagerTest.java"
    ],
    "refer_PR": "apache_rocketmq-7105",
    "test_src": ".org.apache.rocketmq.proxy.service.receipt.DefaultReceiptHandleManagerTest#testClearGroup",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.service.receipt.DefaultReceiptHandleManagerTest#testClearGroup"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/service/receipt/DefaultReceiptHandleManager.java#clearGroup",
    "focal_src": "    protected void clearGroup(ReceiptHandleProcessor.ReceiptHandleGroupKey key) {\n        if (key == null) {\n            return;\n        }\n        ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n        ReceiptHandleGroup handleGroup = receiptHandleGroupMap.remove(key);\n        if (handleGroup == null) {\n            return;\n        }\n        handleGroup.scan((msgID, handle, v) -> {\n            try {\n                handleGroup.computeIfPresent(msgID, handle, messageReceiptHandle -> {\n                    CompletableFuture<AckResult> future = new CompletableFuture<>();\n                    eventListener.fireEvent(new RenewEvent(messageReceiptHandle, proxyConfig.getInvisibleTimeMillisWhenClear(), RenewEvent.EventType.CLEAR_GROUP, future));\n                    return CompletableFuture.completedFuture(null);\n                });\n            } catch (Exception e) {\n                log.error(\"error when clear handle for group. key:{}\", key, e);\n            }\n        });\n    }\n",
    "focal_tgt": "    protected void clearGroup(ReceiptHandleGroupKey key) {\n        if (key == null) {\n            return;\n        }\n        ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n        ReceiptHandleGroup handleGroup = receiptHandleGroupMap.remove(key);\n        if (handleGroup == null) {\n            return;\n        }\n        handleGroup.scan((msgID, handle, v) -> {\n            try {\n                handleGroup.computeIfPresent(msgID, handle, messageReceiptHandle -> {\n                    CompletableFuture<AckResult> future = new CompletableFuture<>();\n                    eventListener.fireEvent(new RenewEvent(key, messageReceiptHandle, proxyConfig.getInvisibleTimeMillisWhenClear(), RenewEvent.EventType.CLEAR_GROUP, future));\n                    return CompletableFuture.completedFuture(null);\n                });\n            } catch (Exception e) {\n                log.error(\"error when clear handle for group. key:{}\", key, e);\n            }\n        });\n    }\n",
    "test_id": 103
  },
  "104": {
    "commit_src": "017ad110475e8024585327b44f47e5e97aabc63b",
    "commit_tgt": "77e8e54b37c3fc3ea0beffc1ace6f5bf20af10d9",
    "changed_tests": [
      "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/AckMessageActivityTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/BaseProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ConsumerProcessorTest.java",
      "proxy/src/test/java/org/apache/rocketmq/proxy/service/mqclient/MQClientAPIExtTest.java"
    ],
    "refer_PR": "apache_rocketmq-7225",
    "test_src": ".org.apache.rocketmq.proxy.grpc.v2.consumer.AckMessageActivityTest#testAckMessage",
    "test_tgt": [
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.AckMessageActivityTest#testAckMessage",
      ".org.apache.rocketmq.proxy.grpc.v2.consumer.AckMessageActivityTest#testAckMessageInBatch"
    ],
    "focal_path": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/AckMessageActivity.java#ackMessage",
    "focal_src": "    public CompletableFuture<AckMessageResponse> ackMessage(ProxyContext ctx, AckMessageRequest request) {\n        CompletableFuture<AckMessageResponse> future = new CompletableFuture<>();\n\n        try {\n            validateTopicAndConsumerGroup(request.getTopic(), request.getGroup());\n\n            CompletableFuture<AckMessageResultEntry>[] futures = new CompletableFuture[request.getEntriesCount()];\n            for (int i = 0; i < request.getEntriesCount(); i++) {\n                futures[i] = processAckMessage(ctx, request, request.getEntries(i));\n            }\n            CompletableFuture.allOf(futures).whenComplete((val, throwable) -> {\n                if (throwable != null) {\n                    future.completeExceptionally(throwable);\n                    return;\n                }\n\n                Set<Code> responseCodes = new HashSet<>();\n                List<AckMessageResultEntry> entryList = new ArrayList<>();\n                for (CompletableFuture<AckMessageResultEntry> entryFuture : futures) {\n                    AckMessageResultEntry entryResult = entryFuture.join();\n                    responseCodes.add(entryResult.getStatus().getCode());\n                    entryList.add(entryResult);\n                }\n                AckMessageResponse.Builder responseBuilder = AckMessageResponse.newBuilder()\n                    .addAllEntries(entryList);\n                if (responseCodes.size() > 1) {\n                    responseBuilder.setStatus(ResponseBuilder.getInstance().buildStatus(Code.MULTIPLE_RESULTS, Code.MULTIPLE_RESULTS.name()));\n                } else if (responseCodes.size() == 1) {\n                    Code code = responseCodes.stream().findAny().get();\n                    responseBuilder.setStatus(ResponseBuilder.getInstance().buildStatus(code, code.name()));\n                } else {\n                    responseBuilder.setStatus(ResponseBuilder.getInstance().buildStatus(Code.INTERNAL_SERVER_ERROR, \"ack message result is empty\"));\n                }\n                future.complete(responseBuilder.build());\n            });\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n",
    "focal_tgt": "    public CompletableFuture<AckMessageResponse> ackMessage(ProxyContext ctx, AckMessageRequest request) {\n        CompletableFuture<AckMessageResponse> future = new CompletableFuture<>();\n\n        try {\n            validateTopicAndConsumerGroup(request.getTopic(), request.getGroup());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getTopic());\n            if (ConfigurationManager.getProxyConfig().isEnableBatchAck()) {\n                future = ackMessageInBatch(ctx, group, topic, request);\n            } else {\n                future = ackMessageOneByOne(ctx, group, topic, request);\n            }\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }\n",
    "test_id": 104
  },
  "105": {
    "commit_src": "c36bb78e850129b9db40adc5b0e1b9bfd5c8fd2e",
    "commit_tgt": "84156084a4c5228e1d2fe21e068fff330bbc40d1",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/RemotingServerTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannel.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannelPromise.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstractTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingClientTest.java"
    ],
    "refer_PR": "apache_rocketmq-7322",
    "test_src": ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand"
    ],
    "focal_path": "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand",
    "focal_src": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, but not matched any request, \" + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n            log.warn(cmd.toString());\n        }\n    }\n",
    "focal_tgt": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, cmd={}, but not matched any request, address={}\", cmd, RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n    }\n",
    "test_id": 105
  },
  "106": {
    "commit_src": "c36bb78e850129b9db40adc5b0e1b9bfd5c8fd2e",
    "commit_tgt": "84156084a4c5228e1d2fe21e068fff330bbc40d1",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/RemotingServerTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannel.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannelPromise.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstractTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingClientTest.java"
    ],
    "refer_PR": "apache_rocketmq-7322",
    "test_src": ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand_RunCallBackInCurrentThread",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessResponseCommand_RunCallBackInCurrentThread"
    ],
    "focal_path": "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand",
    "focal_src": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, but not matched any request, \" + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n            log.warn(cmd.toString());\n        }\n    }\n",
    "focal_tgt": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, cmd={}, but not matched any request, address={}\", cmd, RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n    }\n",
    "test_id": 106
  },
  "107": {
    "commit_src": "c36bb78e850129b9db40adc5b0e1b9bfd5c8fd2e",
    "commit_tgt": "84156084a4c5228e1d2fe21e068fff330bbc40d1",
    "changed_tests": [
      "remoting/src/test/java/org/apache/rocketmq/remoting/RemotingServerTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannel.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/MockChannelPromise.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstractTest.java",
      "remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingClientTest.java"
    ],
    "refer_PR": "apache_rocketmq-7322",
    "test_src": ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessRequestCommand",
    "test_tgt": [
      ".org.apache.rocketmq.remoting.netty.NettyRemotingAbstractTest#testProcessRequestCommand"
    ],
    "focal_path": "remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java#processResponseCommand",
    "focal_src": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, but not matched any request, \" + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n            log.warn(cmd.toString());\n        }\n    }\n",
    "focal_tgt": "    /**\n     * Process response from remote peer to the previous issued requests.\n     *\n     * @param ctx channel handler context.\n     * @param cmd response command instance.\n     */\n    public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) {\n        final int opaque = cmd.getOpaque();\n        final ResponseFuture responseFuture = responseTable.get(opaque);\n        if (responseFuture != null) {\n            responseFuture.setResponseCommand(cmd);\n\n            responseTable.remove(opaque);\n\n            if (responseFuture.getInvokeCallback() != null) {\n                executeInvokeCallback(responseFuture);\n            } else {\n                responseFuture.putResponse(cmd);\n                responseFuture.release();\n            }\n        } else {\n            log.warn(\"receive response, cmd={}, but not matched any request, address={}\", cmd, RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n    }\n",
    "test_id": 107
  },
  "108": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testUpdateAndCreateTopicOnSlaveInRocksdb",
    "test_tgt": [],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#updateAndCreateTopic",
    "focal_src": "    private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        final CreateTopicRequestHeader requestHeader =\n            (CreateTopicRequestHeader) request.decodeCommandCustomHeader(CreateTopicRequestHeader.class);\n\n        LOGGER.info(\"Broker receive request to update or create topic={}, caller address={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        TopicConfig topicConfig = new TopicConfig(topic);\n        topicConfig.setReadQueueNums(requestHeader.getReadQueueNums());\n        topicConfig.setWriteQueueNums(requestHeader.getWriteQueueNums());\n        topicConfig.setTopicFilterType(requestHeader.getTopicFilterTypeEnum());\n        topicConfig.setPerm(requestHeader.getPerm());\n        topicConfig.setTopicSysFlag(requestHeader.getTopicSysFlag() == null ? 0 : requestHeader.getTopicSysFlag());\n        topicConfig.setOrder(requestHeader.getOrder());\n        String attributesModification = requestHeader.getAttributes();\n        topicConfig.setAttributes(AttributeParser.parseToMap(attributesModification));\n\n        if (topicConfig.getTopicMessageType() == TopicMessageType.MIXED\n            && !brokerController.getBrokerConfig().isEnableMixedMessageType()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"MIXED message type is not supported.\");\n            return response;\n        }\n\n        try {\n            this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);\n            if (brokerController.getBrokerConfig().isEnableSingleTopicRegister()) {\n                this.brokerController.registerSingleTopicAll(topicConfig);\n            } else {\n                this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());\n            }\n            response.setCode(ResponseCode.SUCCESS);\n        } catch (Exception e) {\n            LOGGER.error(\"Update / create topic failed for [{}]\", request, e);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(e.getMessage());\n        }\n\n        return response;\n    }\n",
    "focal_tgt": "    private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        final CreateTopicRequestHeader requestHeader =\n            (CreateTopicRequestHeader) request.decodeCommandCustomHeader(CreateTopicRequestHeader.class);\n\n        LOGGER.info(\"Broker receive request to update or create topic={}, caller address={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        TopicConfig topicConfig = new TopicConfig(topic);\n        topicConfig.setReadQueueNums(requestHeader.getReadQueueNums());\n        topicConfig.setWriteQueueNums(requestHeader.getWriteQueueNums());\n        topicConfig.setTopicFilterType(requestHeader.getTopicFilterTypeEnum());\n        topicConfig.setPerm(requestHeader.getPerm());\n        topicConfig.setTopicSysFlag(requestHeader.getTopicSysFlag() == null ? 0 : requestHeader.getTopicSysFlag());\n        topicConfig.setOrder(requestHeader.getOrder());\n        String attributesModification = requestHeader.getAttributes();\n        topicConfig.setAttributes(AttributeParser.parseToMap(attributesModification));\n\n        if (topicConfig.getTopicMessageType() == TopicMessageType.MIXED\n            && !brokerController.getBrokerConfig().isEnableMixedMessageType()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"MIXED message type is not supported.\");\n            return response;\n        }\n\n        try {\n            this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);\n            if (brokerController.getBrokerConfig().isEnableSingleTopicRegister()) {\n                this.brokerController.registerSingleTopicAll(topicConfig);\n            } else {\n                this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());\n            }\n            response.setCode(ResponseCode.SUCCESS);\n        } catch (Exception e) {\n            LOGGER.error(\"Update / create topic failed for [{}]\", request, e);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(e.getMessage());\n        }\n\n        return response;\n    }\n",
    "test_id": 108
  },
  "109": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testUpdateAndCreateTopicOnSlave",
    "test_tgt": [],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#updateAndCreateTopic",
    "focal_src": "    private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        final CreateTopicRequestHeader requestHeader =\n            (CreateTopicRequestHeader) request.decodeCommandCustomHeader(CreateTopicRequestHeader.class);\n\n        LOGGER.info(\"Broker receive request to update or create topic={}, caller address={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        TopicConfig topicConfig = new TopicConfig(topic);\n        topicConfig.setReadQueueNums(requestHeader.getReadQueueNums());\n        topicConfig.setWriteQueueNums(requestHeader.getWriteQueueNums());\n        topicConfig.setTopicFilterType(requestHeader.getTopicFilterTypeEnum());\n        topicConfig.setPerm(requestHeader.getPerm());\n        topicConfig.setTopicSysFlag(requestHeader.getTopicSysFlag() == null ? 0 : requestHeader.getTopicSysFlag());\n        topicConfig.setOrder(requestHeader.getOrder());\n        String attributesModification = requestHeader.getAttributes();\n        topicConfig.setAttributes(AttributeParser.parseToMap(attributesModification));\n\n        if (topicConfig.getTopicMessageType() == TopicMessageType.MIXED\n            && !brokerController.getBrokerConfig().isEnableMixedMessageType()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"MIXED message type is not supported.\");\n            return response;\n        }\n\n        try {\n            this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);\n            if (brokerController.getBrokerConfig().isEnableSingleTopicRegister()) {\n                this.brokerController.registerSingleTopicAll(topicConfig);\n            } else {\n                this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());\n            }\n            response.setCode(ResponseCode.SUCCESS);\n        } catch (Exception e) {\n            LOGGER.error(\"Update / create topic failed for [{}]\", request, e);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(e.getMessage());\n        }\n\n        return response;\n    }\n",
    "focal_tgt": "    private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        final CreateTopicRequestHeader requestHeader =\n            (CreateTopicRequestHeader) request.decodeCommandCustomHeader(CreateTopicRequestHeader.class);\n\n        LOGGER.info(\"Broker receive request to update or create topic={}, caller address={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        TopicConfig topicConfig = new TopicConfig(topic);\n        topicConfig.setReadQueueNums(requestHeader.getReadQueueNums());\n        topicConfig.setWriteQueueNums(requestHeader.getWriteQueueNums());\n        topicConfig.setTopicFilterType(requestHeader.getTopicFilterTypeEnum());\n        topicConfig.setPerm(requestHeader.getPerm());\n        topicConfig.setTopicSysFlag(requestHeader.getTopicSysFlag() == null ? 0 : requestHeader.getTopicSysFlag());\n        topicConfig.setOrder(requestHeader.getOrder());\n        String attributesModification = requestHeader.getAttributes();\n        topicConfig.setAttributes(AttributeParser.parseToMap(attributesModification));\n\n        if (topicConfig.getTopicMessageType() == TopicMessageType.MIXED\n            && !brokerController.getBrokerConfig().isEnableMixedMessageType()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"MIXED message type is not supported.\");\n            return response;\n        }\n\n        try {\n            this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);\n            if (brokerController.getBrokerConfig().isEnableSingleTopicRegister()) {\n                this.brokerController.registerSingleTopicAll(topicConfig);\n            } else {\n                this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());\n            }\n            response.setCode(ResponseCode.SUCCESS);\n        } catch (Exception e) {\n            LOGGER.error(\"Update / create topic failed for [{}]\", request, e);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(e.getMessage());\n        }\n\n        return response;\n    }\n",
    "test_id": 109
  },
  "110": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testDeleteTopicOnSlaveInRocksdb",
    "test_tgt": [],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#deleteTopic",
    "focal_src": "    private synchronized RemotingCommand deleteTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        DeleteTopicRequestHeader requestHeader =\n            (DeleteTopicRequestHeader) request.decodeCommandCustomHeader(DeleteTopicRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteTopic: broker receive request to delete topic={}, caller={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        final Set<String> groups = this.brokerController.getConsumerOffsetManager().whichGroupByTopic(topic);\n        // delete pop retry topics first\n        for (String group : groups) {\n            final String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n            if (brokerController.getTopicConfigManager().selectTopicConfig(popRetryTopic) != null) {\n                deleteTopicInBroker(popRetryTopic);\n            }\n        }\n        // delete topic\n        deleteTopicInBroker(topic);\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private synchronized RemotingCommand deleteTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        DeleteTopicRequestHeader requestHeader =\n            (DeleteTopicRequestHeader) request.decodeCommandCustomHeader(DeleteTopicRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteTopic: broker receive request to delete topic={}, caller={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        final Set<String> groups = this.brokerController.getConsumerOffsetManager().whichGroupByTopic(topic);\n        // delete pop retry topics first\n        for (String group : groups) {\n            final String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n            if (brokerController.getTopicConfigManager().selectTopicConfig(popRetryTopic) != null) {\n                deleteTopicInBroker(popRetryTopic);\n            }\n        }\n        // delete topic\n        deleteTopicInBroker(topic);\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 110
  },
  "111": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testDeleteTopicOnSlave",
    "test_tgt": [],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#deleteTopic",
    "focal_src": "    private synchronized RemotingCommand deleteTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        DeleteTopicRequestHeader requestHeader =\n            (DeleteTopicRequestHeader) request.decodeCommandCustomHeader(DeleteTopicRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteTopic: broker receive request to delete topic={}, caller={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        final Set<String> groups = this.brokerController.getConsumerOffsetManager().whichGroupByTopic(topic);\n        // delete pop retry topics first\n        for (String group : groups) {\n            final String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n            if (brokerController.getTopicConfigManager().selectTopicConfig(popRetryTopic) != null) {\n                deleteTopicInBroker(popRetryTopic);\n            }\n        }\n        // delete topic\n        deleteTopicInBroker(topic);\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private synchronized RemotingCommand deleteTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        DeleteTopicRequestHeader requestHeader =\n            (DeleteTopicRequestHeader) request.decodeCommandCustomHeader(DeleteTopicRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteTopic: broker receive request to delete topic={}, caller={}\",\n            requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        String topic = requestHeader.getTopic();\n        TopicValidator.ValidateTopicResult result = TopicValidator.validateTopic(topic);\n        if (!result.isValid()) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(result.getRemark());\n            return response;\n        }\n        if (brokerController.getBrokerConfig().isValidateSystemTopicWhenUpdateTopic()) {\n            if (TopicValidator.isSystemTopic(topic)) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"The topic[\" + topic + \"] is conflict with system topic.\");\n                return response;\n            }\n        }\n\n        final Set<String> groups = this.brokerController.getConsumerOffsetManager().whichGroupByTopic(topic);\n        // delete pop retry topics first\n        for (String group : groups) {\n            final String popRetryTopic = KeyBuilder.buildPopRetryTopic(topic, group);\n            if (brokerController.getTopicConfigManager().selectTopicConfig(popRetryTopic) != null) {\n                deleteTopicInBroker(popRetryTopic);\n            }\n        }\n        // delete topic\n        deleteTopicInBroker(topic);\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 111
  },
  "112": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testUpdateAndCreateSubscriptionGroupOnSlaveInRocksdb",
    "test_tgt": [],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#updateAndCreateSubscriptionGroup",
    "focal_src": "    private RemotingCommand updateAndCreateSubscriptionGroup(ChannelHandlerContext ctx, RemotingCommand request)\n        throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n\n        LOGGER.info(\"AdminBrokerProcessor#updateAndCreateSubscriptionGroup called by {}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        SubscriptionGroupConfig config = RemotingSerializable.decode(request.getBody(), SubscriptionGroupConfig.class);\n        if (config != null) {\n            this.brokerController.getSubscriptionGroupManager().updateSubscriptionGroupConfig(config);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private RemotingCommand updateAndCreateSubscriptionGroup(ChannelHandlerContext ctx, RemotingCommand request)\n        throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        LOGGER.info(\"AdminBrokerProcessor#updateAndCreateSubscriptionGroup called by {}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        SubscriptionGroupConfig config = RemotingSerializable.decode(request.getBody(), SubscriptionGroupConfig.class);\n        if (config != null) {\n            this.brokerController.getSubscriptionGroupManager().updateSubscriptionGroupConfig(config);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 112
  },
  "113": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testUpdateAndCreateSubscriptionGroupOnSlave",
    "test_tgt": [],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#updateAndCreateSubscriptionGroup",
    "focal_src": "    private RemotingCommand updateAndCreateSubscriptionGroup(ChannelHandlerContext ctx, RemotingCommand request)\n        throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n\n        LOGGER.info(\"AdminBrokerProcessor#updateAndCreateSubscriptionGroup called by {}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        SubscriptionGroupConfig config = RemotingSerializable.decode(request.getBody(), SubscriptionGroupConfig.class);\n        if (config != null) {\n            this.brokerController.getSubscriptionGroupManager().updateSubscriptionGroupConfig(config);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private RemotingCommand updateAndCreateSubscriptionGroup(ChannelHandlerContext ctx, RemotingCommand request)\n        throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        LOGGER.info(\"AdminBrokerProcessor#updateAndCreateSubscriptionGroup called by {}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        SubscriptionGroupConfig config = RemotingSerializable.decode(request.getBody(), SubscriptionGroupConfig.class);\n        if (config != null) {\n            this.brokerController.getSubscriptionGroupManager().updateSubscriptionGroupConfig(config);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 113
  },
  "114": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testDeleteSubscriptionGroupOnSlaveInRocksdb",
    "test_tgt": [],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#deleteSubscriptionGroup",
    "focal_src": "    private RemotingCommand deleteSubscriptionGroup(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        DeleteSubscriptionGroupRequestHeader requestHeader =\n            (DeleteSubscriptionGroupRequestHeader) request.decodeCommandCustomHeader(DeleteSubscriptionGroupRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteSubscriptionGroup, caller={}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        this.brokerController.getSubscriptionGroupManager().deleteSubscriptionGroupConfig(requestHeader.getGroupName());\n\n        if (requestHeader.isCleanOffset()) {\n            this.brokerController.getConsumerOffsetManager().removeOffset(requestHeader.getGroupName());\n            this.brokerController.getPopInflightMessageCounter().clearInFlightMessageNumByGroupName(requestHeader.getGroupName());\n        }\n\n        if (this.brokerController.getBrokerConfig().isAutoDeleteUnusedStats()) {\n            this.brokerController.getBrokerStatsManager().onGroupDeleted(requestHeader.getGroupName());\n        }\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private RemotingCommand deleteSubscriptionGroup(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        DeleteSubscriptionGroupRequestHeader requestHeader =\n            (DeleteSubscriptionGroupRequestHeader) request.decodeCommandCustomHeader(DeleteSubscriptionGroupRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteSubscriptionGroup, caller={}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        this.brokerController.getSubscriptionGroupManager().deleteSubscriptionGroupConfig(requestHeader.getGroupName());\n\n        if (requestHeader.isCleanOffset()) {\n            this.brokerController.getConsumerOffsetManager().removeOffset(requestHeader.getGroupName());\n            this.brokerController.getPopInflightMessageCounter().clearInFlightMessageNumByGroupName(requestHeader.getGroupName());\n        }\n\n        if (this.brokerController.getBrokerConfig().isAutoDeleteUnusedStats()) {\n            this.brokerController.getBrokerStatsManager().onGroupDeleted(requestHeader.getGroupName());\n        }\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 114
  },
  "115": {
    "commit_src": "fd32dae2ab59f86dd215eeec405bf4fa6212bcb3",
    "commit_tgt": "4a8e0d5b851d1f9573cda79b7d2e42ee498809da",
    "changed_tests": [
      "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java"
    ],
    "refer_PR": "apache_rocketmq-7352",
    "test_src": ".org.apache.rocketmq.broker.processor.AdminBrokerProcessorTest#testDeleteSubscriptionGroupOnSlave",
    "test_tgt": [],
    "focal_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java#deleteSubscriptionGroup",
    "focal_src": "    private RemotingCommand deleteSubscriptionGroup(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        if (validateSlave(response)) {\n            return response;\n        }\n        DeleteSubscriptionGroupRequestHeader requestHeader =\n            (DeleteSubscriptionGroupRequestHeader) request.decodeCommandCustomHeader(DeleteSubscriptionGroupRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteSubscriptionGroup, caller={}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        this.brokerController.getSubscriptionGroupManager().deleteSubscriptionGroupConfig(requestHeader.getGroupName());\n\n        if (requestHeader.isCleanOffset()) {\n            this.brokerController.getConsumerOffsetManager().removeOffset(requestHeader.getGroupName());\n            this.brokerController.getPopInflightMessageCounter().clearInFlightMessageNumByGroupName(requestHeader.getGroupName());\n        }\n\n        if (this.brokerController.getBrokerConfig().isAutoDeleteUnusedStats()) {\n            this.brokerController.getBrokerStatsManager().onGroupDeleted(requestHeader.getGroupName());\n        }\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "focal_tgt": "    private RemotingCommand deleteSubscriptionGroup(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        DeleteSubscriptionGroupRequestHeader requestHeader =\n            (DeleteSubscriptionGroupRequestHeader) request.decodeCommandCustomHeader(DeleteSubscriptionGroupRequestHeader.class);\n\n        LOGGER.info(\"AdminBrokerProcessor#deleteSubscriptionGroup, caller={}\",\n            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        this.brokerController.getSubscriptionGroupManager().deleteSubscriptionGroupConfig(requestHeader.getGroupName());\n\n        if (requestHeader.isCleanOffset()) {\n            this.brokerController.getConsumerOffsetManager().removeOffset(requestHeader.getGroupName());\n            this.brokerController.getPopInflightMessageCounter().clearInFlightMessageNumByGroupName(requestHeader.getGroupName());\n        }\n\n        if (this.brokerController.getBrokerConfig().isAutoDeleteUnusedStats()) {\n            this.brokerController.getBrokerStatsManager().onGroupDeleted(requestHeader.getGroupName());\n        }\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
    "test_id": 115
  },
  "116": {
    "commit_src": "73b3fde83765e066541e3455cd1e6604292a9b7c",
    "commit_tgt": "88a9d939ce110381b3b418370d4711c0c214dc7f",
    "changed_tests": [
      "store/src/test/java/org/apache/rocketmq/store/timer/TimerMetricsTest.java"
    ],
    "refer_PR": "apache_rocketmq-7382",
    "test_src": ".org.apache.rocketmq.store.timer.TimerMetricsTest#testTimingCount",
    "test_tgt": [
      ".org.apache.rocketmq.store.timer.TimerMetricsTest#testTimingCount"
    ],
    "focal_path": "store/src/main/java/org/apache/rocketmq/store/timer/TimerMetrics.java#addAndGet",
    "focal_src": "    public long addAndGet(String topic, int value) {\n        Metric pair = getTopicPair(topic);\n        getDataVersion().nextVersion();\n        pair.setTimeStamp(System.currentTimeMillis());\n        return pair.getCount().addAndGet(value);\n    }\n",
    "focal_tgt": "    public long addAndGet(MessageExt msg, int value) {\n        String topic = msg.getProperty(MessageConst.PROPERTY_REAL_TOPIC);\n        Metric pair = getTopicPair(topic);\n        getDataVersion().nextVersion();\n        pair.setTimeStamp(System.currentTimeMillis());\n        return pair.getCount().addAndGet(value);\n    }\n",
    "test_id": 116
  },
  "117": {
    "commit_src": "84285d13a7d056a444e52f0f58e713b9a6343c08",
    "commit_tgt": "af1936d93ad9adab9527e19ceb5c89bb3a907e49",
    "changed_tests": [
      "common/src/test/java/org/apache/rocketmq/common/MixAllTest.java",
      "common/src/test/java/org/apache/rocketmq/common/NetworkUtilTest.java",
      "common/src/test/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtilsTest.java"
    ],
    "refer_PR": "apache_rocketmq-7714",
    "test_src": ".org.apache.rocketmq.common.MixAllTest#testGetLocalhostByNetworkInterface",
    "test_tgt": [],
    "focal_path": "common/src/main/java/org/apache/rocketmq/common/MixAll.java#getLocalhostByNetworkInterface",
    "focal_src": "    public static String getLocalhostByNetworkInterface() throws SocketException {\n        List<String> candidatesHost = new ArrayList<>();\n        Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n\n        while (enumeration.hasMoreElements()) {\n            NetworkInterface networkInterface = enumeration.nextElement();\n            // Workaround for docker0 bridge\n            if (\"docker0\".equals(networkInterface.getName()) || !networkInterface.isUp()) {\n                continue;\n            }\n            Enumeration<InetAddress> addrs = networkInterface.getInetAddresses();\n            while (addrs.hasMoreElements()) {\n                InetAddress address = addrs.nextElement();\n                if (address.isLoopbackAddress()) {\n                    continue;\n                }\n                //ip4 higher priority\n                if (address instanceof Inet6Address) {\n                    candidatesHost.add(address.getHostAddress());\n                    continue;\n                }\n                return address.getHostAddress();\n            }\n        }\n\n        if (!candidatesHost.isEmpty()) {\n            return candidatesHost.get(0);\n        }\n        return null;\n    }\n",
    "focal_tgt": "    public static String getLocalhostByNetworkInterface() throws SocketException {\n        List<String> candidatesHost = new ArrayList<>();\n        Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n\n        while (enumeration.hasMoreElements()) {\n            NetworkInterface networkInterface = enumeration.nextElement();\n            // Workaround for docker0 bridge\n            if (\"docker0\".equals(networkInterface.getName()) || !networkInterface.isUp()) {\n                continue;\n            }\n            Enumeration<InetAddress> addrs = networkInterface.getInetAddresses();\n            while (addrs.hasMoreElements()) {\n                InetAddress address = addrs.nextElement();\n                if (address.isLoopbackAddress()) {\n                    continue;\n                }\n                //ip4 higher priority\n                if (address instanceof Inet6Address) {\n                    candidatesHost.add(address.getHostAddress());\n                    continue;\n                }\n                return address.getHostAddress();\n            }\n        }\n\n        if (!candidatesHost.isEmpty()) {\n            return candidatesHost.get(0);\n        }\n\n        // Fallback to loopback \n        return localhost();\n    }\n",
    "test_id": 117
  }
}